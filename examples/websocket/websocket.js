var vnode = function (sel, data, children, text, elm) {
  var key = data === undefined ? undefined : data.key;
  return { sel: sel, data: data, children: children,
    text: text, elm: elm, key: key };
};

var is$1 = {
  array: Array.isArray,
  primitive: function (s) {
    return typeof s === 'string' || typeof s === 'number';
  }
};

function createElement(tagName) {
  return document.createElement(tagName);
}

function createElementNS(namespaceURI, qualifiedName) {
  return document.createElementNS(namespaceURI, qualifiedName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentElement;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

var htmldomapi = {
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  appendChild: appendChild,
  removeChild: removeChild,
  insertBefore: insertBefore,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent
};

var VNode = vnode;
var is = is$1;
var domApi = htmldomapi;

function isUndef(s) {
  return s === undefined;
}
function isDef(s) {
  return s !== undefined;
}

var emptyNode = VNode('', {}, [], undefined, undefined);

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i,
      map = {},
      key;
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) map[key] = i;
  }
  return map;
}

var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

function init(modules, api) {
  var i,
      j,
      cbs = {};

  if (isUndef(api)) api = domApi;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
    }
  }

  function emptyNodeAt(elm) {
    var id = elm.id ? '#' + elm.id : '';
    var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
    return VNode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    return function () {
      if (--listeners === 0) {
        var parent = api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  function createElm(vnode$$1, insertedVnodeQueue) {
    var i,
        data = vnode$$1.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode$$1);
        data = vnode$$1.data;
      }
    }
    var elm,
        children = vnode$$1.children,
        sel = vnode$$1.sel;
    if (isDef(sel)) {
      // Parse selector
      var hashIdx = sel.indexOf('#');
      var dotIdx = sel.indexOf('.', hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      elm = vnode$$1.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag) : api.createElement(tag);
      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
      if (dotIdx > 0) elm.className = sel.slice(dot + 1).replace(/\./g, ' ');
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          api.appendChild(elm, createElm(children[i], insertedVnodeQueue));
        }
      } else if (is.primitive(vnode$$1.text)) {
        api.appendChild(elm, api.createTextNode(vnode$$1.text));
      }
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode$$1);
      i = vnode$$1.data.hook; // Reuse variable
      if (isDef(i)) {
        if (i.create) i.create(emptyNode, vnode$$1);
        if (i.insert) insertedVnodeQueue.push(vnode$$1);
      }
    } else {
      elm = vnode$$1.elm = api.createTextNode(vnode$$1.text);
    }
    return vnode$$1.elm;
  }

  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
    }
  }

  function invokeDestroyHook(vnode$$1) {
    var i,
        j,
        data = vnode$$1.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode$$1);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode$$1);
      if (isDef(i = vnode$$1.children)) {
        for (j = 0; j < vnode$$1.children.length; ++j) {
          invokeDestroyHook(vnode$$1.children[j]);
        }
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i,
          listeners,
          rm,
          ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
            i(ch, rm);
          } else {
            rm();
          }
        } else {
          // Text node
          api.removeChild(parentElm, ch.elm);
        }
      }
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0,
        newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, before;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) {
          // New element
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
          oldCh[idxInOld] = undefined;
          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode$$1, insertedVnodeQueue) {
    var i, hook;
    if (isDef(i = vnode$$1.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
      i(oldVnode, vnode$$1);
    }
    var elm = vnode$$1.elm = oldVnode.elm,
        oldCh = oldVnode.children,
        ch = vnode$$1.children;
    if (oldVnode === vnode$$1) return;
    if (!sameVnode(oldVnode, vnode$$1)) {
      var parentElm = api.parentNode(oldVnode.elm);
      elm = createElm(vnode$$1, insertedVnodeQueue);
      api.insertBefore(parentElm, elm, oldVnode.elm);
      removeVnodes(parentElm, [oldVnode], 0, 0);
      return;
    }
    if (isDef(vnode$$1.data)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode$$1);
      i = vnode$$1.data.hook;
      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode$$1);
    }
    if (isUndef(vnode$$1.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, '');
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode$$1.text) {
      api.setTextContent(elm, vnode$$1.text);
    }
    if (isDef(hook) && isDef(i = hook.postpatch)) {
      i(oldVnode, vnode$$1);
    }
  }

  return function (oldVnode, vnode$$1) {
    var i, elm, parent;
    var insertedVnodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();

    if (isUndef(oldVnode.sel)) {
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode$$1)) {
      patchVnode(oldVnode, vnode$$1, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent = api.parentNode(elm);

      createElm(vnode$$1, insertedVnodeQueue);

      if (parent !== null) {
        api.insertBefore(parent, vnode$$1.elm, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }

    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode$$1;
  };
}

var snabbdom = { init: init };

var VNode$1 = vnode;
var is$3 = is$1;

function addNS(data, children, sel) {
  data.ns = 'http://www.w3.org/2000/svg';

  if (sel !== 'foreignObject' && children !== undefined) {
    for (var i = 0; i < children.length; ++i) {
      addNS(children[i].data, children[i].children, children[i].sel);
    }
  }
}

var h = function h(sel, b, c) {
  var data = {},
      children,
      text,
      i;
  if (c !== undefined) {
    data = b;
    if (is$3.array(c)) {
      children = c;
    } else if (is$3.primitive(c)) {
      text = c;
    }
  } else if (b !== undefined) {
    if (is$3.array(b)) {
      children = b;
    } else if (is$3.primitive(b)) {
      text = b;
    } else {
      data = b;
    }
  }
  if (is$3.array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (is$3.primitive(children[i])) children[i] = VNode$1(undefined, undefined, undefined, children[i]);
    }
  }
  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
    addNS(data, children, sel);
  }
  return VNode$1(sel, data, children, text, undefined);
};

function updateClass(oldVnode, vnode) {
  var cur,
      name,
      elm = vnode.elm,
      oldClass = oldVnode.data.class,
      klass = vnode.data.class;

  if (!oldClass && !klass) return;
  oldClass = oldClass || {};
  klass = klass || {};

  for (name in oldClass) {
    if (!klass[name]) {
      elm.classList.remove(name);
    }
  }
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? 'add' : 'remove'](name);
    }
  }
}

var _class = { create: updateClass, update: updateClass };

function updateProps(oldVnode, vnode) {
  var key,
      cur,
      old,
      elm = vnode.elm,
      oldProps = oldVnode.data.props,
      props = vnode.data.props;

  if (!oldProps && !props) return;
  oldProps = oldProps || {};
  props = props || {};

  for (key in oldProps) {
    if (!props[key]) {
      delete elm[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}

var props = { create: updateProps, update: updateProps };

var raf = typeof window !== 'undefined' && window.requestAnimationFrame || setTimeout;
var nextFrame = function (fn) {
  raf(function () {
    raf(fn);
  });
};

function setNextFrame(obj, prop, val) {
  nextFrame(function () {
    obj[prop] = val;
  });
}

function updateStyle(oldVnode, vnode) {
  var cur,
      name,
      elm = vnode.elm,
      oldStyle = oldVnode.data.style,
      style = vnode.data.style;

  if (!oldStyle && !style) return;
  oldStyle = oldStyle || {};
  style = style || {};
  var oldHasDel = 'delayed' in oldStyle;

  for (name in oldStyle) {
    if (!style[name]) {
      elm.style[name] = '';
    }
  }
  for (name in style) {
    cur = style[name];
    if (name === 'delayed') {
      for (name in style.delayed) {
        cur = style.delayed[name];
        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
          setNextFrame(elm.style, name, cur);
        }
      }
    } else if (name !== 'remove' && cur !== oldStyle[name]) {
      elm.style[name] = cur;
    }
  }
}

function applyDestroyStyle(vnode) {
  var style,
      name,
      elm = vnode.elm,
      s = vnode.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}

function applyRemoveStyle(vnode, rm) {
  var s = vnode.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name,
      elm = vnode.elm,
      idx,
      i = 0,
      maxDur = 0,
      compStyle,
      style = s.remove,
      amount = 0,
      applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle['transition-property'].split(', ');
  for (; i < props.length; ++i) {
    if (applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener('transitionend', function (ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}

var style = { create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle };

function invokeHandler(handler, vnode, event) {
  if (typeof handler === "function") {
    // call function handler
    handler.call(vnode, event, vnode);
  } else if (typeof handler === "object") {
    // call handler with arguments
    if (typeof handler[0] === "function") {
      // special case for single argument for performance
      if (handler.length === 2) {
        handler[0].call(vnode, handler[1], event, vnode);
      } else {
        var args = handler.slice(1);
        args.push(event);
        args.push(vnode);
        handler[0].apply(vnode, args);
      }
    } else {
      // call multiple handlers
      for (var i = 0; i < handler.length; i++) {
        invokeHandler(handler[i]);
      }
    }
  }
}

function handleEvent(event, vnode) {
  var name = event.type,
      on = vnode.data.on;

  // call event handler(s) if exists
  if (on && on[name]) {
    invokeHandler(on[name], vnode, event);
  }
}

function createListener() {
  return function handler(event) {
    handleEvent(event, handler.vnode);
  };
}

function updateEventListeners(oldVnode, vnode) {
  var oldOn = oldVnode.data.on,
      oldListener = oldVnode.listener,
      oldElm = oldVnode.elm,
      on = vnode && vnode.data.on,
      elm = vnode && vnode.elm,
      name;

  // optimization for reused immutable handlers
  if (oldOn === on) {
    return;
  }

  // remove existing listeners which no longer used
  if (oldOn && oldListener) {
    // if element changed or deleted we remove all existing listeners unconditionally
    if (!on) {
      for (name in oldOn) {
        // remove listener if element was changed or existing listeners removed
        oldElm.removeEventListener(name, oldListener, false);
      }
    } else {
      for (name in oldOn) {
        // remove listener if existing listener removed
        if (!on[name]) {
          oldElm.removeEventListener(name, oldListener, false);
        }
      }
    }
  }

  // add new listeners which has not already attached
  if (on) {
    // reuse existing listener or create new
    var listener = vnode.listener = oldVnode.listener || createListener();
    // update vnode for listener
    listener.vnode = vnode;

    // if element changed or added we add all needed listeners unconditionally
    if (!oldOn) {
      for (name in on) {
        // add listener if element was changed or new listeners added
        elm.addEventListener(name, listener, false);
      }
    } else {
      for (name in on) {
        // add listener if new listener added
        if (!oldOn[name]) {
          elm.addEventListener(name, listener, false);
        }
      }
    }
  }
}

var eventlisteners = {
  create: updateEventListeners,
  update: updateEventListeners,
  destroy: updateEventListeners
};

function convertToHyperScript(node) {
  if (Array.isArray(node)) {
    let [sel, data, children] = node;

    if (Array.isArray(children)) {
      return h(sel, data, children.map(convertToHyperScript));
    }
    return h.apply(null, node);
  }
  return node;
}

function render(view$, container) {
  let patch = snabbdom.init([_class, props, style, eventlisteners]);
  let vnode = container;

  view$.map(convertToHyperScript).subscribe(newVnode => {
    patch(vnode, newVnode);
    vnode = newVnode;
  });
}

var isWebSocket = function (constructor) {
    return constructor && constructor.CLOSING === 2;
};
var isGlobalWebSocket = function () {
    return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);
};
var getDefaultOptions = function () {
    return {
        constructor: isGlobalWebSocket() ? WebSocket : null,
        maxReconnectionDelay: 10000,
        minReconnectionDelay: 1500,
        reconnectionDelayGrowFactor: 1.3,
        connectionTimeout: 4000,
        maxRetries: Infinity,
        debug: false
    };
};
var bypassProperty = function (src, dst, name) {
    Object.defineProperty(dst, name, {
        get: function () {
            return src[name];
        },
        set: function (value) {
            src[name] = value;
        },
        enumerable: true,
        configurable: true
    });
};
var initReconnectionDelay = function (config) {
    return config.minReconnectionDelay + Math.random() * config.minReconnectionDelay;
};
var updateReconnectionDelay = function (config, previousDelay) {
    var newDelay = previousDelay * config.reconnectionDelayGrowFactor;
    return newDelay > config.maxReconnectionDelay ? config.maxReconnectionDelay : newDelay;
};
var LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];
var reassignEventListeners = function (ws, oldWs, listeners) {
    Object.keys(listeners).forEach(function (type) {
        listeners[type].forEach(function (_a) {
            var listener = _a[0],
                options = _a[1];
            ws.addEventListener(type, listener, options);
        });
    });
    if (oldWs) {
        LEVEL_0_EVENTS.forEach(function (name) {
            ws[name] = oldWs[name];
        });
    }
};
var ReconnectingWebsocket = function (url, protocols, options) {
    var _this = this;
    if (options === void 0) {
        options = {};
    }
    var ws;
    var connectingTimeout;
    var reconnectDelay = 0;
    var retriesCount = 0;
    var shouldRetry = true;
    var savedOnClose = null;
    var listeners = {};
    // require new to construct
    if (!(this instanceof ReconnectingWebsocket)) {
        throw new TypeError("Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator");
    }
    // Set config. Not using `Object.assign` because of IE11
    var config = getDefaultOptions();
    Object.keys(config).filter(function (key) {
        return options.hasOwnProperty(key);
    }).forEach(function (key) {
        return config[key] = options[key];
    });
    if (!isWebSocket(config.constructor)) {
        throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');
    }
    var log = config.debug ? function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i - 0] = arguments[_i];
        }
        return console.log.apply(console, ['RWS:'].concat(params));
    } : function () {};
    /**
     * Not using dispatchEvent, otherwise we must use a DOM Event object
     * Deferred because we want to handle the close event before this
     */
    var emitError = function (code, msg) {
        return setTimeout(function () {
            var err = new Error(msg);
            err.code = code;
            if (Array.isArray(listeners.error)) {
                listeners.error.forEach(function (_a) {
                    var fn = _a[0];
                    return fn(err);
                });
            }
            if (ws.onerror) {
                ws.onerror(err);
            }
        }, 0);
    };
    var handleClose = function () {
        log('close');
        retriesCount++;
        log('retries count:', retriesCount);
        if (retriesCount > config.maxRetries) {
            emitError('EHOSTDOWN', 'Too many failed connection attempts');
            return;
        }
        if (!reconnectDelay) {
            reconnectDelay = initReconnectionDelay(config);
        } else {
            reconnectDelay = updateReconnectionDelay(config, reconnectDelay);
        }
        log('reconnectDelay:', reconnectDelay);
        if (shouldRetry) {
            setTimeout(connect, reconnectDelay);
        }
    };
    var connect = function () {
        log('connect');
        var oldWs = ws;
        ws = new config.constructor(url, protocols);
        connectingTimeout = setTimeout(function () {
            log('timeout');
            ws.close();
            emitError('ETIMEDOUT', 'Connection timeout');
        }, config.connectionTimeout);
        log('bypass properties');
        for (var key in ws) {
            // @todo move to constant
            if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {
                bypassProperty(ws, _this, key);
            }
        }
        ws.addEventListener('open', function () {
            clearTimeout(connectingTimeout);
            log('open');
            reconnectDelay = initReconnectionDelay(config);
            log('reconnectDelay:', reconnectDelay);
            retriesCount = 0;
        });
        ws.addEventListener('close', handleClose);
        reassignEventListeners(ws, oldWs, listeners);
        // because when closing with fastClose=true, it is saved and set to null to avoid double calls
        ws.onclose = ws.onclose || savedOnClose;
        savedOnClose = null;
    };
    log('init');
    connect();
    this.close = function (code, reason, _a) {
        if (code === void 0) {
            code = 1000;
        }
        if (reason === void 0) {
            reason = '';
        }
        var _b = _a === void 0 ? {} : _a,
            _c = _b.keepClosed,
            keepClosed = _c === void 0 ? false : _c,
            _d = _b.fastClose,
            fastClose = _d === void 0 ? true : _d,
            _e = _b.delay,
            delay = _e === void 0 ? 0 : _e;
        if (delay) {
            reconnectDelay = delay;
        }
        shouldRetry = !keepClosed;
        ws.close(code, reason);
        if (fastClose) {
            var fakeCloseEvent_1 = {
                code: code,
                reason: reason,
                wasClean: true
            };
            // execute close listeners soon with a fake closeEvent
            // and remove them from the WS instance so they
            // don't get fired on the real close.
            handleClose();
            ws.removeEventListener('close', handleClose);
            // run and remove level2
            if (Array.isArray(listeners.close)) {
                listeners.close.forEach(function (_a) {
                    var listener = _a[0],
                        options = _a[1];
                    listener(fakeCloseEvent_1);
                    ws.removeEventListener('close', listener, options);
                });
            }
            // run and remove level0
            if (ws.onclose) {
                savedOnClose = ws.onclose;
                ws.onclose(fakeCloseEvent_1);
                ws.onclose = null;
            }
        }
    };
    this.send = function (data) {
        ws.send(data);
    };
    this.addEventListener = function (type, listener, options) {
        if (Array.isArray(listeners[type])) {
            if (!listeners[type].some(function (_a) {
                var l = _a[0];
                return l === listener;
            })) {
                listeners[type].push([listener, options]);
            }
        } else {
            listeners[type] = [[listener, options]];
        }
        ws.addEventListener(type, listener, options);
    };
    this.removeEventListener = function (type, listener, options) {
        if (Array.isArray(listeners[type])) {
            listeners[type] = listeners[type].filter(function (_a) {
                var l = _a[0];
                return l !== listener;
            });
        }
        ws.removeEventListener(type, listener, options);
    };
};
var index$1 = ReconnectingWebsocket;

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var root = createCommonjsModule(function (module, exports) {
    "use strict";
    /**
     * window: browser in DOM main thread
     * self: browser in WebWorker
     * global: Node.js/other
     */

    exports.root = typeof window == 'object' && window.window === window && window || typeof self == 'object' && self.self === self && self || typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal;
    if (!exports.root) {
        throw new Error('RxJS could not find any global context (window, self, global)');
    }
    });

function isFunction(x) {
  return typeof x === 'function';
}
var isFunction_2 = isFunction;

var isFunction_1$1 = {
  isFunction: isFunction_2
};

var isArray_1$1 = Array.isArray || function (x) {
	return x && typeof x.length === 'number';
};

var isArray = {
	isArray: isArray_1$1
};

function isObject(x) {
  return x != null && typeof x === 'object';
}
var isObject_2 = isObject;

var isObject_1$1 = {
  isObject: isObject_2
};

// typeof any so that it we don't have to cast when comparing a result to the error object

var errorObject_1$2 = { e: {} };

var errorObject = {
	errorObject: errorObject_1$2
};

var errorObject_1$1 = errorObject;
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1$1.errorObject.e = e;
        return errorObject_1$1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
var tryCatch_2 = tryCatch;


var tryCatch_1$1 = {
    tryCatch: tryCatch_2
};

var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError$1 = function (_super) {
    __extends$2(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
var UnsubscriptionError_2 = UnsubscriptionError$1;

var UnsubscriptionError_1$2 = {
    UnsubscriptionError: UnsubscriptionError_2
};

var isArray_1 = isArray;
var isObject_1 = isObject_1$1;
var isFunction_1$3 = isFunction_1$1;
var tryCatch_1 = tryCatch_1$1;
var errorObject_1 = errorObject;
var UnsubscriptionError_1$1 = UnsubscriptionError_1$2;
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription$1 = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        this.closed = true;
        var _a = this,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1$3.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                (errors = errors || []).push(errorObject_1.errorObject.e);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1$1.UnsubscriptionError) {
                            errors = errors.concat(err.errors);
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1$1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.closed || typeof sub.unsubscribe !== 'function') {
                    break;
                } else if (this.closed) {
                    sub.unsubscribe();
                } else {
                    (this._subscriptions || (this._subscriptions = [])).push(sub);
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        return sub;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
var Subscription_2 = Subscription$1;

var Subscription_1$3 = {
    Subscription: Subscription_2
};

var empty = {
    closed: true,
    next: function (value) {},
    error: function (err) {
        throw err;
    },
    complete: function () {}
};

var Observer = {
    empty: empty
};

var root_1$2 = root;
var Symbol$1 = root_1$2.root.Symbol;
var $$rxSubscriber = typeof Symbol$1 === 'function' && typeof Symbol$1.for === 'function' ? Symbol$1.for('rxSubscriber') : '@@rxSubscriber';

var rxSubscriber = {
  $$rxSubscriber: $$rxSubscriber
};

var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = isFunction_1$1;
var Subscription_1$2 = Subscription_1$3;
var Observer_1$1 = Observer;
var rxSubscriber_1$3 = rxSubscriber;
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber$1 = function (_super) {
    __extends$1(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1$1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1$1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1$3.$$rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    return Subscriber;
}(Subscription_1$2.Subscription);
var Subscriber_2 = Subscriber$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends$1(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber$1);

var Subscriber_1$3 = {
    Subscriber: Subscriber_2
};

var Subscriber_1$2 = Subscriber_1$3;
var rxSubscriber_1$2 = rxSubscriber;
var Observer_1 = Observer;
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1$2.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1$2.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1$2.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1$2.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1$2.Subscriber(nextOrObserver, error, complete);
}
var toSubscriber_2 = toSubscriber;

var toSubscriber_1$1 = {
    toSubscriber: toSubscriber_2
};

var root_1$3 = root;
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        } else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
var getSymbolObservable_1 = getSymbolObservable;
var $$observable = getSymbolObservable(root_1$3.root);

var observable = {
    getSymbolObservable: getSymbolObservable_1,
    $$observable: $$observable
};

var root_1 = root;
var toSubscriber_1 = toSubscriber_1$1;
var observable_1$1 = observable;
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable$1 = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable$$1 = new Observable();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this._subscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1$1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
var Observable_2 = Observable$1;

var Observable_1$2 = {
    Observable: Observable_2
};

var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError$1 = function (_super) {
    __extends$3(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
var ObjectUnsubscribedError_2 = ObjectUnsubscribedError$1;

var ObjectUnsubscribedError_1$2 = {
    ObjectUnsubscribedError: ObjectUnsubscribedError_2
};

var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1$5 = Subscription_1$3;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends$4(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1$5.Subscription);
var SubjectSubscription_2 = SubjectSubscription;

var SubjectSubscription_1$1 = {
    SubjectSubscription: SubjectSubscription_2
};

var __extends = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$1 = Observable_1$2;
var Subscriber_1$1 = Subscriber_1$3;
var Subscription_1$1 = Subscription_1$3;
var ObjectUnsubscribedError_1$1 = ObjectUnsubscribedError_1$2;
var SubjectSubscription_1 = SubjectSubscription_1$1;
var rxSubscriber_1$1 = rxSubscriber;
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1$1.Subscriber);
var SubjectSubscriber_1 = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject$1 = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1$1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject$1(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1$1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1$1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1$1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject$1(destination, source);
    };
    return Subject;
}(Observable_1$1.Observable);
var Subject_2 = Subject$1;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject$1 = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1$1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject$1);
var AnonymousSubject_1 = AnonymousSubject$1;

var Subject_1$1 = {
    SubjectSubscriber: SubjectSubscriber_1,
    Subject: Subject_2,
    AnonymousSubject: AnonymousSubject_1
};

var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$3 = Subject_1$1;
var Subscription_1$6 = Subscription_1$3;
/**
 * @class AsyncSubject<T>
 */
var AsyncSubject$1 = function (_super) {
    __extends$6(AsyncSubject, _super);
    function AsyncSubject() {
        _super.apply(this, arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1$6.Subscription.EMPTY;
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1$6.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1$3.Subject);
var AsyncSubject_2 = AsyncSubject$1;

var AsyncSubject_1$2 = {
    AsyncSubject: AsyncSubject_2
};

var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$5 = Observable_1$2;
var tryCatch_1$3 = tryCatch_1$1;
var errorObject_1$3 = errorObject;
var AsyncSubject_1$1 = AsyncSubject_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var BoundCallbackObservable = function (_super) {
    __extends$5(BoundCallbackObservable, _super);
    function BoundCallbackObservable(callbackFunc, selector, args, scheduler) {
        _super.call(this);
        this.callbackFunc = callbackFunc;
        this.selector = selector;
        this.args = args;
        this.scheduler = scheduler;
    }
    /* tslint:enable:max-line-length */
    /**
     * Converts a callback API to a function that returns an Observable.
     *
     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
     * it will return a function `g` that when called as `g(x)` will output an
     * Observable.</span>
     *
     * `bindCallback` is not an operator because its input and output are not
     * Observables. The input is a function `func` with some parameters, but the
     * last parameter must be a callback function that `func` calls when it is
     * done. The output of `bindCallback` is a function that takes the same
     * parameters as `func`, except the last one (the callback). When the output
     * function is called with arguments, it will return an Observable where the
     * results will be delivered to.
     *
     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
     * // Suppose we have jQuery.getJSON('/my/url', callback)
     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
     * var result = getJSONAsObservable('/my/url');
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindNodeCallback}
     * @see {@link from}
     * @see {@link fromPromise}
     *
     * @param {function} func Function with a callback as the last parameter.
     * @param {function} [selector] A function which takes the arguments from the
     * callback and maps those a value to emit on the output Observable.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * callbacks.
     * @return {function(...params: *): Observable} A function which returns the
     * Observable that delivers the same values the callback would deliver.
     * @static true
     * @name bindCallback
     * @owner Observable
     */
    BoundCallbackObservable.create = function (func, selector, scheduler) {
        if (selector === void 0) {
            selector = undefined;
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return new BoundCallbackObservable(func, selector, args, scheduler);
        };
    };
    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
        var callbackFunc = this.callbackFunc;
        var args = this.args;
        var scheduler = this.scheduler;
        var subject = this.subject;
        if (!scheduler) {
            if (!subject) {
                subject = this.subject = new AsyncSubject_1$1.AsyncSubject();
                var handler = function handlerFn() {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i - 0] = arguments[_i];
                    }
                    var source = handlerFn.source;
                    var selector = source.selector,
                        subject = source.subject;
                    if (selector) {
                        var result_1 = tryCatch_1$3.tryCatch(selector).apply(this, innerArgs);
                        if (result_1 === errorObject_1$3.errorObject) {
                            subject.error(errorObject_1$3.errorObject.e);
                        } else {
                            subject.next(result_1);
                            subject.complete();
                        }
                    } else {
                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    }
                };
                // use named function instance to avoid closure.
                handler.source = this;
                var result = tryCatch_1$3.tryCatch(callbackFunc).apply(this, args.concat(handler));
                if (result === errorObject_1$3.errorObject) {
                    subject.error(errorObject_1$3.errorObject.e);
                }
            }
            return subject.subscribe(subscriber);
        } else {
            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber });
        }
    };
    BoundCallbackObservable.dispatch = function (state) {
        var self = this;
        var source = state.source,
            subscriber = state.subscriber;
        var callbackFunc = source.callbackFunc,
            args = source.args,
            scheduler = source.scheduler;
        var subject = source.subject;
        if (!subject) {
            subject = source.subject = new AsyncSubject_1$1.AsyncSubject();
            var handler = function handlerFn() {
                var innerArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    innerArgs[_i - 0] = arguments[_i];
                }
                var source = handlerFn.source;
                var selector = source.selector,
                    subject = source.subject;
                if (selector) {
                    var result_2 = tryCatch_1$3.tryCatch(selector).apply(this, innerArgs);
                    if (result_2 === errorObject_1$3.errorObject) {
                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1$3.errorObject.e, subject: subject }));
                    } else {
                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
                    }
                } else {
                    var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
                }
            };
            // use named function to pass values in without closure
            handler.source = source;
            var result = tryCatch_1$3.tryCatch(callbackFunc).apply(this, args.concat(handler));
            if (result === errorObject_1$3.errorObject) {
                subject.error(errorObject_1$3.errorObject.e);
            }
        }
        self.add(subject.subscribe(subscriber));
    };
    return BoundCallbackObservable;
}(Observable_1$5.Observable);
var BoundCallbackObservable_2 = BoundCallbackObservable;
function dispatchNext(arg) {
    var value = arg.value,
        subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err,
        subject = arg.subject;
    subject.error(err);
}

var BoundCallbackObservable_1$1 = {
    BoundCallbackObservable: BoundCallbackObservable_2
};

var BoundCallbackObservable_1 = BoundCallbackObservable_1$1;
var bindCallback_1$1 = BoundCallbackObservable_1.BoundCallbackObservable.create;

var bindCallback$2 = {
	bindCallback: bindCallback_1$1
};

var Observable_1$4 = Observable_1$2;
var bindCallback_1 = bindCallback$2;
Observable_1$4.Observable.bindCallback = bindCallback_1.bindCallback;

var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$7 = Observable_1$2;
var tryCatch_1$4 = tryCatch_1$1;
var errorObject_1$4 = errorObject;
var AsyncSubject_1$4 = AsyncSubject_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var BoundNodeCallbackObservable = function (_super) {
    __extends$7(BoundNodeCallbackObservable, _super);
    function BoundNodeCallbackObservable(callbackFunc, selector, args, scheduler) {
        _super.call(this);
        this.callbackFunc = callbackFunc;
        this.selector = selector;
        this.args = args;
        this.scheduler = scheduler;
    }
    /* tslint:enable:max-line-length */
    /**
     * Converts a Node.js-style callback API to a function that returns an
     * Observable.
     *
     * <span class="informal">It's just like {@link bindCallback}, but the
     * callback is expected to be of type `callback(error, result)`.</span>
     *
     * `bindNodeCallback` is not an operator because its input and output are not
     * Observables. The input is a function `func` with some parameters, but the
     * last parameter must be a callback function that `func` calls when it is
     * done. The callback function is expected to follow Node.js conventions,
     * where the first argument to the callback is an error, while remaining
     * arguments are the callback result. The output of `bindNodeCallback` is a
     * function that takes the same parameters as `func`, except the last one (the
     * callback). When the output function is called with arguments, it will
     * return an Observable where the results will be delivered to.
     *
     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
     * import * as fs from 'fs';
     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     * @see {@link fromPromise}
     *
     * @param {function} func Function with a callback as the last parameter.
     * @param {function} [selector] A function which takes the arguments from the
     * callback and maps those a value to emit on the output Observable.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * callbacks.
     * @return {function(...params: *): Observable} A function which returns the
     * Observable that delivers the same values the Node.js callback would
     * deliver.
     * @static true
     * @name bindNodeCallback
     * @owner Observable
     */
    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
        if (selector === void 0) {
            selector = undefined;
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return new BoundNodeCallbackObservable(func, selector, args, scheduler);
        };
    };
    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
        var callbackFunc = this.callbackFunc;
        var args = this.args;
        var scheduler = this.scheduler;
        var subject = this.subject;
        if (!scheduler) {
            if (!subject) {
                subject = this.subject = new AsyncSubject_1$4.AsyncSubject();
                var handler = function handlerFn() {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i - 0] = arguments[_i];
                    }
                    var source = handlerFn.source;
                    var selector = source.selector,
                        subject = source.subject;
                    var err = innerArgs.shift();
                    if (err) {
                        subject.error(err);
                    } else if (selector) {
                        var result_1 = tryCatch_1$4.tryCatch(selector).apply(this, innerArgs);
                        if (result_1 === errorObject_1$4.errorObject) {
                            subject.error(errorObject_1$4.errorObject.e);
                        } else {
                            subject.next(result_1);
                            subject.complete();
                        }
                    } else {
                        subject.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    }
                };
                // use named function instance to avoid closure.
                handler.source = this;
                var result = tryCatch_1$4.tryCatch(callbackFunc).apply(this, args.concat(handler));
                if (result === errorObject_1$4.errorObject) {
                    subject.error(errorObject_1$4.errorObject.e);
                }
            }
            return subject.subscribe(subscriber);
        } else {
            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber });
        }
    };
    return BoundNodeCallbackObservable;
}(Observable_1$7.Observable);
var BoundNodeCallbackObservable_2 = BoundNodeCallbackObservable;
function dispatch(state) {
    var self = this;
    var source = state.source,
        subscriber = state.subscriber;
    // XXX: cast to `any` to access to the private field in `source`.
    var _a = source,
        callbackFunc = _a.callbackFunc,
        args = _a.args,
        scheduler = _a.scheduler;
    var subject = source.subject;
    if (!subject) {
        subject = source.subject = new AsyncSubject_1$4.AsyncSubject();
        var handler = function handlerFn() {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i - 0] = arguments[_i];
            }
            var source = handlerFn.source;
            var selector = source.selector,
                subject = source.subject;
            var err = innerArgs.shift();
            if (err) {
                subject.error(err);
            } else if (selector) {
                var result_2 = tryCatch_1$4.tryCatch(selector).apply(this, innerArgs);
                if (result_2 === errorObject_1$4.errorObject) {
                    self.add(scheduler.schedule(dispatchError$1, 0, { err: errorObject_1$4.errorObject.e, subject: subject }));
                } else {
                    self.add(scheduler.schedule(dispatchNext$1, 0, { value: result_2, subject: subject }));
                }
            } else {
                var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
                self.add(scheduler.schedule(dispatchNext$1, 0, { value: value, subject: subject }));
            }
        };
        // use named function to pass values in without closure
        handler.source = source;
        var result = tryCatch_1$4.tryCatch(callbackFunc).apply(this, args.concat(handler));
        if (result === errorObject_1$4.errorObject) {
            subject.error(errorObject_1$4.errorObject.e);
        }
    }
    self.add(subject.subscribe(subscriber));
}
function dispatchNext$1(arg) {
    var value = arg.value,
        subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError$1(arg) {
    var err = arg.err,
        subject = arg.subject;
    subject.error(err);
}

var BoundNodeCallbackObservable_1$1 = {
    BoundNodeCallbackObservable: BoundNodeCallbackObservable_2
};

var BoundNodeCallbackObservable_1 = BoundNodeCallbackObservable_1$1;
var bindNodeCallback_1$1 = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;

var bindNodeCallback$2 = {
	bindNodeCallback: bindNodeCallback_1$1
};

var Observable_1$6 = Observable_1$2;
var bindNodeCallback_1 = bindNodeCallback$2;
Observable_1$6.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;

function isScheduler(value) {
  return value && typeof value.schedule === 'function';
}
var isScheduler_2 = isScheduler;

var isScheduler_1$1 = {
  isScheduler: isScheduler_2
};

var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$10 = Observable_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends$9(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1$10.Observable);
var ScalarObservable_2 = ScalarObservable;

var ScalarObservable_1$1 = {
    ScalarObservable: ScalarObservable_2
};

var __extends$10 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$11 = Observable_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends$10(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1$11.Observable);
var EmptyObservable_2 = EmptyObservable;

var EmptyObservable_1$1 = {
    EmptyObservable: EmptyObservable_2
};

var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$9 = Observable_1$2;
var ScalarObservable_1 = ScalarObservable_1$1;
var EmptyObservable_1 = EmptyObservable_1$1;
var isScheduler_1$3 = isScheduler_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends$8(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` Scheduler, which means the `next`
     * notifications are sent synchronously, although with a different Scheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1$3.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1$9.Observable);
var ArrayObservable_2 = ArrayObservable;

var ArrayObservable_1$1 = {
    ArrayObservable: ArrayObservable_2
};

var __extends$12 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$5 = Subscriber_1$3;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends$12(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1$5.Subscriber);
var OuterSubscriber_2 = OuterSubscriber;

var OuterSubscriber_1$1 = {
    OuterSubscriber: OuterSubscriber_2
};

function isPromise(value) {
  return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
var isPromise_2 = isPromise;

var isPromise_1$1 = {
  isPromise: isPromise_2
};

var root_1$5 = root;
function symbolIteratorPonyfill(root$$1) {
    var Symbol = root$$1.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root$$1.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root$$1.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
var symbolIteratorPonyfill_1 = symbolIteratorPonyfill;
var $$iterator = symbolIteratorPonyfill(root_1$5.root);

var iterator = {
    symbolIteratorPonyfill: symbolIteratorPonyfill_1,
    $$iterator: $$iterator
};

var __extends$13 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$6 = Subscriber_1$3;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends$13(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1$6.Subscriber);
var InnerSubscriber_2 = InnerSubscriber;

var InnerSubscriber_1$1 = {
    InnerSubscriber: InnerSubscriber_2
};

var root_1$4 = root;
var isArray_1$4 = isArray;
var isPromise_1 = isPromise_1$1;
var isObject_1$3 = isObject_1$1;
var Observable_1$12 = Observable_1$2;
var iterator_1$1 = iterator;
var InnerSubscriber_1 = InnerSubscriber_1$1;
var observable_1$2 = observable;
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1$12.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArray_1$4.isArray(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1$4.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1$1.$$iterator] === 'function') {
        var iterator$$1 = result[iterator_1$1.$$iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1$2.$$observable] === 'function') {
        var obs = result[observable_1$2.$$observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1$3.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
var subscribeToResult_2 = subscribeToResult;

var subscribeToResult_1$1 = {
    subscribeToResult: subscribeToResult_2
};

var __extends$11 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1$3 = ArrayObservable_1$1;
var isArray_1$3 = isArray;
var OuterSubscriber_1 = OuterSubscriber_1$1;
var subscribeToResult_1 = subscribeToResult_1$1;
var none = {};
/* tslint:disable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
function combineLatest$3() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1$3.isArray(observables[0])) {
        observables = observables[0];
    }
    observables.unshift(this);
    return this.lift.call(new ArrayObservable_1$3.ArrayObservable(observables), new CombineLatestOperator(project));
}
var combineLatest_2$2 = combineLatest$3;
var CombineLatestOperator = function () {
    function CombineLatestOperator(project) {
        this.project = project;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
    };
    return CombineLatestOperator;
}();
var CombineLatestOperator_1 = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = function (_super) {
    __extends$11(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, project) {
        _super.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(none);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        } else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === none ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.project) {
                this._tryProject(values);
            } else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryProject = function (values) {
        var result;
        try {
            result = this.project.apply(this, values);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
var CombineLatestSubscriber_1 = CombineLatestSubscriber;

var combineLatest_1$2 = {
    combineLatest: combineLatest_2$2,
    CombineLatestOperator: CombineLatestOperator_1,
    CombineLatestSubscriber: CombineLatestSubscriber_1
};

var isScheduler_1 = isScheduler_1$1;
var isArray_1$2 = isArray;
var ArrayObservable_1 = ArrayObservable_1$1;
var combineLatest_1$1 = combineLatest_1$2;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable, in order, and
 * collecting an array of each of the most recent values any time any of the
 * input Observables emits, then either taking that array and passing it as
 * arguments to an optional `project` function and emitting the return value of
 * that, or just emitting the array of recent values directly if there is no
 * `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} observable1 An input Observable to combine with the
 * source Observable.
 * @param {Observable} observable2 An input Observable to combine with the
 * source Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @static true
 * @name combineLatest
 * @owner Observable
 */
function combineLatest$2() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 && isArray_1$2.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1$1.CombineLatestOperator(project));
}
var combineLatest_3 = combineLatest$2;

var combineLatest_2 = {
    combineLatest: combineLatest_3
};

var Observable_1$8 = Observable_1$2;
var combineLatest_1 = combineLatest_2;
Observable_1$8.Observable.combineLatest = combineLatest_1.combineLatest;

var __extends$14 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$3 = OuterSubscriber_1$1;
var subscribeToResult_1$3 = subscribeToResult_1$1;
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
var mergeAll_2 = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
var MergeAllOperator_1 = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends$14(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1$3.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1$3.OuterSubscriber);
var MergeAllSubscriber_1 = MergeAllSubscriber;

var mergeAll_1$1 = {
    mergeAll: mergeAll_2,
    MergeAllOperator: MergeAllOperator_1,
    MergeAllSubscriber: MergeAllSubscriber_1
};

var isScheduler_1$4 = isScheduler_1$1;
var ArrayObservable_1$4 = ArrayObservable_1$1;
var mergeAll_1 = mergeAll_1$1;
/* tslint:disable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {Observable} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat$4() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
var concat_2$1 = concat$4;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins multiple Observables together by subscribing to them one at a time and
 * merging their results into the output Observable. Will wait for each
 * Observable to complete before moving on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat(timer1, timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {Observable} input1 An input Observable to concatenate with others.
 * @param {Observable} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1$4.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1) {
        return observables[0];
    }
    return new ArrayObservable_1$4.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
var concatStatic_1 = concatStatic;

var concat_1$2 = {
    concat: concat_2$1,
    concatStatic: concatStatic_1
};

var concat_1$1 = concat_1$2;
var concat_2 = concat_1$1.concatStatic;

var concat$2 = {
	concat: concat_2
};

var Observable_1$13 = Observable_1$2;
var concat_1 = concat$2;
Observable_1$13.Observable.concat = concat_1.concat;

var __extends$15 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$15 = Observable_1$2;
var subscribeToResult_1$4 = subscribeToResult_1$1;
var OuterSubscriber_1$4 = OuterSubscriber_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = function (_super) {
    __extends$15(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): Observable|Promise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1$15.Observable);
var DeferObservable_2 = DeferObservable;
var DeferSubscriber = function (_super) {
    __extends$15(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        } catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1$4.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1$4.OuterSubscriber);

var DeferObservable_1$1 = {
    DeferObservable: DeferObservable_2
};

var DeferObservable_1 = DeferObservable_1$1;
var defer_1$1 = DeferObservable_1.DeferObservable.create;

var defer$2 = {
	defer: defer_1$1
};

var Observable_1$14 = Observable_1$2;
var defer_1 = defer$2;
Observable_1$14.Observable.defer = defer_1.defer;

var EmptyObservable_1$3 = EmptyObservable_1$1;
var empty_1$1 = EmptyObservable_1$3.EmptyObservable.create;

var empty$3 = {
	empty: empty_1$1
};

var Observable_1$16 = Observable_1$2;
var empty_1 = empty$3;
Observable_1$16.Observable.empty = empty_1.empty;

var __extends$16 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$18 = Observable_1$2;
var EmptyObservable_1$4 = EmptyObservable_1$1;
var isArray_1$5 = isArray;
var subscribeToResult_1$5 = subscribeToResult_1$1;
var OuterSubscriber_1$5 = OuterSubscriber_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ForkJoinObservable = function (_super) {
    __extends$16(ForkJoinObservable, _super);
    function ForkJoinObservable(sources, resultSelector) {
        _super.call(this);
        this.sources = sources;
        this.resultSelector = resultSelector;
    }
    /* tslint:enable:max-line-length */
    /**
     * @param sources
     * @return {any}
     * @static true
     * @name forkJoin
     * @owner Observable
     */
    ForkJoinObservable.create = function () {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i - 0] = arguments[_i];
        }
        if (sources === null || arguments.length === 0) {
            return new EmptyObservable_1$4.EmptyObservable();
        }
        var resultSelector = null;
        if (typeof sources[sources.length - 1] === 'function') {
            resultSelector = sources.pop();
        }
        // if the first and only other argument besides the resultSelector is an array
        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
        if (sources.length === 1 && isArray_1$5.isArray(sources[0])) {
            sources = sources[0];
        }
        if (sources.length === 0) {
            return new EmptyObservable_1$4.EmptyObservable();
        }
        return new ForkJoinObservable(sources, resultSelector);
    };
    ForkJoinObservable.prototype._subscribe = function (subscriber) {
        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);
    };
    return ForkJoinObservable;
}(Observable_1$18.Observable);
var ForkJoinObservable_2 = ForkJoinObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ForkJoinSubscriber = function (_super) {
    __extends$16(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources, resultSelector) {
        _super.call(this, destination);
        this.sources = sources;
        this.resultSelector = resultSelector;
        this.completed = 0;
        this.haveValues = 0;
        var len = sources.length;
        this.total = len;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult_1$5.subscribeToResult(this, source, null, i);
            if (innerSubscription) {
                innerSubscription.outerIndex = i;
                this.add(innerSubscription);
            }
        }
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        var _a = this,
            haveValues = _a.haveValues,
            resultSelector = _a.resultSelector,
            values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            var value = resultSelector ? resultSelector.apply(this, values) : values;
            destination.next(value);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber_1$5.OuterSubscriber);

var ForkJoinObservable_1$1 = {
    ForkJoinObservable: ForkJoinObservable_2
};

var ForkJoinObservable_1 = ForkJoinObservable_1$1;
var forkJoin_1$1 = ForkJoinObservable_1.ForkJoinObservable.create;

var forkJoin$2 = {
	forkJoin: forkJoin_1$1
};

var Observable_1$17 = Observable_1$2;
var forkJoin_1 = forkJoin$2;
Observable_1$17.Observable.forkJoin = forkJoin_1.forkJoin;

var __extends$18 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1$6 = root;
var Observable_1$21 = Observable_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = function (_super) {
    __extends$18(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {Promise<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.error(err);
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1$6.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        } else {
            if (this._isScalar) {
                if (!subscriber.closed) {
                    return scheduler.schedule(dispatchNext$2, 0, { value: this.value, subscriber: subscriber });
                }
            } else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchNext$2, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.closed) {
                        subscriber.add(scheduler.schedule(dispatchError$2, 0, { err: err, subscriber: subscriber }));
                    }
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1$6.root.setTimeout(function () {
                        throw err;
                    });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1$21.Observable);
var PromiseObservable_2 = PromiseObservable;
function dispatchNext$2(arg) {
    var value = arg.value,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError$2(arg) {
    var err = arg.err,
        subscriber = arg.subscriber;
    if (!subscriber.closed) {
        subscriber.error(err);
    }
}

var PromiseObservable_1$1 = {
    PromiseObservable: PromiseObservable_2
};

var __extends$19 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1$7 = root;
var Observable_1$22 = Observable_1$2;
var iterator_1$3 = iterator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IteratorObservable = function (_super) {
    __extends$19(IteratorObservable, _super);
    function IteratorObservable(iterator$$1, scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
        if (iterator$$1 == null) {
            throw new Error('iterator cannot be null.');
        }
        this.iterator = getIterator(iterator$$1);
    }
    IteratorObservable.create = function (iterator$$1, scheduler) {
        return new IteratorObservable(iterator$$1, scheduler);
    };
    IteratorObservable.dispatch = function (state) {
        var index = state.index,
            hasError = state.hasError,
            iterator$$1 = state.iterator,
            subscriber = state.subscriber;
        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator$$1.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        subscriber.next(result.value);
        state.index = index + 1;
        if (subscriber.closed) {
            if (typeof iterator$$1.return === 'function') {
                iterator$$1.return();
            }
            return;
        }
        this.schedule(state);
    };
    IteratorObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            iterator$$1 = _a.iterator,
            scheduler = _a.scheduler;
        if (scheduler) {
            return scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, iterator: iterator$$1, subscriber: subscriber
            });
        } else {
            do {
                var result = iterator$$1.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                } else {
                    subscriber.next(result.value);
                }
                if (subscriber.closed) {
                    if (typeof iterator$$1.return === 'function') {
                        iterator$$1.return();
                    }
                    break;
                }
            } while (true);
        }
    };
    return IteratorObservable;
}(Observable_1$22.Observable);
var IteratorObservable_2 = IteratorObservable;
var StringIterator = function () {
    function StringIterator(str, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = str.length;
        }
        this.str = str;
        this.idx = idx;
        this.len = len;
    }
    StringIterator.prototype[iterator_1$3.$$iterator] = function () {
        return this;
    };
    StringIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };
    return StringIterator;
}();
var ArrayIterator = function () {
    function ArrayIterator(arr, idx, len) {
        if (idx === void 0) {
            idx = 0;
        }
        if (len === void 0) {
            len = toLength(arr);
        }
        this.arr = arr;
        this.idx = idx;
        this.len = len;
    }
    ArrayIterator.prototype[iterator_1$3.$$iterator] = function () {
        return this;
    };
    ArrayIterator.prototype.next = function () {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };
    return ArrayIterator;
}();
function getIterator(obj) {
    var i = obj[iterator_1$3.$$iterator];
    if (!i && typeof obj === 'string') {
        return new StringIterator(obj);
    }
    if (!i && obj.length !== undefined) {
        return new ArrayIterator(obj);
    }
    if (!i) {
        throw new TypeError('object is not iterable');
    }
    return obj[iterator_1$3.$$iterator]();
}
var maxSafeInteger = Math.pow(2, 53) - 1;
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && root_1$7.root.isFinite(value);
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}

var IteratorObservable_1$1 = {
    IteratorObservable: IteratorObservable_2
};

var __extends$20 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$23 = Observable_1$2;
var ScalarObservable_1$3 = ScalarObservable_1$1;
var EmptyObservable_1$5 = EmptyObservable_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayLikeObservable = function (_super) {
    __extends$20(ArrayLikeObservable, _super);
    function ArrayLikeObservable(arrayLike, scheduler) {
        _super.call(this);
        this.arrayLike = arrayLike;
        this.scheduler = scheduler;
        if (!scheduler && arrayLike.length === 1) {
            this._isScalar = true;
            this.value = arrayLike[0];
        }
    }
    ArrayLikeObservable.create = function (arrayLike, scheduler) {
        var length = arrayLike.length;
        if (length === 0) {
            return new EmptyObservable_1$5.EmptyObservable();
        } else if (length === 1) {
            return new ScalarObservable_1$3.ScalarObservable(arrayLike[0], scheduler);
        } else {
            return new ArrayLikeObservable(arrayLike, scheduler);
        }
    };
    ArrayLikeObservable.dispatch = function (state) {
        var arrayLike = state.arrayLike,
            index = state.index,
            length = state.length,
            subscriber = state.subscriber;
        if (subscriber.closed) {
            return;
        }
        if (index >= length) {
            subscriber.complete();
            return;
        }
        subscriber.next(arrayLike[index]);
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            arrayLike = _a.arrayLike,
            scheduler = _a.scheduler;
        var length = arrayLike.length;
        if (scheduler) {
            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < length && !subscriber.closed; i++) {
                subscriber.next(arrayLike[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayLikeObservable;
}(Observable_1$23.Observable);
var ArrayLikeObservable_2 = ArrayLikeObservable;

var ArrayLikeObservable_1$1 = {
    ArrayLikeObservable: ArrayLikeObservable_2
};

var Observable_1$24 = Observable_1$2;
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification$1 = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1$24.Observable.of(this.value);
            case 'E':
                return Observable_1$24.Observable.throw(this.error);
            case 'C':
                return Observable_1$24.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return this.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
var Notification_2 = Notification$1;

var Notification_1$2 = {
    Notification: Notification_2
};

var __extends$21 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$7 = Subscriber_1$3;
var Notification_1$1 = Notification_1$2;
/**
 * @see {@link Notification}
 *
 * @param scheduler
 * @param delay
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}
var observeOn_2 = observeOn;
var ObserveOnOperator = function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}();
var ObserveOnOperator_1 = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = function (_super) {
    __extends$21(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification,
            destination = arg.destination;
        notification.observe(destination);
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1$1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1$1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1$1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1$7.Subscriber);
var ObserveOnSubscriber_1 = ObserveOnSubscriber;
var ObserveOnMessage = function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}();
var ObserveOnMessage_1 = ObserveOnMessage;

var observeOn_1$1 = {
    observeOn: observeOn_2,
    ObserveOnOperator: ObserveOnOperator_1,
    ObserveOnSubscriber: ObserveOnSubscriber_1,
    ObserveOnMessage: ObserveOnMessage_1
};

var __extends$17 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1$6 = isArray;
var isPromise_1$3 = isPromise_1$1;
var PromiseObservable_1 = PromiseObservable_1$1;
var IteratorObservable_1 = IteratorObservable_1$1;
var ArrayObservable_1$5 = ArrayObservable_1$1;
var ArrayLikeObservable_1 = ArrayLikeObservable_1$1;
var iterator_1$2 = iterator;
var Observable_1$20 = Observable_1$2;
var observeOn_1 = observeOn_1$1;
var observable_1$3 = observable;
var isArrayLike = function (x) {
    return x && typeof x.length === 'number';
};
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromObservable = function (_super) {
    __extends$17(FromObservable, _super);
    function FromObservable(ish, scheduler) {
        _super.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable from an Array, an array-like object, a Promise, an
     * iterable object, or an Observable-like object.
     *
     * <span class="informal">Converts almost anything to an Observable.</span>
     *
     * <img src="./img/from.png" width="100%">
     *
     * Convert various other objects and data types into Observables. `from`
     * converts a Promise or an array-like or an
     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
     * object into an Observable that emits the items in that promise or array or
     * iterable. A String, in this context, is treated as an array of characters.
     * Observable-like objects (contains a function named with the ES2015 Symbol
     * for Observable) can also be converted through this operator.
     *
     * @example <caption>Converts an array to an Observable</caption>
     * var array = [10, 20, 30];
     * var result = Rx.Observable.from(array);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 10 20 30
     *
     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
     * function* generateDoubles(seed) {
     *   var i = seed;
     *   while (true) {
     *     yield i;
     *     i = 2 * i; // double it
     *   }
     * }
     *
     * var iterator = generateDoubles(3);
     * var result = Rx.Observable.from(iterator).take(10);
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // 3 6 12 24 48 96 192 384 768 1536
     *
     * @see {@link create}
     * @see {@link fromEvent}
     * @see {@link fromEventPattern}
     * @see {@link fromPromise}
     *
     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
     * Observable-like, an Array, an iterable or an array-like object to be
     * converted.
     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
     * emissions of values.
     * @return {Observable<T>} The Observable whose values are originally from the
     * input object that was converted.
     * @static true
     * @name from
     * @owner Observable
     */
    FromObservable.create = function (ish, scheduler) {
        if (ish != null) {
            if (typeof ish[observable_1$3.$$observable] === 'function') {
                if (ish instanceof Observable_1$20.Observable && !scheduler) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            } else if (isArray_1$6.isArray(ish)) {
                return new ArrayObservable_1$5.ArrayObservable(ish, scheduler);
            } else if (isPromise_1$3.isPromise(ish)) {
                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
            } else if (typeof ish[iterator_1$2.$$iterator] === 'function' || typeof ish === 'string') {
                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
            } else if (isArrayLike(ish)) {
                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
            }
        }
        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
    };
    FromObservable.prototype._subscribe = function (subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            return ish[observable_1$3.$$observable]().subscribe(subscriber);
        } else {
            return ish[observable_1$3.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };
    return FromObservable;
}(Observable_1$20.Observable);
var FromObservable_2 = FromObservable;

var FromObservable_1$1 = {
    FromObservable: FromObservable_2
};

var FromObservable_1 = FromObservable_1$1;
var from_1$1 = FromObservable_1.FromObservable.create;

var from$2 = {
	from: from_1$1
};

var Observable_1$19 = Observable_1$2;
var from_1 = from$2;
Observable_1$19.Observable.from = from_1.from;

var __extends$22 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$26 = Observable_1$2;
var tryCatch_1$5 = tryCatch_1$1;
var isFunction_1$4 = isFunction_1$1;
var errorObject_1$5 = errorObject;
var Subscription_1$7 = Subscription_1$3;
var toString = Object.prototype.toString;
function isNodeStyleEventEmmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends$22(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1$4.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1$7.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1$5.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1$5.errorObject) {
                subscriber.error(errorObject_1$5.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1$26.Observable);
var FromEventObservable_2 = FromEventObservable;

var FromEventObservable_1$1 = {
    FromEventObservable: FromEventObservable_2
};

var FromEventObservable_1 = FromEventObservable_1$1;
var fromEvent_1$1 = FromEventObservable_1.FromEventObservable.create;

var fromEvent$2 = {
	fromEvent: fromEvent_1$1
};

var Observable_1$25 = Observable_1$2;
var fromEvent_1 = fromEvent$2;
Observable_1$25.Observable.fromEvent = fromEvent_1.fromEvent;

var __extends$23 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$28 = Observable_1$2;
var Subscription_1$8 = Subscription_1$3;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventPatternObservable = function (_super) {
    __extends$23(FromEventPatternObservable, _super);
    function FromEventPatternObservable(addHandler, removeHandler, selector) {
        _super.call(this);
        this.addHandler = addHandler;
        this.removeHandler = removeHandler;
        this.selector = selector;
    }
    /**
     * Creates an Observable from an API based on addHandler/removeHandler
     * functions.
     *
     * <span class="informal">Converts any addHandler/removeHandler API to an
     * Observable.</span>
     *
     * <img src="./img/fromEventPattern.png" width="100%">
     *
     * Creates an Observable by using the `addHandler` and `removeHandler`
     * functions to add and remove the handlers, with an optional selector
     * function to project the event arguments to a result. The `addHandler` is
     * called when the output Observable is subscribed, and `removeHandler` is
     * called when the Subscription is unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * function addClickHandler(handler) {
     *   document.addEventListener('click', handler);
     * }
     *
     * function removeClickHandler(handler) {
     *   document.removeEventListener('click', handler);
     * }
     *
     * var clicks = Rx.Observable.fromEventPattern(
     *   addClickHandler,
     *   removeClickHandler
     * );
     * clicks.subscribe(x => console.log(x));
     *
     * @see {@link from}
     * @see {@link fromEvent}
     *
     * @param {function(handler: Function): any} addHandler A function that takes
     * a `handler` function as argument and attaches it somehow to the actual
     * source of events.
     * @param {function(handler: Function): void} removeHandler A function that
     * takes a `handler` function as argument and removes it in case it was
     * previously attached using `addHandler`.
     * @param {function(...args: any): T} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEventPattern
     * @owner Observable
     */
    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
        return new FromEventPatternObservable(addHandler, removeHandler, selector);
    };
    FromEventPatternObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var removeHandler = this.removeHandler;
        var handler = !!this.selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            _this._callSelector(subscriber, args);
        } : function (e) {
            subscriber.next(e);
        };
        this._callAddHandler(handler, subscriber);
        subscriber.add(new Subscription_1$8.Subscription(function () {
            //TODO: determine whether or not to forward to error handler
            removeHandler(handler);
        }));
    };
    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {
        try {
            var result = this.selector.apply(this, args);
            subscriber.next(result);
        } catch (e) {
            subscriber.error(e);
        }
    };
    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {
        try {
            this.addHandler(handler);
        } catch (e) {
            errorSubscriber.error(e);
        }
    };
    return FromEventPatternObservable;
}(Observable_1$28.Observable);
var FromEventPatternObservable_2 = FromEventPatternObservable;

var FromEventPatternObservable_1$1 = {
    FromEventPatternObservable: FromEventPatternObservable_2
};

var FromEventPatternObservable_1 = FromEventPatternObservable_1$1;
var fromEventPattern_1$1 = FromEventPatternObservable_1.FromEventPatternObservable.create;

var fromEventPattern$2 = {
	fromEventPattern: fromEventPattern_1$1
};

var Observable_1$27 = Observable_1$2;
var fromEventPattern_1 = fromEventPattern$2;
Observable_1$27.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;

var PromiseObservable_1$3 = PromiseObservable_1$1;
var fromPromise_1$1 = PromiseObservable_1$3.PromiseObservable.create;

var fromPromise$2 = {
	fromPromise: fromPromise_1$1
};

var Observable_1$29 = Observable_1$2;
var fromPromise_1 = fromPromise$2;
Observable_1$29.Observable.fromPromise = fromPromise_1.fromPromise;

var __extends$24 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$31 = Observable_1$2;
var isScheduler_1$5 = isScheduler_1$1;
var selfSelector = function (value) {
    return value;
};
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var GenerateObservable = function (_super) {
    __extends$24(GenerateObservable, _super);
    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
        _super.call(this);
        this.initialState = initialState;
        this.condition = condition;
        this.iterate = iterate;
        this.resultSelector = resultSelector;
        this.scheduler = scheduler;
    }
    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
        if (arguments.length == 1) {
            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
        }
        if (resultSelectorOrObservable === undefined || isScheduler_1$5.isScheduler(resultSelectorOrObservable)) {
            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
        }
        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
    };
    GenerateObservable.prototype._subscribe = function (subscriber) {
        var state = this.initialState;
        if (this.scheduler) {
            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
                subscriber: subscriber,
                iterate: this.iterate,
                condition: this.condition,
                resultSelector: this.resultSelector,
                state: state });
        }
        var _a = this,
            condition = _a.condition,
            resultSelector = _a.resultSelector,
            iterate = _a.iterate;
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                } catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            } catch (err) {
                subscriber.error(err);
                return;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            } catch (err) {
                subscriber.error(err);
                return;
            }
        } while (true);
    };
    GenerateObservable.dispatch = function (state) {
        var subscriber = state.subscriber,
            condition = state.condition;
        if (subscriber.closed) {
            return;
        }
        if (state.needIterate) {
            try {
                state.state = state.iterate(state.state);
            } catch (err) {
                subscriber.error(err);
                return;
            }
        } else {
            state.needIterate = true;
        }
        if (condition) {
            var conditionResult = void 0;
            try {
                conditionResult = condition(state.state);
            } catch (err) {
                subscriber.error(err);
                return;
            }
            if (!conditionResult) {
                subscriber.complete();
                return;
            }
            if (subscriber.closed) {
                return;
            }
        }
        var value;
        try {
            value = state.resultSelector(state.state);
        } catch (err) {
            subscriber.error(err);
            return;
        }
        if (subscriber.closed) {
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        return this.schedule(state);
    };
    return GenerateObservable;
}(Observable_1$31.Observable);
var GenerateObservable_2 = GenerateObservable;

var GenerateObservable_1$1 = {
    GenerateObservable: GenerateObservable_2
};

var Observable_1$30 = Observable_1$2;
var GenerateObservable_1 = GenerateObservable_1$1;
Observable_1$30.Observable.generate = GenerateObservable_1.GenerateObservable.create;

var __extends$25 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$33 = Observable_1$2;
var subscribeToResult_1$6 = subscribeToResult_1$1;
var OuterSubscriber_1$6 = OuterSubscriber_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IfObservable = function (_super) {
    __extends$25(IfObservable, _super);
    function IfObservable(condition, thenSource, elseSource) {
        _super.call(this);
        this.condition = condition;
        this.thenSource = thenSource;
        this.elseSource = elseSource;
    }
    IfObservable.create = function (condition, thenSource, elseSource) {
        return new IfObservable(condition, thenSource, elseSource);
    };
    IfObservable.prototype._subscribe = function (subscriber) {
        var _a = this,
            condition = _a.condition,
            thenSource = _a.thenSource,
            elseSource = _a.elseSource;
        return new IfSubscriber(subscriber, condition, thenSource, elseSource);
    };
    return IfObservable;
}(Observable_1$33.Observable);
var IfObservable_2 = IfObservable;
var IfSubscriber = function (_super) {
    __extends$25(IfSubscriber, _super);
    function IfSubscriber(destination, condition, thenSource, elseSource) {
        _super.call(this, destination);
        this.condition = condition;
        this.thenSource = thenSource;
        this.elseSource = elseSource;
        this.tryIf();
    }
    IfSubscriber.prototype.tryIf = function () {
        var _a = this,
            condition = _a.condition,
            thenSource = _a.thenSource,
            elseSource = _a.elseSource;
        var result;
        try {
            result = condition();
            var source = result ? thenSource : elseSource;
            if (source) {
                this.add(subscribeToResult_1$6.subscribeToResult(this, source));
            } else {
                this._complete();
            }
        } catch (err) {
            this._error(err);
        }
    };
    return IfSubscriber;
}(OuterSubscriber_1$6.OuterSubscriber);

var IfObservable_1$1 = {
    IfObservable: IfObservable_2
};

var IfObservable_1 = IfObservable_1$1;
var _if_1 = IfObservable_1.IfObservable.create;

var _if$2 = {
	_if: _if_1
};

var Observable_1$32 = Observable_1$2;
var if_1 = _if$2;
Observable_1$32.Observable.if = if_1._if;

var isArray_1$7 = isArray;
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1$7.isArray(val) && val - parseFloat(val) + 1 >= 0;
}
var isNumeric_2 = isNumeric;


var isNumeric_1$1 = {
    isNumeric: isNumeric_2
};

var __extends$28 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1$9 = Subscription_1$3;
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends$28(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1$9.Subscription);
var Action_2 = Action;

var Action_1$1 = {
    Action: Action_2
};

var __extends$27 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1$8 = root;
var Action_1 = Action_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends$27(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1$8.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1$8.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
var AsyncAction_2 = AsyncAction;

var AsyncAction_1$1 = {
    AsyncAction: AsyncAction_2
};

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */

var Scheduler$1 = function () {
  function Scheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }
  /**
   * Schedules a function, `work`, for execution. May happen at some point in
   * the future, according to the `delay` parameter, if specified. May be passed
   * some context object, `state`, which will be passed to the `work` function.
   *
   * The given arguments will be processed an stored as an Action object in a
   * queue of actions.
   *
   * @param {function(state: ?T): ?Subscription} work A function representing a
   * task, or some unit of work to be executed by the Scheduler.
   * @param {number} [delay] Time to wait before executing the work, where the
   * time unit is implicit and defined by the Scheduler itself.
   * @param {T} [state] Some contextual data that the `work` function uses when
   * called by the Scheduler.
   * @return {Subscription} A subscription in order to be able to unsubscribe
   * the scheduled work.
   */
  Scheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state, delay);
  };
  Scheduler.now = Date.now ? Date.now : function () {
    return +new Date();
  };
  return Scheduler;
}();
var Scheduler_2 = Scheduler$1;

var Scheduler_1$2 = {
  Scheduler: Scheduler_2
};

var __extends$29 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1$1 = Scheduler_1$2;
var AsyncScheduler = function (_super) {
    __extends$29(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1$1.Scheduler);
var AsyncScheduler_2 = AsyncScheduler;

var AsyncScheduler_1$1 = {
    AsyncScheduler: AsyncScheduler_2
};

var AsyncAction_1 = AsyncAction_1$1;
var AsyncScheduler_1 = AsyncScheduler_1$1;
var async_1$2 = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

var async = {
	async: async_1$2
};

var __extends$26 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = isNumeric_1$1;
var Observable_1$35 = Observable_1$2;
var async_1$1 = async;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var IntervalObservable = function (_super) {
    __extends$26(IntervalObservable, _super);
    function IntervalObservable(period, scheduler) {
        if (period === void 0) {
            period = 0;
        }
        if (scheduler === void 0) {
            scheduler = async_1$1.async;
        }
        _super.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(period) || period < 0) {
            this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = async_1$1.async;
        }
    }
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified Scheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` Scheduler to provide a notion of time, but you may pass any
     * Scheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    IntervalObservable.create = function (period, scheduler) {
        if (period === void 0) {
            period = 0;
        }
        if (scheduler === void 0) {
            scheduler = async_1$1.async;
        }
        return new IntervalObservable(period, scheduler);
    };
    IntervalObservable.dispatch = function (state) {
        var index = state.index,
            subscriber = state.subscriber,
            period = state.period;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        }
        state.index += 1;
        this.schedule(state, period);
    };
    IntervalObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
            index: index, subscriber: subscriber, period: period
        }));
    };
    return IntervalObservable;
}(Observable_1$35.Observable);
var IntervalObservable_2 = IntervalObservable;

var IntervalObservable_1$1 = {
    IntervalObservable: IntervalObservable_2
};

var IntervalObservable_1 = IntervalObservable_1$1;
var interval_1$1 = IntervalObservable_1.IntervalObservable.create;

var interval$2 = {
	interval: interval_1$1
};

var Observable_1$34 = Observable_1$2;
var interval_1 = interval$2;
Observable_1$34.Observable.interval = interval_1.interval;

var ArrayObservable_1$6 = ArrayObservable_1$1;
var mergeAll_1$3 = mergeAll_1$1;
var isScheduler_1$6 = isScheduler_1$1;
/* tslint:disable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {Observable} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge$4() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
var merge_2$1 = merge$4;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...Observable} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1$6.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1) {
        return observables[0];
    }
    return new ArrayObservable_1$6.ArrayObservable(observables, scheduler).lift(new mergeAll_1$3.MergeAllOperator(concurrent));
}
var mergeStatic_1 = mergeStatic;

var merge_1$2 = {
    merge: merge_2$1,
    mergeStatic: mergeStatic_1
};

var merge_1$1 = merge_1$2;
var merge_2 = merge_1$1.mergeStatic;

var merge$2 = {
	merge: merge_2
};

var Observable_1$36 = Observable_1$2;
var merge_1 = merge$2;
Observable_1$36.Observable.merge = merge_1.merge;

var __extends$30 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1$8 = isArray;
var ArrayObservable_1$7 = ArrayObservable_1$1;
var OuterSubscriber_1$7 = OuterSubscriber_1$1;
var subscribeToResult_1$7 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables
 * @param {...Observables} ...observables sources used to race for which Observable emits first.
 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 */
function race$2() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1 && isArray_1$8.isArray(observables[0])) {
        observables = observables[0];
    }
    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
}
var race_2 = race$2;
function raceStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1$8.isArray(observables[0])) {
            observables = observables[0];
        } else {
            return observables[0];
        }
    }
    return new ArrayObservable_1$7.ArrayObservable(observables).lift(new RaceOperator());
}
var raceStatic_1 = raceStatic;
var RaceOperator = function () {
    function RaceOperator() {}
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}();
var RaceOperator_1 = RaceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = function (_super) {
    __extends$30(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        _super.call(this, destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        } else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1$7.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1$7.OuterSubscriber);
var RaceSubscriber_1 = RaceSubscriber;

var race_1$1 = {
    race: race_2,
    raceStatic: raceStatic_1,
    RaceOperator: RaceOperator_1,
    RaceSubscriber: RaceSubscriber_1
};

var Observable_1$37 = Observable_1$2;
var race_1 = race_1$1;
Observable_1$37.Observable.race = race_1.raceStatic;

/* tslint:disable:no-empty */

function noop() {}
var noop_2 = noop;

var noop_1$1 = {
	noop: noop_2
};

var __extends$31 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$39 = Observable_1$2;
var noop_1 = noop_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var NeverObservable = function (_super) {
    __extends$31(NeverObservable, _super);
    function NeverObservable() {
        _super.call(this);
    }
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please not
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    NeverObservable.create = function () {
        return new NeverObservable();
    };
    NeverObservable.prototype._subscribe = function (subscriber) {
        noop_1.noop();
    };
    return NeverObservable;
}(Observable_1$39.Observable);
var NeverObservable_2 = NeverObservable;

var NeverObservable_1$1 = {
    NeverObservable: NeverObservable_2
};

var NeverObservable_1 = NeverObservable_1$1;
var never_1$1 = NeverObservable_1.NeverObservable.create;

var never$2 = {
	never: never_1$1
};

var Observable_1$38 = Observable_1$2;
var never_1 = never$2;
Observable_1$38.Observable.never = never_1.never;

var ArrayObservable_1$8 = ArrayObservable_1$1;
var of_1$1 = ArrayObservable_1$8.ArrayObservable.of;

var of$2 = {
	of: of_1$1
};

var Observable_1$40 = Observable_1$2;
var of_1 = of$2;
Observable_1$40.Observable.of = of_1.of;

var __extends$32 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FromObservable_1$3 = FromObservable_1$1;
var isArray_1$9 = isArray;
var OuterSubscriber_1$8 = OuterSubscriber_1$1;
var subscribeToResult_1$8 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
function onErrorResumeNext$2() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1$9.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return this.lift(new OnErrorResumeNextOperator(nextSources));
}
var onErrorResumeNext_2 = onErrorResumeNext$2;
/* tslint:enable:max-line-length */
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && isArray_1$9.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1$3.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
var onErrorResumeNextStatic_1 = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}();
var OnErrorResumeNextSubscriber = function (_super) {
    __extends$32(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        _super.call(this, destination);
        this.destination = destination;
        this.nextSources = nextSources;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult_1$8.subscribeToResult(this, next));
        } else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1$8.OuterSubscriber);

var onErrorResumeNext_1$1 = {
    onErrorResumeNext: onErrorResumeNext_2,
    onErrorResumeNextStatic: onErrorResumeNextStatic_1
};

var Observable_1$41 = Observable_1$2;
var onErrorResumeNext_1 = onErrorResumeNext_1$1;
Observable_1$41.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;

var __extends$33 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$43 = Observable_1$2;
function dispatch$1(state) {
    var obj = state.obj,
        keys = state.keys,
        length = state.length,
        index = state.index,
        subscriber = state.subscriber;
    if (index === length) {
        subscriber.complete();
        return;
    }
    var key = keys[index];
    subscriber.next([key, obj[key]]);
    state.index = index + 1;
    this.schedule(state);
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PairsObservable = function (_super) {
    __extends$33(PairsObservable, _super);
    function PairsObservable(obj, scheduler) {
        _super.call(this);
        this.obj = obj;
        this.scheduler = scheduler;
        this.keys = Object.keys(obj);
    }
    /**
     * Convert an object into an observable sequence of [key, value] pairs
     * using an optional Scheduler to enumerate the object.
     *
     * @example <caption>Converts a javascript object to an Observable</caption>
     * var obj = {
     *   foo: 42,
     *   bar: 56,
     *   baz: 78
     * };
     *
     * var source = Rx.Observable.pairs(obj);
     *
     * var subscription = source.subscribe(
     *   function (x) {
     *     console.log('Next: %s', x);
     *   },
     *   function (err) {
     *     console.log('Error: %s', err);
     *   },
     *   function () {
     *     console.log('Completed');
     *   });
     *
     * @param {Object} obj The object to inspect and turn into an
     * Observable sequence.
     * @param {Scheduler} [scheduler] An optional Scheduler to run the
     * enumeration of the input sequence on.
     * @returns {(Observable<Array<string | T>>)} An observable sequence of
     * [key, value] pairs from the object.
     */
    PairsObservable.create = function (obj, scheduler) {
        return new PairsObservable(obj, scheduler);
    };
    PairsObservable.prototype._subscribe = function (subscriber) {
        var _a = this,
            keys = _a.keys,
            scheduler = _a.scheduler;
        var length = keys.length;
        if (scheduler) {
            return scheduler.schedule(dispatch$1, 0, {
                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber
            });
        } else {
            for (var idx = 0; idx < length; idx++) {
                var key = keys[idx];
                subscriber.next([key, this.obj[key]]);
            }
            subscriber.complete();
        }
    };
    return PairsObservable;
}(Observable_1$43.Observable);
var PairsObservable_2 = PairsObservable;

var PairsObservable_1$1 = {
    PairsObservable: PairsObservable_2
};

var PairsObservable_1 = PairsObservable_1$1;
var pairs_1$1 = PairsObservable_1.PairsObservable.create;

var pairs$2 = {
	pairs: pairs_1$1
};

var Observable_1$42 = Observable_1$2;
var pairs_1 = pairs$2;
Observable_1$42.Observable.pairs = pairs_1.pairs;

var __extends$34 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$45 = Observable_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var RangeObservable = function (_super) {
    __extends$34(RangeObservable, _super);
    function RangeObservable(start, count, scheduler) {
        _super.call(this);
        this.start = start;
        this._count = count;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits a sequence of numbers within a specified
     * range.
     *
     * <span class="informal">Emits a sequence of numbers in a range.</span>
     *
     * <img src="./img/range.png" width="100%">
     *
     * `range` operator emits a range of sequential integers, in order, where you
     * select the `start` of the range and its `length`. By default, uses no
     * Scheduler and just delivers the notifications synchronously, but may use
     * an optional Scheduler to regulate those deliveries.
     *
     * @example <caption>Emits the numbers 1 to 10</caption>
     * var numbers = Rx.Observable.range(1, 10);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link interval}
     *
     * @param {number} [start=0] The value of the first integer in the sequence.
     * @param {number} [count=0] The number of sequential integers to generate.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emissions of the notifications.
     * @return {Observable} An Observable of numbers that emits a finite range of
     * sequential integers.
     * @static true
     * @name range
     * @owner Observable
     */
    RangeObservable.create = function (start, count, scheduler) {
        if (start === void 0) {
            start = 0;
        }
        if (count === void 0) {
            count = 0;
        }
        return new RangeObservable(start, count, scheduler);
    };
    RangeObservable.dispatch = function (state) {
        var start = state.start,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(start);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        state.start = start + 1;
        this.schedule(state);
    };
    RangeObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var start = this.start;
        var count = this._count;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(RangeObservable.dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        } else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(start++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
    };
    return RangeObservable;
}(Observable_1$45.Observable);
var RangeObservable_2 = RangeObservable;

var RangeObservable_1$1 = {
    RangeObservable: RangeObservable_2
};

var RangeObservable_1 = RangeObservable_1$1;
var range_1$1 = RangeObservable_1.RangeObservable.create;

var range$2 = {
	range: range_1$1
};

var Observable_1$44 = Observable_1$2;
var range_1 = range$2;
Observable_1$44.Observable.range = range_1.range;

var __extends$35 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$47 = Observable_1$2;
var subscribeToResult_1$9 = subscribeToResult_1$1;
var OuterSubscriber_1$9 = OuterSubscriber_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var UsingObservable = function (_super) {
    __extends$35(UsingObservable, _super);
    function UsingObservable(resourceFactory, observableFactory) {
        _super.call(this);
        this.resourceFactory = resourceFactory;
        this.observableFactory = observableFactory;
    }
    UsingObservable.create = function (resourceFactory, observableFactory) {
        return new UsingObservable(resourceFactory, observableFactory);
    };
    UsingObservable.prototype._subscribe = function (subscriber) {
        var _a = this,
            resourceFactory = _a.resourceFactory,
            observableFactory = _a.observableFactory;
        var resource;
        try {
            resource = resourceFactory();
            return new UsingSubscriber(subscriber, resource, observableFactory);
        } catch (err) {
            subscriber.error(err);
        }
    };
    return UsingObservable;
}(Observable_1$47.Observable);
var UsingObservable_2 = UsingObservable;
var UsingSubscriber = function (_super) {
    __extends$35(UsingSubscriber, _super);
    function UsingSubscriber(destination, resource, observableFactory) {
        _super.call(this, destination);
        this.resource = resource;
        this.observableFactory = observableFactory;
        destination.add(resource);
        this.tryUse();
    }
    UsingSubscriber.prototype.tryUse = function () {
        try {
            var source = this.observableFactory.call(this, this.resource);
            if (source) {
                this.add(subscribeToResult_1$9.subscribeToResult(this, source));
            }
        } catch (err) {
            this._error(err);
        }
    };
    return UsingSubscriber;
}(OuterSubscriber_1$9.OuterSubscriber);

var UsingObservable_1$1 = {
    UsingObservable: UsingObservable_2
};

var UsingObservable_1 = UsingObservable_1$1;
var using_1$1 = UsingObservable_1.UsingObservable.create;

var using$2 = {
	using: using_1$1
};

var Observable_1$46 = Observable_1$2;
var using_1 = using$2;
Observable_1$46.Observable.using = using_1.using;

var __extends$36 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$49 = Observable_1$2;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = function (_super) {
    __extends$36(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error,
            subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        } else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1$49.Observable);
var ErrorObservable_2 = ErrorObservable;

var ErrorObservable_1$1 = {
    ErrorObservable: ErrorObservable_2
};

var ErrorObservable_1 = ErrorObservable_1$1;
var _throw_1 = ErrorObservable_1.ErrorObservable.create;

var _throw$2 = {
	_throw: _throw_1
};

var Observable_1$48 = Observable_1$2;
var throw_1 = _throw$2;
Observable_1$48.Observable.throw = throw_1._throw;

function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
var isDate_2 = isDate;

var isDate_1$1 = {
  isDate: isDate_2
};

var __extends$37 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1$3 = isNumeric_1$1;
var Observable_1$51 = Observable_1$2;
var async_1$3 = async;
var isScheduler_1$7 = isScheduler_1$1;
var isDate_1 = isDate_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends$37(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1$3.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1$7.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1$7.isScheduler(scheduler)) {
            scheduler = async_1$3.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` Scheduler to provide a notion of time, but you
     * may pass any Scheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1$51.Observable);
var TimerObservable_2 = TimerObservable;

var TimerObservable_1$1 = {
    TimerObservable: TimerObservable_2
};

var TimerObservable_1 = TimerObservable_1$1;
var timer_1$1 = TimerObservable_1.TimerObservable.create;

var timer$2 = {
	timer: timer_1$1
};

var Observable_1$50 = Observable_1$2;
var timer_1 = timer$2;
Observable_1$50.Observable.timer = timer_1.timer;

var __extends$38 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1$9 = ArrayObservable_1$1;
var isArray_1$10 = isArray;
var Subscriber_1$8 = Subscriber_1$3;
var OuterSubscriber_1$10 = OuterSubscriber_1$1;
var subscribeToResult_1$10 = subscribeToResult_1$1;
var iterator_1$4 = iterator;
/* tslint:disable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
var zipProto_1 = zipProto;
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1$9.ArrayObservable(observables).lift(new ZipOperator(project));
}
var zipStatic_1 = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
var ZipOperator_1 = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends$38(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1$10.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1$4.$$iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1$4.$$iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (iterator$$1.stillUnsubscribed) {
                this.add(iterator$$1.subscribe(iterator$$1, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            var result = iterator$$1.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator$$1.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1$8.Subscriber);
var ZipSubscriber_1 = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator$$1) {
        this.iterator = iterator$$1;
        this.nextResult = iterator$$1.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1$4.$$iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends$38(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1$4.$$iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1$10.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1$10.OuterSubscriber);

var zip$4 = {
    zipProto: zipProto_1,
    zipStatic: zipStatic_1,
    ZipOperator: ZipOperator_1,
    ZipSubscriber: ZipSubscriber_1
};

var zip_1$1 = zip$4;
var zip_2 = zip_1$1.zipStatic;

var zip$2 = {
	zip: zip_2
};

var Observable_1$52 = Observable_1$2;
var zip_1 = zip$2;
Observable_1$52.Observable.zip = zip_1.zip;

var __extends$40 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$10 = Subscriber_1$3;
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
var map_2 = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
var MapOperator_1 = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends$40(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1$10.Subscriber);

var map_1$1 = {
    map: map_2,
    MapOperator: MapOperator_1
};

var __extends$39 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1$9 = root;
var tryCatch_1$6 = tryCatch_1$1;
var errorObject_1$6 = errorObject;
var Observable_1$54 = Observable_1$2;
var Subscriber_1$9 = Subscriber_1$3;
var map_1 = map_1$1;
function getCORSRequest() {
    if (root_1$9.root.XMLHttpRequest) {
        var xhr = new root_1$9.root.XMLHttpRequest();
        if ('withCredentials' in xhr) {
            xhr.withCredentials = !!this.withCredentials;
        }
        return xhr;
    } else if (!!root_1$9.root.XDomainRequest) {
        return new root_1$9.root.XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1$9.root.XMLHttpRequest) {
        return new root_1$9.root.XMLHttpRequest();
    } else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1$9.root.ActiveXObject(progId)) {
                        break;
                    }
                } catch (e) {}
            }
            return new root_1$9.root.ActiveXObject(progId);
        } catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) {
        headers = null;
    }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
var ajaxGet_1 = ajaxGet;

function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
var ajaxPost_1 = ajaxPost;

function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
var ajaxDelete_1 = ajaxDelete;

function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
var ajaxPut_1 = ajaxPut;

function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers }).lift(new map_1.MapOperator(function (x, index) {
        return x.response;
    }, null));
}
var ajaxGetJSON_1 = ajaxGetJSON;

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = function (_super) {
    __extends$39(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function () {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        } else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = function () {
        var create = function (urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.getJSON = ajaxGetJSON;
        return create;
    }();
    return AjaxObservable;
}(Observable_1$54.Observable);
var AjaxObservable_2 = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = function (_super) {
    __extends$39(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1$9.root.FormData && request.body instanceof root_1$9.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this,
            xhr = _a.xhr,
            request = _a.request,
            destination = _a.destination;
        var response = new AjaxResponse$1(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this,
            request = _a.request,
            _b = _a.request,
            user = _b.user,
            method = _b.method,
            url = _b.url,
            async = _b.async,
            password = _b.password,
            headers = _b.headers,
            body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1$6.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1$6.errorObject) {
            this.error(errorObject_1$6.errorObject.e);
        } else {
            this.xhr = xhr;
            // open XHR first
            var result = void 0;
            if (user) {
                result = tryCatch_1$6.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            } else {
                result = tryCatch_1$6.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1$6.errorObject) {
                this.error(errorObject_1$6.errorObject.e);
                return null;
            }
            // timeout and responseType can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            // set headers
            this.setHeaders(xhr, headers);
            // now set up the events
            this.setupEvents(xhr, request);
            // finally send the request
            result = body ? tryCatch_1$6.tryCatch(xhr.send).call(xhr, body) : tryCatch_1$6.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1$6.errorObject) {
                this.error(errorObject_1$6.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        } else if (root_1$9.root.FormData && body instanceof root_1$9.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) {
                    return encodeURI(key) + "=" + encodeURI(body[key]);
                }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError$1(this, request)); //TODO: Make betterer.
        }
        
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr && root_1$9.root.XDomainRequest) {
            if (progressSubscriber) {
                var xhrProgress_1;
                xhrProgress_1 = function (e) {
                    var progressSubscriber = xhrProgress_1.progressSubscriber;
                    progressSubscriber.next(e);
                };
                xhr.onprogress = xhrProgress_1;
                xhrProgress_1.progressSubscriber = progressSubscriber;
            }
            var xhrError_1;
            xhrError_1 = function (e) {
                var _a = xhrError_1,
                    progressSubscriber = _a.progressSubscriber,
                    subscriber = _a.subscriber,
                    request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError$1('ajax error', this, request));
            };
            xhr.onerror = xhrError_1;
            xhrError_1.request = request;
            xhrError_1.subscriber = this;
            xhrError_1.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = this.responseType === 'text' ? this.response || this.responseText : this.response;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                } else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError$1('ajax error ' + status_1, this, request));
                }
            }
        }
        
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this,
            done = _a.done,
            xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1$9.Subscriber);
var AjaxSubscriber_1 = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse$1 = function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        switch (this.responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                } else {
                    this.response = JSON.parse(xhr.responseText || 'null');
                }
                break;
            case 'xml':
                this.response = xhr.responseXML;
                break;
            case 'text':
            default:
                this.response = 'response' in xhr ? xhr.response : xhr.responseText;
                break;
        }
    }
    return AjaxResponse;
}();
var AjaxResponse_1 = AjaxResponse$1;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError$1 = function (_super) {
    __extends$39(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
    return AjaxError;
}(Error);
var AjaxError_1 = AjaxError$1;
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError$1 = function (_super) {
    __extends$39(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError$1);
var AjaxTimeoutError_1 = AjaxTimeoutError$1;

var AjaxObservable_1$2 = {
    ajaxGet: ajaxGet_1,
    ajaxPost: ajaxPost_1,
    ajaxDelete: ajaxDelete_1,
    ajaxPut: ajaxPut_1,
    ajaxGetJSON: ajaxGetJSON_1,
    AjaxObservable: AjaxObservable_2,
    AjaxSubscriber: AjaxSubscriber_1,
    AjaxResponse: AjaxResponse_1,
    AjaxError: AjaxError_1,
    AjaxTimeoutError: AjaxTimeoutError_1
};

var AjaxObservable_1$1 = AjaxObservable_1$2;
var ajax_1$1 = AjaxObservable_1$1.AjaxObservable.create;

var ajax$2 = {
	ajax: ajax_1$1
};

var Observable_1$53 = Observable_1$2;
var ajax_1 = ajax$2;
Observable_1$53.Observable.ajax = ajax_1.ajax;

var __extends$43 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1$3 = AsyncAction_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = function (_super) {
    __extends$43(QueueAction, _super);
    function QueueAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1$3.AsyncAction);
var QueueAction_2 = QueueAction;

var QueueAction_1$1 = {
    QueueAction: QueueAction_2
};

var __extends$44 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1$3 = AsyncScheduler_1$1;
var QueueScheduler = function (_super) {
    __extends$44(QueueScheduler, _super);
    function QueueScheduler() {
        _super.apply(this, arguments);
    }
    return QueueScheduler;
}(AsyncScheduler_1$3.AsyncScheduler);
var QueueScheduler_2 = QueueScheduler;

var QueueScheduler_1$1 = {
    QueueScheduler: QueueScheduler_2
};

var QueueAction_1 = QueueAction_1$1;
var QueueScheduler_1 = QueueScheduler_1$1;
var queue_1$2 = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

var queue = {
	queue: queue_1$2
};

var __extends$42 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$5 = Subject_1$1;
var queue_1$1 = queue;
var Subscription_1$11 = Subscription_1$3;
var observeOn_1$3 = observeOn_1$1;
var ObjectUnsubscribedError_1$4 = ObjectUnsubscribedError_1$2;
var SubjectSubscription_1$3 = SubjectSubscription_1$1;
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject$1 = function (_super) {
    __extends$42(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        _super.call(this);
        this.scheduler = scheduler;
        this._events = [];
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;
    }
    ReplaySubject.prototype.next = function (value) {
        var now = this._getNow();
        this._events.push(new ReplayEvent(now, value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _events = this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1$4.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscription = Subscription_1$11.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscription = Subscription_1$11.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1$3.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1$3.ObserveOnSubscriber(subscriber, scheduler));
        }
        var len = _events.length;
        for (var i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        } else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1$1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if (now - _events[spliceCount].time < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1$5.Subject);
var ReplaySubject_2 = ReplaySubject$1;
var ReplayEvent = function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}();

var ReplaySubject_1$2 = {
    ReplaySubject: ReplaySubject_2
};

var root_1$11 = root;
function assignImpl(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var len = sources.length;
    for (var i = 0; i < len; i++) {
        var source = sources[i];
        for (var k in source) {
            if (source.hasOwnProperty(k)) {
                target[k] = source[k];
            }
        }
    }
    return target;
}
var assignImpl_1 = assignImpl;

function getAssign(root$$1) {
    return root$$1.Object.assign || assignImpl;
}
var getAssign_1 = getAssign;
var assign_1$1 = getAssign(root_1$11.root);

var assign = {
    assignImpl: assignImpl_1,
    getAssign: getAssign_1,
    assign: assign_1$1
};

var __extends$41 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$4 = Subject_1$1;
var Subscriber_1$11 = Subscriber_1$3;
var Observable_1$56 = Observable_1$2;
var Subscription_1$10 = Subscription_1$3;
var root_1$10 = root;
var ReplaySubject_1$1 = ReplaySubject_1$2;
var tryCatch_1$7 = tryCatch_1$1;
var errorObject_1$7 = errorObject;
var assign_1 = assign;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var WebSocketSubject = function (_super) {
    __extends$41(WebSocketSubject, _super);
    function WebSocketSubject(urlConfigOrSource, destination) {
        if (urlConfigOrSource instanceof Observable_1$56.Observable) {
            _super.call(this, destination, urlConfigOrSource);
        } else {
            _super.call(this);
            this.WebSocketCtor = root_1$10.root.WebSocket;
            this._output = new Subject_1$4.Subject();
            if (typeof urlConfigOrSource === 'string') {
                this.url = urlConfigOrSource;
            } else {
                // WARNING: config object could override important members here.
                assign_1.assign(this, urlConfigOrSource);
            }
            if (!this.WebSocketCtor) {
                throw new Error('no WebSocket constructor can be found');
            }
            this.destination = new ReplaySubject_1$1.ReplaySubject();
        }
    }
    WebSocketSubject.prototype.resultSelector = function (e) {
        return JSON.parse(e.data);
    };
    /**
     * @param urlConfigOrSource
     * @return {WebSocketSubject}
     * @static true
     * @name webSocket
     * @owner Observable
     */
    WebSocketSubject.create = function (urlConfigOrSource) {
        return new WebSocketSubject(urlConfigOrSource);
    };
    WebSocketSubject.prototype.lift = function (operator) {
        var sock = new WebSocketSubject(this, this.destination);
        sock.operator = operator;
        return sock;
    };
    WebSocketSubject.prototype._resetState = function () {
        this.socket = null;
        if (!this.source) {
            this.destination = new ReplaySubject_1$1.ReplaySubject();
        }
        this._output = new Subject_1$4.Subject();
    };
    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
        var self = this;
        return new Observable_1$56.Observable(function (observer) {
            var result = tryCatch_1$7.tryCatch(subMsg)();
            if (result === errorObject_1$7.errorObject) {
                observer.error(errorObject_1$7.errorObject.e);
            } else {
                self.next(result);
            }
            var subscription = self.subscribe(function (x) {
                var result = tryCatch_1$7.tryCatch(messageFilter)(x);
                if (result === errorObject_1$7.errorObject) {
                    observer.error(errorObject_1$7.errorObject.e);
                } else if (result) {
                    observer.next(x);
                }
            }, function (err) {
                return observer.error(err);
            }, function () {
                return observer.complete();
            });
            return function () {
                var result = tryCatch_1$7.tryCatch(unsubMsg)();
                if (result === errorObject_1$7.errorObject) {
                    observer.error(errorObject_1$7.errorObject.e);
                } else {
                    self.next(result);
                }
                subscription.unsubscribe();
            };
        });
    };
    WebSocketSubject.prototype._connectSocket = function () {
        var _this = this;
        var WebSocketCtor = this.WebSocketCtor;
        var observer = this._output;
        var socket = null;
        try {
            socket = this.protocol ? new WebSocketCtor(this.url, this.protocol) : new WebSocketCtor(this.url);
            this.socket = socket;
        } catch (e) {
            observer.error(e);
            return;
        }
        var subscription = new Subscription_1$10.Subscription(function () {
            _this.socket = null;
            if (socket && socket.readyState === 1) {
                socket.close();
            }
        });
        socket.onopen = function (e) {
            var openObserver = _this.openObserver;
            if (openObserver) {
                openObserver.next(e);
            }
            var queue = _this.destination;
            _this.destination = Subscriber_1$11.Subscriber.create(function (x) {
                return socket.readyState === 1 && socket.send(x);
            }, function (e) {
                var closingObserver = _this.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                if (e && e.code) {
                    socket.close(e.code, e.reason);
                } else {
                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' + 'and an optional reason: { code: number, reason: string }'));
                }
                _this._resetState();
            }, function () {
                var closingObserver = _this.closingObserver;
                if (closingObserver) {
                    closingObserver.next(undefined);
                }
                socket.close();
                _this._resetState();
            });
            if (queue && queue instanceof ReplaySubject_1$1.ReplaySubject) {
                subscription.add(queue.subscribe(_this.destination));
            }
        };
        socket.onerror = function (e) {
            _this._resetState();
            observer.error(e);
        };
        socket.onclose = function (e) {
            _this._resetState();
            var closeObserver = _this.closeObserver;
            if (closeObserver) {
                closeObserver.next(e);
            }
            if (e.wasClean) {
                observer.complete();
            } else {
                observer.error(e);
            }
        };
        socket.onmessage = function (e) {
            var result = tryCatch_1$7.tryCatch(_this.resultSelector)(e);
            if (result === errorObject_1$7.errorObject) {
                observer.error(errorObject_1$7.errorObject.e);
            } else {
                observer.next(result);
            }
        };
    };
    WebSocketSubject.prototype._subscribe = function (subscriber) {
        var _this = this;
        var source = this.source;
        if (source) {
            return source.subscribe(subscriber);
        }
        if (!this.socket) {
            this._connectSocket();
        }
        var subscription = new Subscription_1$10.Subscription();
        subscription.add(this._output.subscribe(subscriber));
        subscription.add(function () {
            var socket = _this.socket;
            if (_this._output.observers.length === 0) {
                if (socket && socket.readyState === 1) {
                    socket.close();
                }
                _this._resetState();
            }
        });
        return subscription;
    };
    WebSocketSubject.prototype.unsubscribe = function () {
        var _a = this,
            source = _a.source,
            socket = _a.socket;
        if (socket && socket.readyState === 1) {
            socket.close();
            this._resetState();
        }
        _super.prototype.unsubscribe.call(this);
        if (!source) {
            this.destination = new ReplaySubject_1$1.ReplaySubject();
        }
    };
    return WebSocketSubject;
}(Subject_1$4.AnonymousSubject);
var WebSocketSubject_2 = WebSocketSubject;

var WebSocketSubject_1$1 = {
    WebSocketSubject: WebSocketSubject_2
};

var WebSocketSubject_1 = WebSocketSubject_1$1;
var webSocket_1$1 = WebSocketSubject_1.WebSocketSubject.create;

var webSocket$2 = {
	webSocket: webSocket_1$1
};

var Observable_1$55 = Observable_1$2;
var webSocket_1 = webSocket$2;
Observable_1$55.Observable.webSocket = webSocket_1.webSocket;

var __extends$45 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$11 = OuterSubscriber_1$1;
var subscribeToResult_1$11 = subscribeToResult_1$1;
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
function buffer$2(closingNotifier) {
    return this.lift(new BufferOperator(closingNotifier));
}
var buffer_2 = buffer$2;
var BufferOperator = function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = function (_super) {
    __extends$45(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        _super.call(this, destination);
        this.buffer = [];
        this.add(subscribeToResult_1$11.subscribeToResult(this, closingNotifier));
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1$11.OuterSubscriber);

var buffer_1$1 = {
    buffer: buffer_2
};

var Observable_1$57 = Observable_1$2;
var buffer_1 = buffer_1$1;
Observable_1$57.Observable.prototype.buffer = buffer_1.buffer;

var __extends$46 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$12 = Subscriber_1$3;
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
function bufferCount$2(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
        startBufferEvery = null;
    }
    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
}
var bufferCount_2 = bufferCount$2;
var BufferCountOperator = function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = function (_super) {
    __extends$46(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
        _super.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var count = this.count++;
        var _a = this,
            destination = _a.destination,
            bufferSize = _a.bufferSize,
            startBufferEvery = _a.startBufferEvery,
            buffers = _a.buffers;
        var startOn = startBufferEvery == null ? bufferSize : startBufferEvery;
        if (count % startOn === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                destination.next(buffer);
            }
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var buffers = this.buffers;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1$12.Subscriber);

var bufferCount_1$1 = {
    bufferCount: bufferCount_2
};

var Observable_1$58 = Observable_1$2;
var bufferCount_1 = bufferCount_1$1;
Observable_1$58.Observable.prototype.bufferCount = bufferCount_1.bufferCount;

var __extends$47 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1$4 = async;
var Subscriber_1$13 = Subscriber_1$3;
var isScheduler_1$8 = isScheduler_1$1;
/* tslint:disable:max-line-length */
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */
function bufferTime$2(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1$4.async;
    if (isScheduler_1$8.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
}
var bufferTime_2 = bufferTime$2;
var BufferTimeOperator = function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}();
var Context = function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = function (_super) {
    __extends$47(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        _super.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        var context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
            var closeState = { subscriber: this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context = contexts[i];
            var buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this,
            contexts = _a.contexts,
            destination = _a.destination;
        while (contexts.length > 0) {
            var context = contexts.shift();
            destination.next(context.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1$13.Subscriber);
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval,
        bufferTimeSpan = state.bufferTimeSpan,
        subscriber = state.subscriber,
        scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber,
        context = arg.context;
    subscriber.closeContext(context);
}

var bufferTime_1$1 = {
    bufferTime: bufferTime_2
};

var Observable_1$59 = Observable_1$2;
var bufferTime_1 = bufferTime_1$1;
Observable_1$59.Observable.prototype.bufferTime = bufferTime_1.bufferTime;

var __extends$48 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1$12 = Subscription_1$3;
var subscribeToResult_1$12 = subscribeToResult_1$1;
var OuterSubscriber_1$12 = OuterSubscriber_1$1;
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
function bufferToggle$2(openings, closingSelector) {
    return this.lift(new BufferToggleOperator(openings, closingSelector));
}
var bufferToggle_2 = bufferToggle$2;
var BufferToggleOperator = function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = function (_super) {
    __extends$48(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(subscribeToResult_1$12.subscribeToResult(this, openings));
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context = contexts.shift();
            this.destination.next(context.buffer);
            context.subscription.unsubscribe();
            context.buffer = null;
            context.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        } catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer,
                subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1$12.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1$12.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        } else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1$12.OuterSubscriber);

var bufferToggle_1$1 = {
    bufferToggle: bufferToggle_2
};

var Observable_1$60 = Observable_1$2;
var bufferToggle_1 = bufferToggle_1$1;
Observable_1$60.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;

var __extends$49 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1$13 = Subscription_1$3;
var tryCatch_1$8 = tryCatch_1$1;
var errorObject_1$8 = errorObject;
var OuterSubscriber_1$13 = OuterSubscriber_1$1;
var subscribeToResult_1$13 = subscribeToResult_1$1;
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
function bufferWhen$2(closingSelector) {
    return this.lift(new BufferWhenOperator(closingSelector));
}
var bufferWhen_2 = bufferWhen$2;
var BufferWhenOperator = function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = function (_super) {
    __extends$49(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        } else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch_1$8.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1$8.errorObject) {
            this.error(errorObject_1$8.errorObject.e);
        } else {
            closingSubscription = new Subscription_1$13.Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult_1$13.subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1$13.OuterSubscriber);

var bufferWhen_1$1 = {
    bufferWhen: bufferWhen_2
};

var Observable_1$61 = Observable_1$2;
var bufferWhen_1 = bufferWhen_1$1;
Observable_1$61.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;

var __extends$50 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$14 = OuterSubscriber_1$1;
var subscribeToResult_1$14 = subscribeToResult_1$1;
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} an observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch$2(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
var _catch_2 = _catch$2;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends$50(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err) {
                this.destination.error(err);
                return;
            }
            this.unsubscribe();
            this.destination.remove(this);
            subscribeToResult_1$14.subscribeToResult(this, result);
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1$14.OuterSubscriber);

var _catch_1 = {
    _catch: _catch_2
};

var Observable_1$62 = Observable_1$2;
var catch_1 = _catch_1;
Observable_1$62.Observable.prototype.catch = catch_1._catch;
Observable_1$62.Observable.prototype._catch = catch_1._catch;

var combineLatest_1$4 = combineLatest_1$2;
/**
 * Converts a higher-order Observable into a first-order Observable by waiting
 * for the outer Observable to complete, then applying {@link combineLatest}.
 *
 * <span class="informal">Flattens an Observable-of-Observables by applying
 * {@link combineLatest} when the Observable-of-Observables completes.</span>
 *
 * <img src="./img/combineAll.png" width="100%">
 *
 * Takes an Observable of Observables, and collects all Observables from it.
 * Once the outer Observable completes, it subscribes to all collected
 * Observables and combines their values using the {@link combineLatest}
 * strategy, such that:
 * - Every time an inner Observable emits, the output Observable emits.
 * - When the returned observable emits, it emits all of the latest values by:
 *   - If a `project` function is provided, it is called with each recent value
 *     from each inner Observable in whatever order they arrived, and the result
 *     of the `project` function is what is emitted by the output Observable.
 *   - If there is no `project` function, an array of all of the most recent
 *     values is emitted by the output Observable.
 *
 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev =>
 *   Rx.Observable.interval(Math.random()*2000).take(3)
 * ).take(2);
 * var result = higherOrder.combineAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 * @see {@link mergeAll}
 *
 * @param {function} [project] An optional function to map the most recent
 * values from each inner Observable into a new result. Takes each of the most
 * recent values from each collected inner Observable as arguments, in order.
 * @return {Observable} An Observable of projected results or arrays of recent
 * values.
 * @method combineAll
 * @owner Observable
 */
function combineAll$2(project) {
  return this.lift(new combineLatest_1$4.CombineLatestOperator(project));
}
var combineAll_2 = combineAll$2;

var combineAll_1$1 = {
  combineAll: combineAll_2
};

var Observable_1$63 = Observable_1$2;
var combineAll_1 = combineAll_1$1;
Observable_1$63.Observable.prototype.combineAll = combineAll_1.combineAll;

var Observable_1$64 = Observable_1$2;
var combineLatest_1$5 = combineLatest_1$2;
Observable_1$64.Observable.prototype.combineLatest = combineLatest_1$5.combineLatest;

var Observable_1$65 = Observable_1$2;
var concat_1$4 = concat_1$2;
Observable_1$65.Observable.prototype.concat = concat_1$4.concat;

var mergeAll_1$4 = mergeAll_1$1;
/* tslint:disable:max-line-length */
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll$2() {
  return this.lift(new mergeAll_1$4.MergeAllOperator(1));
}
var concatAll_2 = concatAll$2;

var concatAll_1$1 = {
  concatAll: concatAll_2
};

var Observable_1$66 = Observable_1$2;
var concatAll_1 = concatAll_1$1;
Observable_1$66.Observable.prototype.concatAll = concatAll_1.concatAll;

var __extends$51 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1$15 = subscribeToResult_1$1;
var OuterSubscriber_1$15 = OuterSubscriber_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
var mergeMap_2 = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
var MergeMapOperator_1 = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends$51(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1$15.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1$15.OuterSubscriber);
var MergeMapSubscriber_1 = MergeMapSubscriber;

var mergeMap_1$1 = {
    mergeMap: mergeMap_2,
    MergeMapOperator: MergeMapOperator_1,
    MergeMapSubscriber: MergeMapSubscriber_1
};

var mergeMap_1 = mergeMap_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} an observable of values merged from the projected
 * Observables as they were subscribed to, one at a time. Optionally, these
 * values may have been projected from a passed `projectResult` argument.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap$2(project, resultSelector) {
  return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
}
var concatMap_2 = concatMap$2;

var concatMap_1$1 = {
  concatMap: concatMap_2
};

var Observable_1$67 = Observable_1$2;
var concatMap_1 = concatMap_1$1;
Observable_1$67.Observable.prototype.concatMap = concatMap_1.concatMap;

var __extends$52 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$16 = OuterSubscriber_1$1;
var subscribeToResult_1$16 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
}
var mergeMapTo_2 = mergeMapTo;
// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
var MergeMapToOperator = function () {
    function MergeMapToOperator(ish, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapToOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
    };
    return MergeMapToOperator;
}();
var MergeMapToOperator_1 = MergeMapToOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapToSubscriber = function (_super) {
    __extends$52(MergeMapToSubscriber, _super);
    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapToSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            this.active++;
            this._innerSub(ish, destination, resultSelector, value, index);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
        this.add(subscribeToResult_1$16.subscribeToResult(this, ish, value, index));
    };
    MergeMapToSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    MergeMapToSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapToSubscriber;
}(OuterSubscriber_1$16.OuterSubscriber);
var MergeMapToSubscriber_1 = MergeMapToSubscriber;

var mergeMapTo_1$1 = {
    mergeMapTo: mergeMapTo_2,
    MergeMapToOperator: MergeMapToOperator_1,
    MergeMapToSubscriber: MergeMapToSubscriber_1
};

var mergeMapTo_1 = mergeMapTo_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo$2(innerObservable, resultSelector) {
  return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
}
var concatMapTo_2 = concatMapTo$2;

var concatMapTo_1$1 = {
  concatMapTo: concatMapTo_2
};

var Observable_1$68 = Observable_1$2;
var concatMapTo_1 = concatMapTo_1$1;
Observable_1$68.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;

var __extends$53 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$14 = Subscriber_1$3;
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting an value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 4
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */
function count$2(predicate) {
    return this.lift(new CountOperator(predicate, this));
}
var count_2 = count$2;
var CountOperator = function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = function (_super) {
    __extends$53(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        } else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1$14.Subscriber);

var count_1$1 = {
    count: count_2
};

var Observable_1$69 = Observable_1$2;
var count_1 = count_1$1;
Observable_1$69.Observable.prototype.count = count_1.count;

var __extends$54 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$15 = Subscriber_1$3;
/**
 * Converts an Observable of {@link Notification} objects into the emissions
 * that they represent.
 *
 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
 *
 * <img src="./img/dematerialize.png" width="100%">
 *
 * `dematerialize` is assumed to operate an Observable that only emits
 * {@link Notification} objects as `next` emissions, and does not emit any
 * `error`. Such Observable is the output of a `materialize` operation. Those
 * notifications are then unwrapped using the metadata they contain, and emitted
 * as `next`, `error`, and `complete` on the output Observable.
 *
 * Use this operator in conjunction with {@link materialize}.
 *
 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
 * var notifA = new Rx.Notification('N', 'A');
 * var notifB = new Rx.Notification('N', 'B');
 * var notifE = new Rx.Notification('E', void 0,
 *   new TypeError('x.toUpperCase is not a function')
 * );
 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
 * var upperCase = materialized.dematerialize();
 * upperCase.subscribe(x => console.log(x), e => console.error(e));
 *
 * // Results in:
 * // A
 * // B
 * // TypeError: x.toUpperCase is not a function
 *
 * @see {@link Notification}
 * @see {@link materialize}
 *
 * @return {Observable} An Observable that emits items and notifications
 * embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */
function dematerialize$2() {
    return this.lift(new DeMaterializeOperator());
}
var dematerialize_2 = dematerialize$2;
var DeMaterializeOperator = function () {
    function DeMaterializeOperator() {}
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = function (_super) {
    __extends$54(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1$15.Subscriber);

var dematerialize_1$1 = {
    dematerialize: dematerialize_2
};

var Observable_1$70 = Observable_1$2;
var dematerialize_1 = dematerialize_1$1;
Observable_1$70.Observable.prototype.dematerialize = dematerialize_1.dematerialize;

var __extends$55 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$17 = OuterSubscriber_1$1;
var subscribeToResult_1$17 = subscribeToResult_1$1;
/**
 * Emits a value from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * <img src="./img/debounce.png" width="100%">
 *
 * `debounce` delays values emitted by the source Observable, but drops previous
 * pending delayed emissions if a new value arrives on the source Observable.
 * This operator keeps track of the most recent value from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The value is emitted only when the duration
 * Observable emits a value or completes, and if no other value was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * value appears before the duration Observable emits, the previous value will
 * be dropped and will not be emitted on the output Observable.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 * @see {@link throttle}
 *
 * @param {function(value: T): Observable|Promise} durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 * @method debounce
 * @owner Observable
 */
function debounce$2(durationSelector) {
    return this.lift(new DebounceOperator(durationSelector));
}
var debounce_2 = debounce$2;
var DebounceOperator = function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = function (_super) {
    __extends$55(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        } catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1$17.subscribeToResult(this, duration);
        if (!subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1$17.OuterSubscriber);

var debounce_1$1 = {
    debounce: debounce_2
};

var Observable_1$71 = Observable_1$2;
var debounce_1 = debounce_1$1;
Observable_1$71.Observable.prototype.debounce = debounce_1.debounce;

var __extends$56 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$16 = Subscriber_1$3;
var async_1$5 = async;
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link Scheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime$2(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$5.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
var debounceTime_2 = debounceTime$2;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends$56(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$3, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1$16.Subscriber);
function dispatchNext$3(subscriber) {
    subscriber.debouncedNext();
}

var debounceTime_1$1 = {
    debounceTime: debounceTime_2
};

var Observable_1$72 = Observable_1$2;
var debounceTime_1 = debounceTime_1$1;
Observable_1$72.Observable.prototype.debounceTime = debounceTime_1.debounceTime;

var __extends$57 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$17 = Subscriber_1$3;
/* tslint:disable:max-line-length */
/**
 * Emits a given value if the source Observable completes without emitting any
 * `next` value, otherwise mirrors the source Observable.
 *
 * <span class="informal">If the source Observable turns out to be empty, then
 * this operator will emit a default value.</span>
 *
 * <img src="./img/defaultIfEmpty.png" width="100%">
 *
 * `defaultIfEmpty` emits the values emitted by the source Observable or a
 * specified default value if the source Observable is empty (completes without
 * having emitted any `next` value).
 *
 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link empty}
 * @see {@link last}
 *
 * @param {any} [defaultValue=null] The default value used if the source
 * Observable is empty.
 * @return {Observable} An Observable that emits either the specified
 * `defaultValue` if the source Observable emits no items, or the values emitted
 * by the source Observable.
 * @method defaultIfEmpty
 * @owner Observable
 */
function defaultIfEmpty$2(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return this.lift(new DefaultIfEmptyOperator(defaultValue));
}
var defaultIfEmpty_2 = defaultIfEmpty$2;
var DefaultIfEmptyOperator = function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = function (_super) {
    __extends$57(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _super.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1$17.Subscriber);

var defaultIfEmpty_1$1 = {
    defaultIfEmpty: defaultIfEmpty_2
};

var Observable_1$73 = Observable_1$2;
var defaultIfEmpty_1 = defaultIfEmpty_1$1;
Observable_1$73.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;

var __extends$58 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1$6 = async;
var isDate_1$3 = isDate_1$1;
var Subscriber_1$18 = Subscriber_1$3;
var Notification_1$4 = Notification_1$2;
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The Scheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay$2(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$6.async;
    }
    var absoluteDelay = isDate_1$3.isDate(delay);
    var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}
var delay_2 = delay$2;
var DelayOperator = function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = function (_super) {
    __extends$58(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        } else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1$4.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1$4.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1$18.Subscriber);
var DelayMessage = function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}();

var delay_1$1 = {
    delay: delay_2
};

var Observable_1$74 = Observable_1$2;
var delay_1 = delay_1$1;
Observable_1$74.Observable.prototype.delay = delay_1.delay;

var __extends$59 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$19 = Subscriber_1$3;
var Observable_1$76 = Observable_1$2;
var OuterSubscriber_1$18 = OuterSubscriber_1$1;
var subscribeToResult_1$18 = subscribeToResult_1$1;
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * <img src="./img/delayWhen.png" width="100%">
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delayWhen(event =>
 *   Rx.Observable.interval(Math.random() * 5000)
 * );
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounce}
 * @see {@link delay}
 *
 * @param {function(value: T): Observable} delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param {Observable} subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */
function delayWhen$2(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return new SubscriptionDelayObservable(this, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    }
    return this.lift(new DelayWhenOperator(delayDurationSelector));
}
var delayWhen_2 = delayWhen$2;
var DelayWhenOperator = function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = function (_super) {
    __extends$59(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        _super.call(this, destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.values = [];
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        } catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1$18.subscribeToResult(this, delayNotifier, value);
        this.add(notifierSubscription);
        this.delayNotifierSubscriptions.push(notifierSubscription);
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1$18.OuterSubscriber);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = function (_super) {
    __extends$59(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        _super.call(this);
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1$76.Observable);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = function (_super) {
    __extends$59(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        _super.call(this);
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1$19.Subscriber);

var delayWhen_1$1 = {
    delayWhen: delayWhen_2
};

var Observable_1$75 = Observable_1$2;
var delayWhen_1 = delayWhen_1$1;
Observable_1$75.Observable.prototype.delayWhen = delayWhen_1.delayWhen;

var root_1$12 = root;
function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }();
}
var minimalSetImpl_1 = minimalSetImpl;
var Set = root_1$12.root.Set || minimalSetImpl();

var _Set = {
    minimalSetImpl: minimalSetImpl_1,
    Set: Set
};

var __extends$60 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$19 = OuterSubscriber_1$1;
var subscribeToResult_1$19 = subscribeToResult_1$1;
var Set_1 = _Set;
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 * @param {function} [keySelector] optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */
function distinct$2(keySelector, flushes) {
    return this.lift(new DistinctOperator(keySelector, flushes));
}
var distinct_2 = distinct$2;
var DistinctOperator = function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = function (_super) {
    __extends$60(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.values = new Set_1.Set();
        if (flushes) {
            this.add(subscribeToResult_1$19.subscribeToResult(this, flushes));
        }
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        } else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        } catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1$19.OuterSubscriber);
var DistinctSubscriber_1 = DistinctSubscriber;

var distinct_1$1 = {
    distinct: distinct_2,
    DistinctSubscriber: DistinctSubscriber_1
};

var Observable_1$77 = Observable_1$2;
var distinct_1 = distinct_1$1;
Observable_1$77.Observable.prototype.distinct = distinct_1.distinct;

var __extends$61 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$20 = Subscriber_1$3;
var tryCatch_1$9 = tryCatch_1$1;
var errorObject_1$9 = errorObject;
/* tslint:disable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged$2(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
var distinctUntilChanged_2 = distinctUntilChanged$2;
var DistinctUntilChangedOperator = function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = function (_super) {
    __extends$61(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1$9.tryCatch(this.keySelector)(value);
            if (key === errorObject_1$9.errorObject) {
                return this.destination.error(errorObject_1$9.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1$9.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1$9.errorObject) {
                return this.destination.error(errorObject_1$9.errorObject.e);
            }
        } else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1$20.Subscriber);

var distinctUntilChanged_1$1 = {
    distinctUntilChanged: distinctUntilChanged_2
};

var Observable_1$78 = Observable_1$2;
var distinctUntilChanged_1 = distinctUntilChanged_1$1;
Observable_1$78.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;

var distinctUntilChanged_1$3 = distinctUntilChanged_1$1;
/* tslint:disable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * @param {string} key string key for object property lookup on each item.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged$2(key, compare) {
    return distinctUntilChanged_1$3.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}
var distinctUntilKeyChanged_2 = distinctUntilKeyChanged$2;

var distinctUntilKeyChanged_1$1 = {
    distinctUntilKeyChanged: distinctUntilKeyChanged_2
};

var Observable_1$79 = Observable_1$2;
var distinctUntilKeyChanged_1 = distinctUntilKeyChanged_1$1;
Observable_1$79.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;

var __extends$62 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$21 = Subscriber_1$3;
/* tslint:disable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do$2(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
var _do_2 = _do$2;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends$62(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1$21.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1$21.Subscriber);

var _do_1 = {
    _do: _do_2
};

var Observable_1$80 = Observable_1$2;
var do_1 = _do_1;
Observable_1$80.Observable.prototype.do = do_1._do;
Observable_1$80.Observable.prototype._do = do_1._do;

var __extends$63 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$20 = OuterSubscriber_1$1;
var subscribeToResult_1$20 = subscribeToResult_1$1;
/**
 * Converts a higher-order Observable into a first-order Observable by dropping
 * inner Observables while the previous inner Observable has not yet completed.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * next inner Observables while the current inner is still executing.</span>
 *
 * <img src="./img/exhaust.png" width="100%">
 *
 * `exhaust` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable begins emitting the items emitted by that
 * inner Observable. So far, it behaves like {@link mergeAll}. However,
 * `exhaust` ignores every new inner Observable if the previous Observable has
 * not yet completed. Once that one completes, it will accept and flatten the
 * next inner Observable and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var result = higherOrder.exhaust();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link switch}
 * @see {@link mergeAll}
 * @see {@link exhaustMap}
 * @see {@link zipAll}
 *
 * @return {Observable} Returns an Observable that takes a source of Observables
 * and propagates the first observable exclusively until it completes before
 * subscribing to the next.
 * @method exhaust
 * @owner Observable
 */
function exhaust$2() {
    return this.lift(new SwitchFirstOperator());
}
var exhaust_2 = exhaust$2;
var SwitchFirstOperator = function () {
    function SwitchFirstOperator() {}
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = function (_super) {
    __extends$63(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        _super.call(this, destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1$20.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1$20.OuterSubscriber);

var exhaust_1$1 = {
    exhaust: exhaust_2
};

var Observable_1$81 = Observable_1$2;
var exhaust_1 = exhaust_1$1;
Observable_1$81.Observable.prototype.exhaust = exhaust_1.exhaust;

var __extends$64 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$21 = OuterSubscriber_1$1;
var subscribeToResult_1$21 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap$2(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}
var exhaustMap_2 = exhaustMap$2;
var SwitchFirstMapOperator = function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = function (_super) {
    __extends$64(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1$21.subscribeToResult(this, result, value, index));
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1$21.OuterSubscriber);

var exhaustMap_1$1 = {
    exhaustMap: exhaustMap_2
};

var Observable_1$82 = Observable_1$2;
var exhaustMap_1 = exhaustMap_1$1;
Observable_1$82.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;

var __extends$65 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1$10 = tryCatch_1$1;
var errorObject_1$10 = errorObject;
var OuterSubscriber_1$22 = OuterSubscriber_1$1;
var subscribeToResult_1$22 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */
function expand$2(project, concurrent, scheduler) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (scheduler === void 0) {
        scheduler = undefined;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return this.lift(new ExpandOperator(project, concurrent, scheduler));
}
var expand_2 = expand$2;
var ExpandOperator = function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}();
var ExpandOperator_1 = ExpandOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = function (_super) {
    __extends$65(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        _super.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber,
            result = arg.result,
            value = arg.value,
            index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch_1$10.tryCatch(this.project)(value, index);
            if (result === errorObject_1$10.errorObject) {
                destination.error(errorObject_1$10.errorObject.e);
            } else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            } else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        } else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult_1$22.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1$22.OuterSubscriber);
var ExpandSubscriber_1 = ExpandSubscriber;

var expand_1$1 = {
    expand: expand_2,
    ExpandOperator: ExpandOperator_1,
    ExpandSubscriber: ExpandSubscriber_1
};

var Observable_1$83 = Observable_1$2;
var expand_1 = expand_1$1;
Observable_1$83.Observable.prototype.expand = expand_1.expand;

var __extends$67 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError$1 = function (_super) {
    __extends$67(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error);
var ArgumentOutOfRangeError_2 = ArgumentOutOfRangeError$1;

var ArgumentOutOfRangeError_1$2 = {
    ArgumentOutOfRangeError: ArgumentOutOfRangeError_2
};

var __extends$66 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$22 = Subscriber_1$3;
var ArgumentOutOfRangeError_1$1 = ArgumentOutOfRangeError_1$2;
/**
 * Emits the single value at the specified `index` in a sequence of emissions
 * from the source Observable.
 *
 * <span class="informal">Emits only the i-th value, then completes.</span>
 *
 * <img src="./img/elementAt.png" width="100%">
 *
 * `elementAt` returns an Observable that emits the item at the specified
 * `index` in the source Observable, or a default value if that `index` is out
 * of range and the `default` argument is provided. If the `default` argument is
 * not given and the `index` is out of range, the output Observable will emit an
 * `ArgumentOutOfRangeError` error.
 *
 * @example <caption>Emit only the third click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.elementAt(2);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // click 1 = nothing
 * // click 2 = nothing
 * // click 3 = MouseEvent object logged to console
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link skip}
 * @see {@link single}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
 * Observable has completed before emitting the i-th `next` notification.
 *
 * @param {number} index Is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {T} [defaultValue] The default value returned for missing indices.
 * @return {Observable} An Observable that emits a single item, if it is found.
 * Otherwise, will emit the default value if given. If not, then emits an error.
 * @method elementAt
 * @owner Observable
 */
function elementAt$2(index, defaultValue) {
    return this.lift(new ElementAtOperator(index, defaultValue));
}
var elementAt_2 = elementAt$2;
var ElementAtOperator = function () {
    function ElementAtOperator(index, defaultValue) {
        this.index = index;
        this.defaultValue = defaultValue;
        if (index < 0) {
            throw new ArgumentOutOfRangeError_1$1.ArgumentOutOfRangeError();
        }
    }
    ElementAtOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
    };
    return ElementAtOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ElementAtSubscriber = function (_super) {
    __extends$66(ElementAtSubscriber, _super);
    function ElementAtSubscriber(destination, index, defaultValue) {
        _super.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }
    ElementAtSubscriber.prototype._next = function (x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };
    ElementAtSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            } else {
                destination.error(new ArgumentOutOfRangeError_1$1.ArgumentOutOfRangeError());
            }
        }
        destination.complete();
    };
    return ElementAtSubscriber;
}(Subscriber_1$22.Subscriber);

var elementAt_1$1 = {
    elementAt: elementAt_2
};

var Observable_1$84 = Observable_1$2;
var elementAt_1 = elementAt_1$1;
Observable_1$84.Observable.prototype.elementAt = elementAt_1.elementAt;

var __extends$68 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$23 = Subscriber_1$3;
/* tslint:disable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter$2(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
var filter_2 = filter$2;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends$68(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1$23.Subscriber);

var filter_1$1 = {
    filter: filter_2
};

var Observable_1$85 = Observable_1$2;
var filter_1 = filter_1$1;
Observable_1$85.Observable.prototype.filter = filter_1.filter;

var __extends$69 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$24 = Subscriber_1$3;
var Subscription_1$14 = Subscription_1$3;
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback function to be called when source terminates.
 * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally$2(callback) {
    return this.lift(new FinallyOperator(callback));
}
var _finally_2 = _finally$2;
var FinallyOperator = function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = function (_super) {
    __extends$69(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1$14.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1$24.Subscriber);

var _finally_1 = {
    _finally: _finally_2
};

var Observable_1$86 = Observable_1$2;
var finally_1 = _finally_1;
Observable_1$86.Observable.prototype.finally = finally_1._finally;
Observable_1$86.Observable.prototype._finally = finally_1._finally;

var __extends$70 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$25 = Subscriber_1$3;
/* tslint:disable:max-line-length */
/**
 * Emits only the first value emitted by the source Observable that meets some
 * condition.
 *
 * <span class="informal">Finds the first value that passes some test and emits
 * that.</span>
 *
 * <img src="./img/find.png" width="100%">
 *
 * `find` searches for the first item in the source Observable that matches the
 * specified condition embodied by the `predicate`, and returns the first
 * occurrence in the source. Unlike {@link first}, the `predicate` is required
 * in `find`, and does not emit an error if a valid value is not found.
 *
 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link first}
 * @see {@link findIndex}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable<T>} An Observable of the first item that matches the
 * condition.
 * @method find
 * @owner Observable
 */
function find$2(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
}
var find_2 = find$2;
var FindValueOperator = function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}();
var FindValueOperator_1 = FindValueOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = function (_super) {
    __extends$70(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this,
            predicate = _a.predicate,
            thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        } catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1$25.Subscriber);
var FindValueSubscriber_1 = FindValueSubscriber;

var find_1$1 = {
    find: find_2,
    FindValueOperator: FindValueOperator_1,
    FindValueSubscriber: FindValueSubscriber_1
};

var Observable_1$87 = Observable_1$2;
var find_1 = find_1$1;
Observable_1$87.Observable.prototype.find = find_1.find;

var find_1$3 = find_1$1;
/**
 * Emits only the index of the first value emitted by the source Observable that
 * meets some condition.
 *
 * <span class="informal">It's like {@link find}, but emits the index of the
 * found value, not the value itself.</span>
 *
 * <img src="./img/findIndex.png" width="100%">
 *
 * `findIndex` searches for the first item in the source Observable that matches
 * the specified condition embodied by the `predicate`, and returns the
 * (zero-based) index of the first occurrence in the source. Unlike
 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
 * an error if a valid value is not found.
 *
 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link first}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */
function findIndex$2(predicate, thisArg) {
  return this.lift(new find_1$3.FindValueOperator(predicate, this, true, thisArg));
}
var findIndex_2 = findIndex$2;

var findIndex_1$1 = {
  findIndex: findIndex_2
};

var Observable_1$88 = Observable_1$2;
var findIndex_1 = findIndex_1$1;
Observable_1$88.Observable.prototype.findIndex = findIndex_1.findIndex;

var __extends$72 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError$1 = function (_super) {
    __extends$72(EmptyError, _super);
    function EmptyError() {
        var err = _super.call(this, 'no elements in sequence');
        this.name = err.name = 'EmptyError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return EmptyError;
}(Error);
var EmptyError_2 = EmptyError$1;

var EmptyError_1$2 = {
    EmptyError: EmptyError_2
};

var __extends$71 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$26 = Subscriber_1$3;
var EmptyError_1$1 = EmptyError_1$2;
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} an Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
function first$2(predicate, resultSelector, defaultValue) {
    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
}
var first_2 = first$2;
var FirstOperator = function () {
    function FirstOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    FirstOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return FirstOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FirstSubscriber = function (_super) {
    __extends$71(FirstSubscriber, _super);
    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.index = 0;
        this.hasCompleted = false;
        this._emitted = false;
    }
    FirstSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        } else {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this._emit(value, index);
        }
    };
    FirstSubscriber.prototype._emit = function (value, index) {
        if (this.resultSelector) {
            this._tryResultSelector(value, index);
            return;
        }
        this._emitFinal(value);
    };
    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this._emitFinal(result);
    };
    FirstSubscriber.prototype._emitFinal = function (value) {
        var destination = this.destination;
        if (!this._emitted) {
            this._emitted = true;
            destination.next(value);
            destination.complete();
            this.hasCompleted = true;
        }
    };
    FirstSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
            destination.next(this.defaultValue);
            destination.complete();
        } else if (!this.hasCompleted) {
            destination.error(new EmptyError_1$1.EmptyError());
        }
    };
    return FirstSubscriber;
}(Subscriber_1$26.Subscriber);

var first_1$1 = {
    first: first_2
};

var Observable_1$89 = Observable_1$2;
var first_1 = first_1$1;
Observable_1$89.Observable.prototype.first = first_1.first;

var MapPolyfill = function () {
    function MapPolyfill() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    MapPolyfill.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    MapPolyfill.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        } else {
            this._values[i] = value;
        }
        return this;
    };
    MapPolyfill.prototype.delete = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    MapPolyfill.prototype.clear = function () {
        this._keys.length = 0;
        this._values.length = 0;
        this.size = 0;
    };
    MapPolyfill.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return MapPolyfill;
}();
var MapPolyfill_2 = MapPolyfill;

var MapPolyfill_1$1 = {
    MapPolyfill: MapPolyfill_2
};

var root_1$13 = root;
var MapPolyfill_1 = MapPolyfill_1$1;
var Map = root_1$13.root.Map || function () {
	return MapPolyfill_1.MapPolyfill;
}();

var _Map = {
	Map: Map
};

var FastMap = function () {
    function FastMap() {
        this.values = {};
    }
    FastMap.prototype.delete = function (key) {
        this.values[key] = null;
        return true;
    };
    FastMap.prototype.set = function (key, value) {
        this.values[key] = value;
        return this;
    };
    FastMap.prototype.get = function (key) {
        return this.values[key];
    };
    FastMap.prototype.forEach = function (cb, thisArg) {
        var values = this.values;
        for (var key in values) {
            if (values.hasOwnProperty(key) && values[key] !== null) {
                cb.call(thisArg, values[key], key);
            }
        }
    };
    FastMap.prototype.clear = function () {
        this.values = {};
    };
    return FastMap;
}();
var FastMap_2 = FastMap;

var FastMap_1$1 = {
    FastMap: FastMap_2
};

var __extends$73 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$27 = Subscriber_1$3;
var Subscription_1$15 = Subscription_1$3;
var Observable_1$91 = Observable_1$2;
var Subject_1$6 = Subject_1$1;
var Map_1 = _Map;
var FastMap_1 = FastMap_1$1;
/* tslint:disable:max-line-length */
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @param {function(value: T): K} keySelector a function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] a function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * a function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} an Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
function groupBy$2(keySelector, elementSelector, durationSelector, subjectSelector) {
    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
}
var groupBy_2 = groupBy$2;
var GroupByOperator = function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = function (_super) {
    __extends$73(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        } catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            } catch (err) {
                this.error(err);
            }
        } else {
            element = value;
        }
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new Subject_1$6.Subject();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                } catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed && !this.attemptedToUnsubscribe) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1$27.Subscriber);
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = function (_super) {
    __extends$73(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        _super.call(this);
        this.key = key;
        this.group = group;
        this.parent = parent;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this._complete();
    };
    GroupDurationSubscriber.prototype._error = function (err) {
        var group = this.group;
        if (!group.closed) {
            group.error(err);
        }
        this.parent.removeGroup(this.key);
    };
    GroupDurationSubscriber.prototype._complete = function () {
        var group = this.group;
        if (!group.closed) {
            group.complete();
        }
        this.parent.removeGroup(this.key);
    };
    return GroupDurationSubscriber;
}(Subscriber_1$27.Subscriber);
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = function (_super) {
    __extends$73(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        _super.call(this);
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1$15.Subscription();
        var _a = this,
            refCountSubscription = _a.refCountSubscription,
            groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1$91.Observable);
var GroupedObservable_1 = GroupedObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = function (_super) {
    __extends$73(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        _super.call(this);
        this.parent = parent;
        parent.count++;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1$15.Subscription);

var groupBy_1$1 = {
    groupBy: groupBy_2,
    GroupedObservable: GroupedObservable_1
};

var Observable_1$90 = Observable_1$2;
var groupBy_1 = groupBy_1$1;
Observable_1$90.Observable.prototype.groupBy = groupBy_1.groupBy;

var __extends$74 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$28 = Subscriber_1$3;
var noop_1$3 = noop_1$1;
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} an empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
function ignoreElements$2() {
    return this.lift(new IgnoreElementsOperator());
}
var ignoreElements_2 = ignoreElements$2;

var IgnoreElementsOperator = function () {
    function IgnoreElementsOperator() {}
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = function (_super) {
    __extends$74(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        _super.apply(this, arguments);
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        noop_1$3.noop();
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1$28.Subscriber);

var ignoreElements_1$1 = {
    ignoreElements: ignoreElements_2
};

var Observable_1$92 = Observable_1$2;
var ignoreElements_1 = ignoreElements_1$1;
Observable_1$92.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;

var __extends$75 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$29 = Subscriber_1$3;
/**
 * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
 *
 * <img src="./img/isEmpty.png" width="100%">
 *
 * @return {Observable} an Observable that emits a Boolean.
 * @method isEmpty
 * @owner Observable
 */
function isEmpty$2() {
    return this.lift(new IsEmptyOperator());
}
var isEmpty_2 = isEmpty$2;
var IsEmptyOperator = function () {
    function IsEmptyOperator() {}
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = function (_super) {
    __extends$75(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        _super.call(this, destination);
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1$29.Subscriber);

var isEmpty_1$1 = {
    isEmpty: isEmpty_2
};

var Observable_1$93 = Observable_1$2;
var isEmpty_1 = isEmpty_1$1;
Observable_1$93.Observable.prototype.isEmpty = isEmpty_1.isEmpty;

var __extends$76 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1$11 = tryCatch_1$1;
var errorObject_1$11 = errorObject;
var OuterSubscriber_1$23 = OuterSubscriber_1$1;
var subscribeToResult_1$23 = subscribeToResult_1$1;
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): Observable|Promise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */
function audit$2(durationSelector) {
    return this.lift(new AuditOperator(durationSelector));
}
var audit_2 = audit$2;
var AuditOperator = function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = function (_super) {
    __extends$76(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch_1$11.tryCatch(this.durationSelector)(value);
            if (duration === errorObject_1$11.errorObject) {
                this.destination.error(errorObject_1$11.errorObject.e);
            } else {
                this.add(this.throttled = subscribeToResult_1$23.subscribeToResult(this, duration));
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this,
            value = _a.value,
            hasValue = _a.hasValue,
            throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1$23.OuterSubscriber);

var audit_1$1 = {
    audit: audit_2
};

var Observable_1$94 = Observable_1$2;
var audit_1 = audit_1$1;
Observable_1$94.Observable.prototype.audit = audit_1.audit;

var __extends$77 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1$7 = async;
var Subscriber_1$30 = Subscriber_1$3;
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link Scheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */
function auditTime$2(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$7.async;
    }
    return this.lift(new AuditTimeOperator(duration, scheduler));
}
var auditTime_2 = auditTime$2;
var AuditTimeOperator = function () {
    function AuditTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    AuditTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return AuditTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditTimeSubscriber = function (_super) {
    __extends$77(AuditTimeSubscriber, _super);
    function AuditTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.hasValue = false;
    }
    AuditTimeSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$4, this.duration, this));
        }
    };
    AuditTimeSubscriber.prototype.clearThrottle = function () {
        var _a = this,
            value = _a.value,
            hasValue = _a.hasValue,
            throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    return AuditTimeSubscriber;
}(Subscriber_1$30.Subscriber);
function dispatchNext$4(subscriber) {
    subscriber.clearThrottle();
}

var auditTime_1$1 = {
    auditTime: auditTime_2
};

var Observable_1$95 = Observable_1$2;
var auditTime_1 = auditTime_1$1;
Observable_1$95.Observable.prototype.auditTime = auditTime_1.auditTime;

var __extends$78 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$31 = Subscriber_1$3;
var EmptyError_1$4 = EmptyError_1$2;
/* tslint:disable:max-line-length */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - the condition any source emitted item has to satisfy.
 * @return {Observable} an Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
function last$2(predicate, resultSelector, defaultValue) {
    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
}
var last_2 = last$2;
var LastOperator = function () {
    function LastOperator(predicate, resultSelector, defaultValue, source) {
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
    }
    LastOperator.prototype.call = function (observer, source) {
        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
    };
    return LastOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var LastSubscriber = function (_super) {
    __extends$78(LastSubscriber, _super);
    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.resultSelector = resultSelector;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
    }
    LastSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this._tryPredicate(value, index);
        } else {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryPredicate = function (value, index) {
        var result;
        try {
            result = this.predicate(value, index, this.source);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this.lastValue = value;
            this.hasValue = true;
        }
    };
    LastSubscriber.prototype._tryResultSelector = function (value, index) {
        var result;
        try {
            result = this.resultSelector(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.lastValue = result;
        this.hasValue = true;
    };
    LastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        } else {
            destination.error(new EmptyError_1$4.EmptyError());
        }
    };
    return LastSubscriber;
}(Subscriber_1$31.Subscriber);

var last_1$1 = {
    last: last_2
};

var Observable_1$96 = Observable_1$2;
var last_1 = last_1$1;
Observable_1$96.Observable.prototype.last = last_1.last;

/**
 * @param func
 * @return {Observable<R>}
 * @method let
 * @owner Observable
 */

function letProto(func) {
  return func(this);
}
var letProto_1 = letProto;

var _let$2 = {
  letProto: letProto_1
};

var Observable_1$97 = Observable_1$2;
var let_1 = _let$2;
Observable_1$97.Observable.prototype.let = let_1.letProto;
Observable_1$97.Observable.prototype.letBind = let_1.letProto;

var __extends$79 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$32 = Subscriber_1$3;
/**
 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
 * @param {function} predicate a function for determining if an item meets a specified condition.
 * @param {any} [thisArg] optional object to use for `this` in the callback
 * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.
 * @method every
 * @owner Observable
 */
function every$2(predicate, thisArg) {
    return this.lift(new EveryOperator(predicate, thisArg, this));
}
var every_2 = every$2;
var EveryOperator = function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var EverySubscriber = function (_super) {
    __extends$79(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
        this.index = 0;
        this.thisArg = thisArg || this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1$32.Subscriber);

var every_1$1 = {
    every: every_2
};

var Observable_1$98 = Observable_1$2;
var every_1 = every_1$1;
Observable_1$98.Observable.prototype.every = every_1.every;

var Observable_1$99 = Observable_1$2;
var map_1$3 = map_1$1;
Observable_1$99.Observable.prototype.map = map_1$3.map;

var __extends$80 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$33 = Subscriber_1$3;
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
function mapTo$2(value) {
    return this.lift(new MapToOperator(value));
}
var mapTo_2 = mapTo$2;
var MapToOperator = function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = function (_super) {
    __extends$80(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        _super.call(this, destination);
        this.value = value;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1$33.Subscriber);

var mapTo_1$1 = {
    mapTo: mapTo_2
};

var Observable_1$100 = Observable_1$2;
var mapTo_1 = mapTo_1$1;
Observable_1$100.Observable.prototype.mapTo = mapTo_1.mapTo;

var __extends$81 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$34 = Subscriber_1$3;
var Notification_1$5 = Notification_1$2;
/**
 * Represents all of the notifications from the source Observable as `next`
 * emissions marked with their original types within {@link Notification}
 * objects.
 *
 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
 * {@link Notification} objects, emitted as `next` on the output Observable.
 * </span>
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * `materialize` returns an Observable that emits a `next` notification for each
 * `next`, `error`, or `complete` emission of the source Observable. When the
 * source Observable emits `complete`, the output Observable will emit `next` as
 * a Notification of type "complete", and then it will emit `complete` as well.
 * When the source Observable emits `error`, the output will emit `next` as a
 * Notification of type "error", and then `complete`.
 *
 * This operator is useful for producing metadata of the source Observable, to
 * be consumed as `next` emissions. Use it in conjunction with
 * {@link dematerialize}.
 *
 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
 * var upperCase = letters.map(x => x.toUpperCase());
 * var materialized = upperCase.materialize();
 * materialized.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
 * // - Notification {kind: "E", value: undefined, error: TypeError:
 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
 * //   [as project] (http://1…, hasValue: false}
 *
 * @see {@link Notification}
 * @see {@link dematerialize}
 *
 * @return {Observable<Notification<T>>} An Observable that emits
 * {@link Notification} objects that wrap the original emissions from the source
 * Observable with metadata.
 * @method materialize
 * @owner Observable
 */
function materialize$2() {
    return this.lift(new MaterializeOperator());
}
var materialize_2 = materialize$2;
var MaterializeOperator = function () {
    function MaterializeOperator() {}
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = function (_super) {
    __extends$81(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        _super.call(this, destination);
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1$5.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1$5.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1$5.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1$34.Subscriber);

var materialize_1$1 = {
    materialize: materialize_2
};

var Observable_1$101 = Observable_1$2;
var materialize_1 = materialize_1$1;
Observable_1$101.Observable.prototype.materialize = materialize_1.materialize;

var __extends$82 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$35 = Subscriber_1$3;
/* tslint:disable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
function reduce(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
}
var reduce_2 = reduce;
var ReduceOperator = function () {
    function ReduceOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ReduceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ReduceOperator;
}();
var ReduceOperator_1 = ReduceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ReduceSubscriber = function (_super) {
    __extends$82(ReduceSubscriber, _super);
    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this.hasSeed = hasSeed;
        this.hasValue = false;
        this.acc = seed;
    }
    ReduceSubscriber.prototype._next = function (value) {
        if (this.hasValue || (this.hasValue = this.hasSeed)) {
            this._tryReduce(value);
        } else {
            this.acc = value;
            this.hasValue = true;
        }
    };
    ReduceSubscriber.prototype._tryReduce = function (value) {
        var result;
        try {
            result = this.accumulator(this.acc, value);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.acc = result;
    };
    ReduceSubscriber.prototype._complete = function () {
        if (this.hasValue || this.hasSeed) {
            this.destination.next(this.acc);
        }
        this.destination.complete();
    };
    return ReduceSubscriber;
}(Subscriber_1$35.Subscriber);
var ReduceSubscriber_1 = ReduceSubscriber;

var reduce_1$1 = {
    reduce: reduce_2,
    ReduceOperator: ReduceOperator_1,
    ReduceSubscriber: ReduceSubscriber_1
};

var reduce_1 = reduce_1$1;
/**
 * The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),
 * and when source Observable completes it emits a single item: the item with the largest number.
 *
 * <img src="./img/max.png" width="100%">
 *
 * @param {Function} optional comparer function that it will use instead of its default to compare the value of two
 * items.
 * @return {Observable} an Observable that emits item with the largest number.
 * @method max
 * @owner Observable
 */
function max$2(comparer) {
  var max = typeof comparer === 'function' ? function (x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function (x, y) {
    return x > y ? x : y;
  };
  return this.lift(new reduce_1.ReduceOperator(max));
}
var max_2 = max$2;

var max_1$1 = {
  max: max_2
};

var Observable_1$102 = Observable_1$2;
var max_1 = max_1$1;
Observable_1$102.Observable.prototype.max = max_1.max;

var Observable_1$103 = Observable_1$2;
var merge_1$4 = merge_1$2;
Observable_1$103.Observable.prototype.merge = merge_1$4.merge;

var Observable_1$104 = Observable_1$2;
var mergeAll_1$5 = mergeAll_1$1;
Observable_1$104.Observable.prototype.mergeAll = mergeAll_1$5.mergeAll;

var Observable_1$105 = Observable_1$2;
var mergeMap_1$3 = mergeMap_1$1;
Observable_1$105.Observable.prototype.mergeMap = mergeMap_1$3.mergeMap;
Observable_1$105.Observable.prototype.flatMap = mergeMap_1$3.mergeMap;

var Observable_1$106 = Observable_1$2;
var mergeMapTo_1$3 = mergeMapTo_1$1;
Observable_1$106.Observable.prototype.flatMapTo = mergeMapTo_1$3.mergeMapTo;
Observable_1$106.Observable.prototype.mergeMapTo = mergeMapTo_1$3.mergeMapTo;

var __extends$83 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var tryCatch_1$12 = tryCatch_1$1;
var errorObject_1$12 = errorObject;
var subscribeToResult_1$24 = subscribeToResult_1$1;
var OuterSubscriber_1$24 = OuterSubscriber_1$1;
/**
 * @param project
 * @param seed
 * @param concurrent
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method mergeScan
 * @owner Observable
 */
function mergeScan$2(project, seed, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeScanOperator(project, seed, concurrent));
}
var mergeScan_2 = mergeScan$2;
var MergeScanOperator = function () {
    function MergeScanOperator(project, seed, concurrent) {
        this.project = project;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.project, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}();
var MergeScanOperator_1 = MergeScanOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = function (_super) {
    __extends$83(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, project, acc, concurrent) {
        _super.call(this, destination);
        this.project = project;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch_1$12.tryCatch(this.project)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject_1$12.errorObject) {
                destination.error(errorObject_1$12.errorObject.e);
            } else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        } else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1$24.subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1$24.OuterSubscriber);
var MergeScanSubscriber_1 = MergeScanSubscriber;

var mergeScan_1$1 = {
    mergeScan: mergeScan_2,
    MergeScanOperator: MergeScanOperator_1,
    MergeScanSubscriber: MergeScanSubscriber_1
};

var Observable_1$107 = Observable_1$2;
var mergeScan_1 = mergeScan_1$1;
Observable_1$107.Observable.prototype.mergeScan = mergeScan_1.mergeScan;

var reduce_1$3 = reduce_1$1;
/**
 * The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),
 * and when source Observable completes it emits a single item: the item with the smallest number.
 *
 * <img src="./img/min.png" width="100%">
 *
 * @param {Function} optional comparer function that it will use instead of its default to compare the value of two items.
 * @return {Observable<R>} an Observable that emits item with the smallest number.
 * @method min
 * @owner Observable
 */
function min$2(comparer) {
  var min = typeof comparer === 'function' ? function (x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function (x, y) {
    return x < y ? x : y;
  };
  return this.lift(new reduce_1$3.ReduceOperator(min));
}
var min_2 = min$2;

var min_1$1 = {
  min: min_2
};

var Observable_1$108 = Observable_1$2;
var min_1 = min_1$1;
Observable_1$108.Observable.prototype.min = min_1.min;

var __extends$84 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$7 = Subject_1$1;
var Observable_1$110 = Observable_1$2;
var Subscriber_1$36 = Subscriber_1$3;
var Subscription_1$16 = Subscription_1$3;
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable$1 = function (_super) {
    __extends$84(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1$16.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1$16.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1$110.Observable);
var ConnectableObservable_2 = ConnectableObservable$1;
var connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subscribe: { value: ConnectableObservable$1.prototype._subscribe },
    getSubject: { value: ConnectableObservable$1.prototype.getSubject },
    connect: { value: ConnectableObservable$1.prototype.connect },
    refCount: { value: ConnectableObservable$1.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends$84(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1$7.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends$84(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1$36.Subscriber);

var ConnectableObservable_1$2 = {
    ConnectableObservable: ConnectableObservable_2,
    connectableObservableDescriptor: connectableObservableDescriptor
};

var ConnectableObservable_1$1 = ConnectableObservable_1$2;
/* tslint:disable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} an Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast$2(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    } else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1$1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
var multicast_2 = multicast$2;
var MulticastOperator = function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}();
var MulticastOperator_1 = MulticastOperator;

var multicast_1$1 = {
    multicast: multicast_2,
    MulticastOperator: MulticastOperator_1
};

var Observable_1$109 = Observable_1$2;
var multicast_1 = multicast_1$1;
Observable_1$109.Observable.prototype.multicast = multicast_1.multicast;

var Observable_1$111 = Observable_1$2;
var observeOn_1$4 = observeOn_1$1;
Observable_1$111.Observable.prototype.observeOn = observeOn_1$4.observeOn;

var Observable_1$112 = Observable_1$2;
var onErrorResumeNext_1$3 = onErrorResumeNext_1$1;
Observable_1$112.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1$3.onErrorResumeNext;

var __extends$85 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$37 = Subscriber_1$3;
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise$2() {
    return this.lift(new PairwiseOperator());
}
var pairwise_2 = pairwise$2;
var PairwiseOperator = function () {
    function PairwiseOperator() {}
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = function (_super) {
    __extends$85(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        } else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1$37.Subscriber);

var pairwise_1$1 = {
    pairwise: pairwise_2
};

var Observable_1$113 = Observable_1$2;
var pairwise_1 = pairwise_1$1;
Observable_1$113.Observable.prototype.pairwise = pairwise_1.pairwise;

function not(pred, thisArg) {
    function notPred() {
        return !notPred.pred.apply(notPred.thisArg, arguments);
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
var not_2 = not;

var not_1$1 = {
    not: not_2
};

var not_1 = not_1$1;
var filter_1$3 = filter_1$1;
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
function partition$2(predicate, thisArg) {
  return [filter_1$3.filter.call(this, predicate, thisArg), filter_1$3.filter.call(this, not_1.not(predicate, thisArg))];
}
var partition_2 = partition$2;

var partition_1$1 = {
  partition: partition_2
};

var Observable_1$114 = Observable_1$2;
var partition_1 = partition_1$1;
Observable_1$114.Observable.prototype.partition = partition_1.partition;

var map_1$4 = map_1$1;
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} Returns a new Observable of property values from the
 * source values.
 * @method pluck
 * @owner Observable
 */
function pluck$2() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return map_1$4.map.call(this, plucker(properties, length));
}
var pluck_2 = pluck$2;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            } else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

var pluck_1$1 = {
    pluck: pluck_2
};

var Observable_1$115 = Observable_1$2;
var pluck_1 = pluck_1$1;
Observable_1$115.Observable.prototype.pluck = pluck_1.pluck;

var Subject_1$8 = Subject_1$1;
var multicast_1$3 = multicast_1$1;
/* tslint:disable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} Optional selector function which can use the multicasted source sequence as many times as needed,
 * without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return a ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
function publish$2(selector) {
  return selector ? multicast_1$3.multicast.call(this, function () {
    return new Subject_1$8.Subject();
  }, selector) : multicast_1$3.multicast.call(this, new Subject_1$8.Subject());
}
var publish_2 = publish$2;

var publish_1$1 = {
  publish: publish_2
};

var Observable_1$116 = Observable_1$2;
var publish_1 = publish_1$1;
Observable_1$116.Observable.prototype.publish = publish_1.publish;

var __extends$86 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$9 = Subject_1$1;
var ObjectUnsubscribedError_1$5 = ObjectUnsubscribedError_1$2;
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject$1 = function (_super) {
    __extends$86(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        _super.call(this);
        this._value = _value;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        } else if (this.closed) {
            throw new ObjectUnsubscribedError_1$5.ObjectUnsubscribedError();
        } else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1$9.Subject);
var BehaviorSubject_2 = BehaviorSubject$1;

var BehaviorSubject_1$2 = {
    BehaviorSubject: BehaviorSubject_2
};

var BehaviorSubject_1$1 = BehaviorSubject_1$2;
var multicast_1$4 = multicast_1$1;
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */
function publishBehavior$2(value) {
  return multicast_1$4.multicast.call(this, new BehaviorSubject_1$1.BehaviorSubject(value));
}
var publishBehavior_2 = publishBehavior$2;

var publishBehavior_1$1 = {
  publishBehavior: publishBehavior_2
};

var Observable_1$117 = Observable_1$2;
var publishBehavior_1 = publishBehavior_1$1;
Observable_1$117.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;

var ReplaySubject_1$4 = ReplaySubject_1$2;
var multicast_1$5 = multicast_1$1;
/**
 * @param bufferSize
 * @param windowTime
 * @param scheduler
 * @return {ConnectableObservable<T>}
 * @method publishReplay
 * @owner Observable
 */
function publishReplay$2(bufferSize, windowTime, scheduler) {
  if (bufferSize === void 0) {
    bufferSize = Number.POSITIVE_INFINITY;
  }
  if (windowTime === void 0) {
    windowTime = Number.POSITIVE_INFINITY;
  }
  return multicast_1$5.multicast.call(this, new ReplaySubject_1$4.ReplaySubject(bufferSize, windowTime, scheduler));
}
var publishReplay_2 = publishReplay$2;

var publishReplay_1$1 = {
  publishReplay: publishReplay_2
};

var Observable_1$118 = Observable_1$2;
var publishReplay_1 = publishReplay_1$1;
Observable_1$118.Observable.prototype.publishReplay = publishReplay_1.publishReplay;

var AsyncSubject_1$5 = AsyncSubject_1$2;
var multicast_1$6 = multicast_1$1;
/**
 * @return {ConnectableObservable<T>}
 * @method publishLast
 * @owner Observable
 */
function publishLast$2() {
  return multicast_1$6.multicast.call(this, new AsyncSubject_1$5.AsyncSubject());
}
var publishLast_2 = publishLast$2;

var publishLast_1$1 = {
  publishLast: publishLast_2
};

var Observable_1$119 = Observable_1$2;
var publishLast_1 = publishLast_1$1;
Observable_1$119.Observable.prototype.publishLast = publishLast_1.publishLast;

var Observable_1$120 = Observable_1$2;
var race_1$3 = race_1$1;
Observable_1$120.Observable.prototype.race = race_1$3.race;

var Observable_1$121 = Observable_1$2;
var reduce_1$4 = reduce_1$1;
Observable_1$121.Observable.prototype.reduce = reduce_1$4.reduce;

var __extends$87 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$38 = Subscriber_1$3;
var EmptyObservable_1$6 = EmptyObservable_1$1;
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times,
 * on a particular Scheduler.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {Scheduler} [scheduler] the Scheduler to emit the items on.
 * @param {number} [count] the number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} an Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */
function repeat$2(count) {
    if (count === void 0) {
        count = -1;
    }
    if (count === 0) {
        return new EmptyObservable_1$6.EmptyObservable();
    } else if (count < 0) {
        return this.lift(new RepeatOperator(-1, this));
    } else {
        return this.lift(new RepeatOperator(count - 1, this));
    }
}
var repeat_2 = repeat$2;
var RepeatOperator = function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = function (_super) {
    __extends$87(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this,
                source = _a.source,
                count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            } else if (count > -1) {
                this.count = count - 1;
            }
            this.unsubscribe();
            this.isStopped = false;
            this.closed = false;
            source.subscribe(this);
        }
    };
    return RepeatSubscriber;
}(Subscriber_1$38.Subscriber);

var repeat_1$1 = {
    repeat: repeat_2
};

var Observable_1$122 = Observable_1$2;
var repeat_1 = repeat_1$1;
Observable_1$122.Observable.prototype.repeat = repeat_1.repeat;

var __extends$88 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$10 = Subject_1$1;
var tryCatch_1$13 = tryCatch_1$1;
var errorObject_1$13 = errorObject;
var OuterSubscriber_1$25 = OuterSubscriber_1$1;
var subscribeToResult_1$25 = subscribeToResult_1$1;
/**
 * Returns an Observable that emits the same values as the source observable with the exception of a `complete`.
 * A `complete` will cause the emission of the Throwable that cause the complete to the Observable returned from
 * notificationHandler. If that Observable calls onComplete or `complete` then retry will call `complete` or `error`
 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
 * Scheduler.
 *
 * <img src="./img/repeatWhen.png" width="100%">
 *
 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
 * aborting the retry.
 * @param {scheduler} the Scheduler on which to subscribe to the source Observable.
 * @return {Observable} the source Observable modified with retry logic.
 * @method repeatWhen
 * @owner Observable
 */
function repeatWhen$2(notifier) {
    return this.lift(new RepeatWhenOperator(notifier, this));
}
var repeatWhen_2 = repeatWhen$2;
var RepeatWhenOperator = function () {
    function RepeatWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RepeatWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = function (_super) {
    __extends$88(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RepeatWhenSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var notifications = this.notifications;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                notifications = new Subject_1$10.Subject();
                retries = tryCatch_1$13.tryCatch(this.notifier)(notifications);
                if (retries === errorObject_1$13.errorObject) {
                    return _super.prototype.complete.call(this);
                }
                retriesSubscription = subscribeToResult_1$25.subscribeToResult(this, retries);
            } else {
                this.notifications = null;
                this.retriesSubscription = null;
            }
            this.unsubscribe();
            this.closed = false;
            this.notifications = notifications;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this,
            notifications = _a.notifications,
            retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            notifications = _a.notifications,
            retries = _a.retries,
            retriesSubscription = _a.retriesSubscription;
        this.notifications = null;
        this.retries = null;
        this.retriesSubscription = null;
        this.unsubscribe();
        this.isStopped = false;
        this.closed = false;
        this.notifications = notifications;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1$25.OuterSubscriber);

var repeatWhen_1$1 = {
    repeatWhen: repeatWhen_2
};

var Observable_1$123 = Observable_1$2;
var repeatWhen_1 = repeatWhen_1$1;
Observable_1$123.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;

var __extends$89 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$39 = Subscriber_1$3;
/**
 * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls `error` and the
 * predicate returns true for that specific exception and retry count.
 * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of
 * count resubscriptions (given as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} number of retry attempts before failing.
 * @return {Observable} the source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
function retry$2(count) {
    if (count === void 0) {
        count = -1;
    }
    return this.lift(new RetryOperator(count, this));
}
var retry_2 = retry$2;
var RetryOperator = function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = function (_super) {
    __extends$89(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        _super.call(this, destination);
        this.count = count;
        this.source = source;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this,
                source = _a.source,
                count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            } else if (count > -1) {
                this.count = count - 1;
            }
            this.unsubscribe();
            this.isStopped = false;
            this.closed = false;
            source.subscribe(this);
        }
    };
    return RetrySubscriber;
}(Subscriber_1$39.Subscriber);

var retry_1$1 = {
    retry: retry_2
};

var Observable_1$124 = Observable_1$2;
var retry_1 = retry_1$1;
Observable_1$124.Observable.prototype.retry = retry_1.retry;

var __extends$90 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$11 = Subject_1$1;
var tryCatch_1$14 = tryCatch_1$1;
var errorObject_1$14 = errorObject;
var OuterSubscriber_1$26 = OuterSubscriber_1$1;
var subscribeToResult_1$26 = subscribeToResult_1$1;
/**
 * Returns an Observable that emits the same values as the source observable with the exception of an `error`.
 * An `error` will cause the emission of the Throwable that cause the error to the Observable returned from
 * notificationHandler. If that Observable calls onComplete or `error` then retry will call `complete` or `error`
 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
 * Scheduler.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
 * aborting the retry.
 * @param {scheduler} the Scheduler on which to subscribe to the source Observable.
 * @return {Observable} the source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen$2(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}
var retryWhen_2 = retryWhen$2;
var RetryWhenOperator = function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = function (_super) {
    __extends$90(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1$11.Subject();
                retries = tryCatch_1$14.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1$14.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1$14.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1$26.subscribeToResult(this, retries);
            } else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this.unsubscribe();
            this.closed = false;
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this,
            errors = _a.errors,
            retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            errors = _a.errors,
            retries = _a.retries,
            retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this.unsubscribe();
        this.isStopped = false;
        this.closed = false;
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1$26.OuterSubscriber);

var retryWhen_1$1 = {
    retryWhen: retryWhen_2
};

var Observable_1$125 = Observable_1$2;
var retryWhen_1 = retryWhen_1$1;
Observable_1$125.Observable.prototype.retryWhen = retryWhen_1.retryWhen;

var __extends$91 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$27 = OuterSubscriber_1$1;
var subscribeToResult_1$27 = subscribeToResult_1$1;
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */
function sample$2(notifier) {
    return this.lift(new SampleOperator(notifier));
}
var sample_2 = sample$2;
var SampleOperator = function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult_1$27.subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = function (_super) {
    __extends$91(SampleSubscriber, _super);
    function SampleSubscriber() {
        _super.apply(this, arguments);
        this.hasValue = false;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1$27.OuterSubscriber);

var sample_1$1 = {
    sample: sample_2
};

var Observable_1$126 = Observable_1$2;
var sample_1 = sample_1$1;
Observable_1$126.Observable.prototype.sample = sample_1.sample;

var __extends$92 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$40 = Subscriber_1$3;
var async_1$8 = async;
/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * <img src="./img/sampleTime.png" width="100%">
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * @example <caption>Every second, emit the most recent click at most once</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.sampleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {number} period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */
function sampleTime$2(period, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$8.async;
    }
    return this.lift(new SampleTimeOperator(period, scheduler));
}
var sampleTime_2 = sampleTime$2;
var SampleTimeOperator = function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = function (_super) {
    __extends$92(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        _super.call(this, destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1$40.Subscriber);
function dispatchNotification(state) {
    var subscriber = state.subscriber,
        period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

var sampleTime_1$1 = {
    sampleTime: sampleTime_2
};

var Observable_1$127 = Observable_1$2;
var sampleTime_1 = sampleTime_1$1;
Observable_1$127.Observable.prototype.sampleTime = sampleTime_1.sampleTime;

var __extends$93 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$41 = Subscriber_1$3;
/* tslint:disable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
function scan$2(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
}
var scan_2 = scan$2;
var ScanOperator = function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = function (_super) {
    __extends$93(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        _super.call(this, destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        } else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        } catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1$41.Subscriber);

var scan_1$1 = {
    scan: scan_2
};

var Observable_1$128 = Observable_1$2;
var scan_1 = scan_1$1;
Observable_1$128.Observable.prototype.scan = scan_1.scan;

var __extends$94 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$42 = Subscriber_1$3;
var tryCatch_1$15 = tryCatch_1$1;
var errorObject_1$15 = errorObject;
/**
 * Compares all values of two observables in sequence using an optional comparor function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * <img src="./img/sequenceEqual.png" width="100%">
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * @example <caption>figure out if the Konami code matches</caption>
 * var code = Rx.Observable.from([
 *  "ArrowUp",
 *  "ArrowUp",
 *  "ArrowDown",
 *  "ArrowDown",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "KeyB",
 *  "KeyA",
 *  "Enter" // no start key, clearly.
 * ]);
 *
 * var keys = Rx.Observable.fromEvent(document, 'keyup')
 *  .map(e => e.code);
 * var matches = keys.bufferCount(11, 1)
 *  .mergeMap(
 *    last11 =>
 *      Rx.Observable.from(last11)
 *        .sequenceEqual(code)
 *   );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} compareTo the observable sequence to compare the source sequence to.
 * @param {function} [comparor] An optional function to compare each value pair
 * @return {Observable} An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence
 * @method sequenceEqual
 * @owner Observable
 */
function sequenceEqual$2(compareTo, comparor) {
    return this.lift(new SequenceEqualOperator(compareTo, comparor));
}
var sequenceEqual_2 = sequenceEqual$2;
var SequenceEqualOperator = function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}();
var SequenceEqualOperator_1 = SequenceEqualOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = function (_super) {
    __extends$94(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        _super.call(this, destination);
        this.compareTo = compareTo;
        this.comparor = comparor;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        } else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this,
            _a = _c._a,
            _b = _c._b,
            comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch_1$15.tryCatch(comparor)(a, b);
                if (areEqual === errorObject_1$15.errorObject) {
                    this.destination.error(errorObject_1$15.errorObject.e);
                }
            } else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        } else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1$42.Subscriber);
var SequenceEqualSubscriber_1 = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = function (_super) {
    __extends$94(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        _super.call(this, destination);
        this.parent = parent;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1$42.Subscriber);

var sequenceEqual_1$1 = {
    sequenceEqual: sequenceEqual_2,
    SequenceEqualOperator: SequenceEqualOperator_1,
    SequenceEqualSubscriber: SequenceEqualSubscriber_1
};

var Observable_1$129 = Observable_1$2;
var sequenceEqual_1 = sequenceEqual_1$1;
Observable_1$129.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;

var multicast_1$7 = multicast_1$1;
var Subject_1$12 = Subject_1$1;
function shareSubjectFactory() {
  return new Subject_1$12.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers
 * @method share
 * @owner Observable
 */
function share$2() {
  return multicast_1$7.multicast.call(this, shareSubjectFactory).refCount();
}
var share_2 = share$2;


var share_1$1 = {
  share: share_2
};

var Observable_1$130 = Observable_1$2;
var share_1 = share_1$1;
Observable_1$130.Observable.prototype.share = share_1.share;

var __extends$95 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$43 = Subscriber_1$3;
var EmptyError_1$5 = EmptyError_1$2;
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} a predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
function single$2(predicate) {
    return this.lift(new SingleOperator(predicate, this));
}
var single_2 = single$2;
var SingleOperator = function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = function (_super) {
    __extends$95(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        } else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var predicate = this.predicate;
        this.index++;
        if (predicate) {
            this.tryNext(value);
        } else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value) {
        try {
            var result = this.predicate(value, this.index, this.source);
            if (result) {
                this.applySingleValue(value);
            }
        } catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        } else {
            destination.error(new EmptyError_1$5.EmptyError());
        }
    };
    return SingleSubscriber;
}(Subscriber_1$43.Subscriber);

var single_1$1 = {
    single: single_2
};

var Observable_1$131 = Observable_1$2;
var single_1 = single_1$1;
Observable_1$131.Observable.prototype.single = single_1.single;

var __extends$96 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$44 = Subscriber_1$3;
/**
 * Returns an Observable that skips `n` items emitted by an Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
 * @return {Observable} an Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
function skip$2(total) {
    return this.lift(new SkipOperator(total));
}
var skip_2 = skip$2;
var SkipOperator = function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = function (_super) {
    __extends$96(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1$44.Subscriber);

var skip_1$1 = {
    skip: skip_2
};

var Observable_1$132 = Observable_1$2;
var skip_1 = skip_1$1;
Observable_1$132.Observable.prototype.skip = skip_1.skip;

var __extends$97 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$28 = OuterSubscriber_1$1;
var subscribeToResult_1$28 = subscribeToResult_1$1;
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} the second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} an Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
function skipUntil$2(notifier) {
    return this.lift(new SkipUntilOperator(notifier));
}
var skipUntil_2 = skipUntil$2;
var SkipUntilOperator = function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
    };
    return SkipUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = function (_super) {
    __extends$97(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.hasValue = false;
        this.isInnerStopped = false;
        this.add(subscribeToResult_1$28.subscribeToResult(this, notifier));
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype._complete = function () {
        if (this.isInnerStopped) {
            _super.prototype._complete.call(this);
        } else {
            this.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        this.isInnerStopped = true;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1$28.OuterSubscriber);

var skipUntil_1$1 = {
    skipUntil: skipUntil_2
};

var Observable_1$133 = Observable_1$2;
var skipUntil_1 = skipUntil_1$1;
Observable_1$133.Observable.prototype.skipUntil = skipUntil_1.skipUntil;

var __extends$98 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$45 = Subscriber_1$3;
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - a function to test each item emitted from the source Observable.
 * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
function skipWhile$2(predicate) {
    return this.lift(new SkipWhileOperator(predicate));
}
var skipWhile_2 = skipWhile$2;
var SkipWhileOperator = function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = function (_super) {
    __extends$98(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        } catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1$45.Subscriber);

var skipWhile_1$1 = {
    skipWhile: skipWhile_2
};

var Observable_1$134 = Observable_1$2;
var skipWhile_1 = skipWhile_1$1;
Observable_1$134.Observable.prototype.skipWhile = skipWhile_1.skipWhile;

var ArrayObservable_1$10 = ArrayObservable_1$1;
var ScalarObservable_1$4 = ScalarObservable_1$1;
var EmptyObservable_1$7 = EmptyObservable_1$1;
var concat_1$5 = concat_1$2;
var isScheduler_1$9 = isScheduler_1$1;
/* tslint:disable:max-line-length */
/**
 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
 * source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith$2() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1$9.isScheduler(scheduler)) {
        array.pop();
    } else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1$5.concatStatic(new ScalarObservable_1$4.ScalarObservable(array[0], scheduler), this);
    } else if (len > 1) {
        return concat_1$5.concatStatic(new ArrayObservable_1$10.ArrayObservable(array, scheduler), this);
    } else {
        return concat_1$5.concatStatic(new EmptyObservable_1$7.EmptyObservable(scheduler), this);
    }
}
var startWith_2 = startWith$2;

var startWith_1$1 = {
    startWith: startWith_2
};

var Observable_1$135 = Observable_1$2;
var startWith_1 = startWith_1$1;
Observable_1$135.Observable.prototype.startWith = startWith_1.startWith;

var root_1$14 = root;
var ImmediateDefinition = function () {
    function ImmediateDefinition(root$$1) {
        this.root = root$$1;
        if (root$$1.setImmediate && typeof root$$1.setImmediate === 'function') {
            this.setImmediate = root$$1.setImmediate.bind(root$$1);
            this.clearImmediate = root$$1.clearImmediate.bind(root$$1);
        } else {
            this.nextHandle = 1;
            this.tasksByHandle = {};
            this.currentlyRunningATask = false;
            // Don't get fooled by e.g. browserify environments.
            if (this.canUseProcessNextTick()) {
                // For Node.js before 0.9
                this.setImmediate = this.createProcessNextTickSetImmediate();
            } else if (this.canUsePostMessage()) {
                // For non-IE10 modern browsers
                this.setImmediate = this.createPostMessageSetImmediate();
            } else if (this.canUseMessageChannel()) {
                // For web workers, where supported
                this.setImmediate = this.createMessageChannelSetImmediate();
            } else if (this.canUseReadyStateChange()) {
                // For IE 6–8
                this.setImmediate = this.createReadyStateChangeSetImmediate();
            } else {
                // For older browsers
                this.setImmediate = this.createSetTimeoutSetImmediate();
            }
            var ci = function clearImmediate(handle) {
                delete clearImmediate.instance.tasksByHandle[handle];
            };
            ci.instance = this;
            this.clearImmediate = ci;
        }
    }
    ImmediateDefinition.prototype.identify = function (o) {
        return this.root.Object.prototype.toString.call(o);
    };
    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
        return this.identify(this.root.process) === '[object process]';
    };
    ImmediateDefinition.prototype.canUseMessageChannel = function () {
        return Boolean(this.root.MessageChannel);
    };
    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
        var document = this.root.document;
        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
    };
    ImmediateDefinition.prototype.canUsePostMessage = function () {
        var root$$1 = this.root;
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `root.postMessage` means something completely different and can't be used for this purpose.
        if (root$$1.postMessage && !root$$1.importScripts) {
            var postMessageIsAsynchronous_1 = true;
            var oldOnMessage = root$$1.onmessage;
            root$$1.onmessage = function () {
                postMessageIsAsynchronous_1 = false;
            };
            root$$1.postMessage('', '*');
            root$$1.onmessage = oldOnMessage;
            return postMessageIsAsynchronous_1;
        }
        return false;
    };
    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fn = function result() {
            var _a = result,
                handler = _a.handler,
                args = _a.args;
            if (typeof handler === 'function') {
                handler.apply(undefined, args);
            } else {
                new Function('' + handler)();
            }
        };
        fn.handler = handler;
        fn.args = args;
        return fn;
    };
    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
        return this.nextHandle++;
    };
    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var root$$1 = this.root;
        var messagePrefix = 'setImmediate$' + root$$1.Math.random() + '$';
        var onGlobalMessage = function globalMessageHandler(event) {
            var instance = globalMessageHandler.instance;
            if (event.source === root$$1 && typeof event.data === 'string' && event.data.indexOf(messagePrefix) === 0) {
                instance.runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };
        onGlobalMessage.instance = this;
        root$$1.addEventListener('message', onGlobalMessage, false);
        var fn = function setImmediate() {
            var _a = setImmediate,
                messagePrefix = _a.messagePrefix,
                instance = _a.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.postMessage(messagePrefix + handle, '*');
            return handle;
        };
        fn.instance = this;
        fn.messagePrefix = messagePrefix;
        return fn;
    };
    ImmediateDefinition.prototype.runIfPresent = function (handle) {
        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
        // So if we're currently running a task, we'll need to delay this invocation.
        if (this.currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // 'too much recursion' error.
            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
        } else {
            var task = this.tasksByHandle[handle];
            if (task) {
                this.currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    this.clearImmediate(handle);
                    this.currentlyRunningATask = false;
                }
            }
        }
    };
    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
        var _this = this;
        var channel = new this.root.MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            _this.runIfPresent(handle);
        };
        var fn = function setImmediate() {
            var _a = setImmediate,
                channel = _a.channel,
                instance = _a.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
        fn.channel = channel;
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var root$$1 = instance.root;
            var doc = root$$1.document;
            var html = doc.documentElement;
            var handle = instance.addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement('script');
            script.onreadystatechange = function () {
                instance.runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    return ImmediateDefinition;
}();
var ImmediateDefinition_1 = ImmediateDefinition;
var Immediate_1$1 = new ImmediateDefinition(root_1$14.root);

var Immediate = {
    ImmediateDefinition: ImmediateDefinition_1,
    Immediate: Immediate_1$1
};

var __extends$100 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Immediate_1 = Immediate;
var AsyncAction_1$4 = AsyncAction_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsapAction = function (_super) {
    __extends$100(AsapAction, _super);
    function AsapAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1$4.AsyncAction);
var AsapAction_2 = AsapAction;

var AsapAction_1$1 = {
    AsapAction: AsapAction_2
};

var __extends$101 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1$4 = AsyncScheduler_1$1;
var AsapScheduler = function (_super) {
    __extends$101(AsapScheduler, _super);
    function AsapScheduler() {
        _super.apply(this, arguments);
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1$4.AsyncScheduler);
var AsapScheduler_2 = AsapScheduler;

var AsapScheduler_1$1 = {
    AsapScheduler: AsapScheduler_2
};

var AsapAction_1 = AsapAction_1$1;
var AsapScheduler_1 = AsapScheduler_1$1;
var asap_1$2 = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);

var asap = {
	asap: asap_1$2
};

var __extends$99 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$137 = Observable_1$2;
var asap_1$1 = asap;
var isNumeric_1$4 = isNumeric_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var SubscribeOnObservable = function (_super) {
    __extends$99(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap_1$1.asap;
        }
        _super.call(this);
        this.source = source;
        this.delayTime = delayTime;
        this.scheduler = scheduler;
        if (!isNumeric_1$4.isNumeric(delayTime) || delayTime < 0) {
            this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            this.scheduler = asap_1$1.asap;
        }
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap_1$1.asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source,
            subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable_1$137.Observable);
var SubscribeOnObservable_2 = SubscribeOnObservable;

var SubscribeOnObservable_1$1 = {
    SubscribeOnObservable: SubscribeOnObservable_2
};

var SubscribeOnObservable_1 = SubscribeOnObservable_1$1;
/**
 * Asynchronously subscribes Observers to this Observable on the specified Scheduler.
 *
 * <img src="./img/subscribeOn.png" width="100%">
 *
 * @param {Scheduler} the Scheduler to perform subscription actions on.
 * @return {Observable<T>} the source Observable modified so that its subscriptions happen on the specified Scheduler
 .
 * @method subscribeOn
 * @owner Observable
 */
function subscribeOn$2(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return this.lift(new SubscribeOnOperator(scheduler, delay));
}
var subscribeOn_2 = subscribeOn$2;
var SubscribeOnOperator = function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}();

var subscribeOn_1$1 = {
    subscribeOn: subscribeOn_2
};

var Observable_1$136 = Observable_1$2;
var subscribeOn_1 = subscribeOn_1$1;
Observable_1$136.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;

var __extends$102 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$29 = OuterSubscriber_1$1;
var subscribeToResult_1$29 = subscribeToResult_1$1;
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
function _switch$2() {
    return this.lift(new SwitchOperator());
}
var _switch_2 = _switch$2;
var SwitchOperator = function () {
    function SwitchOperator() {}
    SwitchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchSubscriber(subscriber));
    };
    return SwitchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchSubscriber = function (_super) {
    __extends$102(SwitchSubscriber, _super);
    function SwitchSubscriber(destination) {
        _super.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }
    SwitchSubscriber.prototype._next = function (value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = subscribeToResult_1$29.subscribeToResult(this, value));
    };
    SwitchSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    SwitchSubscriber.prototype.unsubscribeInner = function () {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };
    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    SwitchSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchSubscriber.prototype.notifyComplete = function () {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return SwitchSubscriber;
}(OuterSubscriber_1$29.OuterSubscriber);

var _switch_1 = {
    _switch: _switch_2
};

var Observable_1$138 = Observable_1$2;
var switch_1 = _switch_1;
Observable_1$138.Observable.prototype.switch = switch_1._switch;
Observable_1$138.Observable.prototype._switch = switch_1._switch;

var __extends$103 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$30 = OuterSubscriber_1$1;
var subscribeToResult_1$30 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap$2(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
var switchMap_2 = switchMap$2;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends$103(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1$30.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1$30.OuterSubscriber);

var switchMap_1$1 = {
    switchMap: switchMap_2
};

var Observable_1$139 = Observable_1$2;
var switchMap_1 = switchMap_1$1;
Observable_1$139.Observable.prototype.switchMap = switchMap_1.switchMap;

var __extends$104 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$31 = OuterSubscriber_1$1;
var subscribeToResult_1$31 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` every time a value is emitted on the source Observable.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
function switchMapTo$2(innerObservable, resultSelector) {
    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
}
var switchMapTo_2 = switchMapTo$2;
var SwitchMapToOperator = function () {
    function SwitchMapToOperator(observable, resultSelector) {
        this.observable = observable;
        this.resultSelector = resultSelector;
    }
    SwitchMapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
    };
    return SwitchMapToOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapToSubscriber = function (_super) {
    __extends$104(SwitchMapToSubscriber, _super);
    function SwitchMapToSubscriber(destination, inner, resultSelector) {
        _super.call(this, destination);
        this.inner = inner;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapToSubscriber.prototype._next = function (value) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1$31.subscribeToResult(this, this.inner, value, this.index++));
    };
    SwitchMapToSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        var result;
        try {
            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            destination.error(err);
            return;
        }
        destination.next(result);
    };
    return SwitchMapToSubscriber;
}(OuterSubscriber_1$31.OuterSubscriber);

var switchMapTo_1$1 = {
    switchMapTo: switchMapTo_2
};

var Observable_1$140 = Observable_1$2;
var switchMapTo_1 = switchMapTo_1$1;
Observable_1$140.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;

var __extends$105 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$46 = Subscriber_1$3;
var ArgumentOutOfRangeError_1$4 = ArgumentOutOfRangeError_1$2;
var EmptyObservable_1$8 = EmptyObservable_1$1;
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take$2(count) {
    if (count === 0) {
        return new EmptyObservable_1$8.EmptyObservable();
    } else {
        return this.lift(new TakeOperator(count));
    }
}
var take_2 = take$2;
var TakeOperator = function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1$4.ArgumentOutOfRangeError();
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = function (_super) {
    __extends$105(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1$46.Subscriber);

var take_1$1 = {
    take: take_2
};

var Observable_1$141 = Observable_1$2;
var take_1 = take_1$1;
Observable_1$141.Observable.prototype.take = take_1.take;

var __extends$106 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$47 = Subscriber_1$3;
var ArgumentOutOfRangeError_1$5 = ArgumentOutOfRangeError_1$2;
var EmptyObservable_1$9 = EmptyObservable_1$1;
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.takeLast(3);
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */
function takeLast$2(count) {
    if (count === 0) {
        return new EmptyObservable_1$9.EmptyObservable();
    } else {
        return this.lift(new TakeLastOperator(count));
    }
}
var takeLast_2 = takeLast$2;
var TakeLastOperator = function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1$5.ArgumentOutOfRangeError();
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = function (_super) {
    __extends$106(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        } else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = count++ % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1$47.Subscriber);

var takeLast_1$1 = {
    takeLast: takeLast_2
};

var Observable_1$142 = Observable_1$2;
var takeLast_1 = takeLast_1$1;
Observable_1$142.Observable.prototype.takeLast = takeLast_1.takeLast;

var __extends$107 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$32 = OuterSubscriber_1$1;
var subscribeToResult_1$32 = subscribeToResult_1$1;
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil$2(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
var takeUntil_2 = takeUntil$2;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends$107(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1$32.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1$32.OuterSubscriber);

var takeUntil_1$1 = {
    takeUntil: takeUntil_2
};

var Observable_1$143 = Observable_1$2;
var takeUntil_1 = takeUntil_1$1;
Observable_1$143.Observable.prototype.takeUntil = takeUntil_1.takeUntil;

var __extends$108 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$48 = Subscriber_1$3;
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */
function takeWhile$2(predicate) {
    return this.lift(new TakeWhileOperator(predicate));
}
var takeWhile_2 = takeWhile$2;
var TakeWhileOperator = function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = function (_super) {
    __extends$108(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.index = 0;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        } catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        } else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1$48.Subscriber);

var takeWhile_1$1 = {
    takeWhile: takeWhile_2
};

var Observable_1$144 = Observable_1$2;
var takeWhile_1 = takeWhile_1$1;
Observable_1$144.Observable.prototype.takeWhile = takeWhile_1.takeWhile;

var __extends$109 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$33 = OuterSubscriber_1$1;
var subscribeToResult_1$33 = subscribeToResult_1$1;
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): Observable|Promise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */
function throttle$2(durationSelector) {
    return this.lift(new ThrottleOperator(durationSelector));
}
var throttle_2 = throttle$2;
var ThrottleOperator = function () {
    function ThrottleOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector));
    };
    return ThrottleOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = function (_super) {
    __extends$109(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.tryDurationSelector(value);
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        var duration = null;
        try {
            duration = this.durationSelector(value);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.emitAndThrottle(value, duration);
    };
    ThrottleSubscriber.prototype.emitAndThrottle = function (value, duration) {
        this.add(this.throttled = subscribeToResult_1$33.subscribeToResult(this, duration));
        this.destination.next(value);
    };
    ThrottleSubscriber.prototype._unsubscribe = function () {
        var throttled = this.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._unsubscribe();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this._unsubscribe();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1$33.OuterSubscriber);

var throttle_1$1 = {
    throttle: throttle_2
};

var Observable_1$145 = Observable_1$2;
var throttle_1 = throttle_1$1;
Observable_1$145.Observable.prototype.throttle = throttle_1.throttle;

var __extends$110 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$49 = Subscriber_1$3;
var async_1$9 = async;
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link Scheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime$2(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$9.async;
    }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}
var throttleTime_2 = throttleTime$2;
var ThrottleTimeOperator = function () {
    function ThrottleTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return ThrottleTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = function (_super) {
    __extends$110(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$5, this.duration, { subscriber: this }));
            this.destination.next(value);
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1$49.Subscriber);
function dispatchNext$5(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

var throttleTime_1$1 = {
    throttleTime: throttleTime_2
};

var Observable_1$146 = Observable_1$2;
var throttleTime_1 = throttleTime_1$1;
Observable_1$146.Observable.prototype.throttleTime = throttleTime_1.throttleTime;

var __extends$111 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$50 = Subscriber_1$3;
var async_1$10 = async;
/**
 * @param scheduler
 * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timeInterval
 * @owner Observable
 */
function timeInterval$2(scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$10.async;
    }
    return this.lift(new TimeIntervalOperator(scheduler));
}
var timeInterval_2 = timeInterval$2;
var TimeInterval$1 = function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}();
var TimeInterval_1 = TimeInterval$1;

var TimeIntervalOperator = function () {
    function TimeIntervalOperator(scheduler) {
        this.scheduler = scheduler;
    }
    TimeIntervalOperator.prototype.call = function (observer, source) {
        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
    };
    return TimeIntervalOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeIntervalSubscriber = function (_super) {
    __extends$111(TimeIntervalSubscriber, _super);
    function TimeIntervalSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.lastTime = 0;
        this.lastTime = scheduler.now();
    }
    TimeIntervalSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        var span = now - this.lastTime;
        this.lastTime = now;
        this.destination.next(new TimeInterval$1(value, span));
    };
    return TimeIntervalSubscriber;
}(Subscriber_1$50.Subscriber);

var timeInterval_1$2 = {
    timeInterval: timeInterval_2,
    TimeInterval: TimeInterval_1
};

var Observable_1$147 = Observable_1$2;
var timeInterval_1$1 = timeInterval_1$2;
Observable_1$147.Observable.prototype.timeInterval = timeInterval_1$1.timeInterval;

var __extends$113 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError$1 = function (_super) {
    __extends$113(TimeoutError, _super);
    function TimeoutError() {
        var err = _super.call(this, 'Timeout has occurred');
        this.name = err.name = 'TimeoutError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return TimeoutError;
}(Error);
var TimeoutError_2 = TimeoutError$1;

var TimeoutError_1$2 = {
    TimeoutError: TimeoutError_2
};

var __extends$112 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1$11 = async;
var isDate_1$4 = isDate_1$1;
var Subscriber_1$51 = Subscriber_1$3;
var TimeoutError_1$1 = TimeoutError_1$2;
/**
 * @param {number} due
 * @param {Scheduler} [scheduler]
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeout
 * @owner Observable
 */
function timeout$2(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$11.async;
    }
    var absoluteTimeout = isDate_1$4.isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1$1.TimeoutError()));
}
var timeout_2 = timeout$2;
var TimeoutOperator = function () {
    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
    }
    TimeoutOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
    };
    return TimeoutOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutSubscriber = function (_super) {
    __extends$112(TimeoutSubscriber, _super);
    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
        _super.call(this, destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.scheduler = scheduler;
        this.errorInstance = errorInstance;
        this.index = 0;
        this._previousIndex = 0;
        this._hasCompleted = false;
        this.scheduleTimeout();
    }
    Object.defineProperty(TimeoutSubscriber.prototype, "previousIndex", {
        get: function () {
            return this._previousIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeoutSubscriber.prototype, "hasCompleted", {
        get: function () {
            return this._hasCompleted;
        },
        enumerable: true,
        configurable: true
    });
    TimeoutSubscriber.dispatchTimeout = function (state) {
        var source = state.subscriber;
        var currentIndex = state.index;
        if (!source.hasCompleted && source.previousIndex === currentIndex) {
            source.notifyTimeout();
        }
    };
    TimeoutSubscriber.prototype.scheduleTimeout = function () {
        var currentIndex = this.index;
        this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, { subscriber: this, index: currentIndex });
        this.index++;
        this._previousIndex = currentIndex;
    };
    TimeoutSubscriber.prototype._next = function (value) {
        this.destination.next(value);
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
    };
    TimeoutSubscriber.prototype._error = function (err) {
        this.destination.error(err);
        this._hasCompleted = true;
    };
    TimeoutSubscriber.prototype._complete = function () {
        this.destination.complete();
        this._hasCompleted = true;
    };
    TimeoutSubscriber.prototype.notifyTimeout = function () {
        this.error(this.errorInstance);
    };
    return TimeoutSubscriber;
}(Subscriber_1$51.Subscriber);

var timeout_1$1 = {
    timeout: timeout_2
};

var Observable_1$148 = Observable_1$2;
var timeout_1 = timeout_1$1;
Observable_1$148.Observable.prototype.timeout = timeout_1.timeout;

var __extends$114 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1$12 = async;
var isDate_1$5 = isDate_1$1;
var OuterSubscriber_1$34 = OuterSubscriber_1$1;
var subscribeToResult_1$34 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * @param due
 * @param withObservable
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeoutWith
 * @owner Observable
 */
function timeoutWith$2(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$12.async;
    }
    var absoluteTimeout = isDate_1$5.isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
}
var timeoutWith_2 = timeoutWith$2;
var TimeoutWithOperator = function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = function (_super) {
    __extends$114(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        _super.call(this);
        this.destination = destination;
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.timeoutSubscription = undefined;
        this.index = 0;
        this._previousIndex = 0;
        this._hasCompleted = false;
        destination.add(this);
        this.scheduleTimeout();
    }
    Object.defineProperty(TimeoutWithSubscriber.prototype, "previousIndex", {
        get: function () {
            return this._previousIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimeoutWithSubscriber.prototype, "hasCompleted", {
        get: function () {
            return this._hasCompleted;
        },
        enumerable: true,
        configurable: true
    });
    TimeoutWithSubscriber.dispatchTimeout = function (state) {
        var source = state.subscriber;
        var currentIndex = state.index;
        if (!source.hasCompleted && source.previousIndex === currentIndex) {
            source.handleTimeout();
        }
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var currentIndex = this.index;
        var timeoutState = { subscriber: this, index: currentIndex };
        this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, timeoutState);
        this.index++;
        this._previousIndex = currentIndex;
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        this.destination.next(value);
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
    };
    TimeoutWithSubscriber.prototype._error = function (err) {
        this.destination.error(err);
        this._hasCompleted = true;
    };
    TimeoutWithSubscriber.prototype._complete = function () {
        this.destination.complete();
        this._hasCompleted = true;
    };
    TimeoutWithSubscriber.prototype.handleTimeout = function () {
        if (!this.closed) {
            var withObservable = this.withObservable;
            this.unsubscribe();
            this.destination.add(this.timeoutSubscription = subscribeToResult_1$34.subscribeToResult(this, withObservable));
        }
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1$34.OuterSubscriber);

var timeoutWith_1$1 = {
    timeoutWith: timeoutWith_2
};

var Observable_1$149 = Observable_1$2;
var timeoutWith_1 = timeoutWith_1$1;
Observable_1$149.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;

var __extends$115 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$52 = Subscriber_1$3;
var async_1$13 = async;
/**
 * @param scheduler
 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timestamp
 * @owner Observable
 */
function timestamp$2(scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1$13.async;
    }
    return this.lift(new TimestampOperator(scheduler));
}
var timestamp_2 = timestamp$2;
var Timestamp$1 = function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}();
var Timestamp_1 = Timestamp$1;

var TimestampOperator = function () {
    function TimestampOperator(scheduler) {
        this.scheduler = scheduler;
    }
    TimestampOperator.prototype.call = function (observer, source) {
        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));
    };
    return TimestampOperator;
}();
var TimestampSubscriber = function (_super) {
    __extends$115(TimestampSubscriber, _super);
    function TimestampSubscriber(destination, scheduler) {
        _super.call(this, destination);
        this.scheduler = scheduler;
    }
    TimestampSubscriber.prototype._next = function (value) {
        var now = this.scheduler.now();
        this.destination.next(new Timestamp$1(value, now));
    };
    return TimestampSubscriber;
}(Subscriber_1$52.Subscriber);

var timestamp_1$2 = {
    timestamp: timestamp_2,
    Timestamp: Timestamp_1
};

var Observable_1$150 = Observable_1$2;
var timestamp_1$1 = timestamp_1$2;
Observable_1$150.Observable.prototype.timestamp = timestamp_1$1.timestamp;

var __extends$116 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$53 = Subscriber_1$3;
/**
 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
 * @method toArray
 * @owner Observable
 */
function toArray$2() {
    return this.lift(new ToArrayOperator());
}
var toArray_2 = toArray$2;
var ToArrayOperator = function () {
    function ToArrayOperator() {}
    ToArrayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ToArraySubscriber(subscriber));
    };
    return ToArrayOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ToArraySubscriber = function (_super) {
    __extends$116(ToArraySubscriber, _super);
    function ToArraySubscriber(destination) {
        _super.call(this, destination);
        this.array = [];
    }
    ToArraySubscriber.prototype._next = function (x) {
        this.array.push(x);
    };
    ToArraySubscriber.prototype._complete = function () {
        this.destination.next(this.array);
        this.destination.complete();
    };
    return ToArraySubscriber;
}(Subscriber_1$53.Subscriber);

var toArray_1$1 = {
    toArray: toArray_2
};

var Observable_1$151 = Observable_1$2;
var toArray_1 = toArray_1$1;
Observable_1$151.Observable.prototype.toArray = toArray_1.toArray;

var root_1$15 = root;
/* tslint:disable:max-line-length */
/**
 * @param PromiseCtor
 * @return {Promise<T>}
 * @method toPromise
 * @owner Observable
 */
function toPromise$2(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
        if (root_1$15.root.Rx && root_1$15.root.Rx.config && root_1$15.root.Rx.config.Promise) {
            PromiseCtor = root_1$15.root.Rx.config.Promise;
        } else if (root_1$15.root.Promise) {
            PromiseCtor = root_1$15.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var value;
        _this.subscribe(function (x) {
            return value = x;
        }, function (err) {
            return reject(err);
        }, function () {
            return resolve(value);
        });
    });
}
var toPromise_2 = toPromise$2;

var toPromise_1$1 = {
    toPromise: toPromise_2
};

var Observable_1$152 = Observable_1$2;
var toPromise_1 = toPromise_1$1;
Observable_1$152.Observable.prototype.toPromise = toPromise_1.toPromise;

var __extends$117 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$13 = Subject_1$1;
var OuterSubscriber_1$35 = OuterSubscriber_1$1;
var subscribeToResult_1$35 = subscribeToResult_1$1;
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */
function window$3(windowBoundaries) {
    return this.lift(new WindowOperator(windowBoundaries));
}
var window_2 = window$3;
var WindowOperator = function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult_1$35.subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = function (_super) {
    __extends$117(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        _super.call(this, destination);
        this.window = new Subject_1$13.Subject();
        destination.next(this.window);
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1$13.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1$35.OuterSubscriber);

var window_1$1 = {
    window: window_2
};

var Observable_1$153 = Observable_1$2;
var window_1 = window_1$1;
Observable_1$153.Observable.prototype.window = window_1.window;

var __extends$118 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1$54 = Subscriber_1$3;
var Subject_1$14 = Subject_1$1;
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */
function windowCount$2(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
        startWindowEvery = 0;
    }
    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
}
var windowCount_2 = windowCount$2;
var WindowCountOperator = function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = function (_super) {
    __extends$118(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new Subject_1$14.Subject()];
        this.count = 0;
        destination.next(this.windows[0]);
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1$14.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1$54.Subscriber);

var windowCount_1$1 = {
    windowCount: windowCount_2
};

var Observable_1$154 = Observable_1$2;
var windowCount_1 = windowCount_1$1;
Observable_1$154.Observable.prototype.windowCount = windowCount_1.windowCount;

var __extends$119 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$15 = Subject_1$1;
var async_1$14 = async;
var Subscriber_1$55 = Subscriber_1$3;
/**
 * Branch out the source Observable values as a nested Observable periodically
 * in time.
 *
 * <span class="informal">It's like {@link bufferTime}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowTime.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable starts a new window periodically, as
 * determined by the `windowCreationInterval` argument. It emits each window
 * after a fixed timespan, specified by the `windowTimeSpan` argument. When the
 * source Observable completes or encounters an error, the output Observable
 * emits the current window and propagates the notification from the source
 * Observable. If `windowCreationInterval` is not provided, the output
 * Observable starts a new window when the previous window of duration
 * `windowTimeSpan` completes.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowTime(1000)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowTime(1000, 5000)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferTime}
 *
 * @param {number} windowTimeSpan The amount of time to fill each window.
 * @param {number} [windowCreationInterval] The interval at which to start new
 * windows.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine window boundaries.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowTime
 * @owner Observable
 */
function windowTime$2(windowTimeSpan, windowCreationInterval, scheduler) {
    if (windowCreationInterval === void 0) {
        windowCreationInterval = null;
    }
    if (scheduler === void 0) {
        scheduler = async_1$14.async;
    }
    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
}
var windowTime_2 = windowTime$2;
var WindowTimeOperator = function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler));
    };
    return WindowTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = function (_super) {
    __extends$119(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.scheduler = scheduler;
        this.windows = [];
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var window_1 = this.openWindow();
            var closeState = { subscriber: this, window: window_1, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
            var window_2 = this.openWindow();
            var timeSpanOnlyState = { subscriber: this, window: window_2, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_3 = windows[i];
            if (!window_3.closed) {
                window_3.next(value);
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_4 = windows.shift();
            if (!window_4.closed) {
                window_4.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new Subject_1$15.Subject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1$55.Subscriber);
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber,
        windowTimeSpan = state.windowTimeSpan,
        window = state.window;
    if (window) {
        window.complete();
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan,
        subscriber = state.subscriber,
        scheduler = state.scheduler,
        windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(arg) {
    var subscriber = arg.subscriber,
        window = arg.window,
        context = arg.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

var windowTime_1$1 = {
    windowTime: windowTime_2
};

var Observable_1$155 = Observable_1$2;
var windowTime_1 = windowTime_1$1;
Observable_1$155.Observable.prototype.windowTime = windowTime_1.windowTime;

var __extends$120 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$16 = Subject_1$1;
var Subscription_1$17 = Subscription_1$3;
var tryCatch_1$16 = tryCatch_1$1;
var errorObject_1$16 = errorObject;
var OuterSubscriber_1$36 = OuterSubscriber_1$1;
var subscribeToResult_1$36 = subscribeToResult_1$1;
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
function windowToggle$2(openings, closingSelector) {
    return this.lift(new WindowToggleOperator(openings, closingSelector));
}
var windowToggle_2 = windowToggle$2;
var WindowToggleOperator = function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = function (_super) {
    __extends$120(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _super.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = subscribeToResult_1$36.subscribeToResult(this, openings, openings));
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.error(err);
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.complete();
                context.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context = contexts[index];
                context.window.unsubscribe();
                context.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch_1$16.tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject_1$16.errorObject) {
                return this.error(errorObject_1$16.errorObject.e);
            } else {
                var window_1 = new Subject_1$16.Subject();
                var subscription = new Subscription_1$17.Subscription();
                var context = { window: window_1, subscription: subscription };
                this.contexts.push(context);
                var innerSubscription = subscribeToResult_1$36.subscribeToResult(this, closingNotifier, context);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                } else {
                    innerSubscription.context = context;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        } else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window,
            subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1$36.OuterSubscriber);

var windowToggle_1$1 = {
    windowToggle: windowToggle_2
};

var Observable_1$156 = Observable_1$2;
var windowToggle_1 = windowToggle_1$1;
Observable_1$156.Observable.prototype.windowToggle = windowToggle_1.windowToggle;

var __extends$121 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$17 = Subject_1$1;
var tryCatch_1$17 = tryCatch_1$1;
var errorObject_1$17 = errorObject;
var OuterSubscriber_1$37 = OuterSubscriber_1$1;
var subscribeToResult_1$37 = subscribeToResult_1$1;
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
function windowWhen$2(closingSelector) {
    return this.lift(new WindowOperator$1(closingSelector));
}
var windowWhen_2 = windowWhen$2;
var WindowOperator$1 = function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
    };
    return WindowOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber$1 = function (_super) {
    __extends$121(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        _super.call(this, destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1$17.Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch_1$17.tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject_1$17.errorObject) {
            var err = errorObject_1$17.errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        } else {
            this.add(this.closingNotification = subscribeToResult_1$37.subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber_1$37.OuterSubscriber);

var windowWhen_1$1 = {
    windowWhen: windowWhen_2
};

var Observable_1$157 = Observable_1$2;
var windowWhen_1 = windowWhen_1$1;
Observable_1$157.Observable.prototype.windowWhen = windowWhen_1.windowWhen;

var __extends$122 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1$38 = OuterSubscriber_1$1;
var subscribeToResult_1$38 = subscribeToResult_1$1;
/* tslint:disable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {Observable} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom$2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}
var withLatestFrom_2 = withLatestFrom$2;
var WithLatestFromOperator = function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = function (_super) {
    __extends$122(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1$38.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            } else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1$38.OuterSubscriber);

var withLatestFrom_1$1 = {
    withLatestFrom: withLatestFrom_2
};

var Observable_1$158 = Observable_1$2;
var withLatestFrom_1 = withLatestFrom_1$1;
Observable_1$158.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;

var Observable_1$159 = Observable_1$2;
var zip_1$2 = zip$4;
Observable_1$159.Observable.prototype.zip = zip_1$2.zipProto;

var zip_1$3 = zip$4;
/**
 * @param project
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method zipAll
 * @owner Observable
 */
function zipAll$2(project) {
  return this.lift(new zip_1$3.ZipOperator(project));
}
var zipAll_2 = zipAll$2;

var zipAll_1$1 = {
  zipAll: zipAll_2
};

var Observable_1$160 = Observable_1$2;
var zipAll_1 = zipAll_1$1;
Observable_1$160.Observable.prototype.zipAll = zipAll_1.zipAll;

var SubscriptionLog = function () {
    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
        if (unsubscribedFrame === void 0) {
            unsubscribedFrame = Number.POSITIVE_INFINITY;
        }
        this.subscribedFrame = subscribedFrame;
        this.unsubscribedFrame = unsubscribedFrame;
    }
    return SubscriptionLog;
}();
var SubscriptionLog_2 = SubscriptionLog;

var SubscriptionLog_1$2 = {
    SubscriptionLog: SubscriptionLog_2
};

var SubscriptionLog_1$1 = SubscriptionLog_1$2;
var SubscriptionLoggable = function () {
    function SubscriptionLoggable() {
        this.subscriptions = [];
    }
    SubscriptionLoggable.prototype.logSubscribedFrame = function () {
        this.subscriptions.push(new SubscriptionLog_1$1.SubscriptionLog(this.scheduler.now()));
        return this.subscriptions.length - 1;
    };
    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
        var subscriptionLogs = this.subscriptions;
        var oldSubscriptionLog = subscriptionLogs[index];
        subscriptionLogs[index] = new SubscriptionLog_1$1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
    };
    return SubscriptionLoggable;
}();
var SubscriptionLoggable_2 = SubscriptionLoggable;

var SubscriptionLoggable_1$1 = {
    SubscriptionLoggable: SubscriptionLoggable_2
};

function applyMixins(derivedCtor, baseCtors) {
    for (var i = 0, len = baseCtors.length; i < len; i++) {
        var baseCtor = baseCtors[i];
        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
            var name_1 = propertyKeys[j];
            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
        }
    }
}
var applyMixins_2 = applyMixins;

var applyMixins_1$1 = {
    applyMixins: applyMixins_2
};

var __extends$124 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$162 = Observable_1$2;
var Subscription_1$18 = Subscription_1$3;
var SubscriptionLoggable_1 = SubscriptionLoggable_1$1;
var applyMixins_1 = applyMixins_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ColdObservable = function (_super) {
    __extends$124(ColdObservable, _super);
    function ColdObservable(messages, scheduler) {
        _super.call(this, function (subscriber) {
            var observable = this;
            var index = observable.logSubscribedFrame();
            subscriber.add(new Subscription_1$18.Subscription(function () {
                observable.logUnsubscribedFrame(index);
            }));
            observable.scheduleMessages(subscriber);
            return subscriber;
        });
        this.messages = messages;
        this.subscriptions = [];
        this.scheduler = scheduler;
    }
    ColdObservable.prototype.scheduleMessages = function (subscriber) {
        var messagesLength = this.messages.length;
        for (var i = 0; i < messagesLength; i++) {
            var message = this.messages[i];
            subscriber.add(this.scheduler.schedule(function (_a) {
                var message = _a.message,
                    subscriber = _a.subscriber;
                message.notification.observe(subscriber);
            }, message.frame, { message: message, subscriber: subscriber }));
        }
    };
    return ColdObservable;
}(Observable_1$162.Observable);
var ColdObservable_2 = ColdObservable;
applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);

var ColdObservable_1$1 = {
    ColdObservable: ColdObservable_2
};

var __extends$125 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1$18 = Subject_1$1;
var Subscription_1$19 = Subscription_1$3;
var SubscriptionLoggable_1$3 = SubscriptionLoggable_1$1;
var applyMixins_1$3 = applyMixins_1$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var HotObservable = function (_super) {
    __extends$125(HotObservable, _super);
    function HotObservable(messages, scheduler) {
        _super.call(this);
        this.messages = messages;
        this.subscriptions = [];
        this.scheduler = scheduler;
    }
    HotObservable.prototype._subscribe = function (subscriber) {
        var subject = this;
        var index = subject.logSubscribedFrame();
        subscriber.add(new Subscription_1$19.Subscription(function () {
            subject.logUnsubscribedFrame(index);
        }));
        return _super.prototype._subscribe.call(this, subscriber);
    };
    HotObservable.prototype.setup = function () {
        var subject = this;
        var messagesLength = subject.messages.length;
        /* tslint:disable:no-var-keyword */
        for (var i = 0; i < messagesLength; i++) {
            (function () {
                var message = subject.messages[i];
                /* tslint:enable */
                subject.scheduler.schedule(function () {
                    message.notification.observe(subject);
                }, message.frame);
            })();
        }
    };
    return HotObservable;
}(Subject_1$18.Subject);
var HotObservable_2 = HotObservable;
applyMixins_1$3.applyMixins(HotObservable, [SubscriptionLoggable_1$3.SubscriptionLoggable]);

var HotObservable_1$1 = {
    HotObservable: HotObservable_2
};

var __extends$126 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1$5 = AsyncAction_1$1;
var AsyncScheduler_1$5 = AsyncScheduler_1$1;
var VirtualTimeScheduler$1 = function (_super) {
    __extends$126(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        var _this = this;
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        _super.call(this, SchedulerAction, function () {
            return _this.frame;
        });
        this.maxFrames = maxFrames;
        this.frame = 0;
        this.index = -1;
    }
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this,
            actions = _a.actions,
            maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1$5.AsyncScheduler);
var VirtualTimeScheduler_2 = VirtualTimeScheduler$1;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var VirtualAction = function (_super) {
    __extends$126(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.index = index;
        this.index = scheduler.index = index;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return !this.id ? _super.prototype.schedule.call(this, state, delay) : this.add(new VirtualAction(this.scheduler, this.work)).schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            } else if (a.index > b.index) {
                return 1;
            } else {
                return -1;
            }
        } else if (a.delay > b.delay) {
            return 1;
        } else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1$5.AsyncAction);
var VirtualAction_1 = VirtualAction;

var VirtualTimeScheduler_1$2 = {
    VirtualTimeScheduler: VirtualTimeScheduler_2,
    VirtualAction: VirtualAction_1
};

var __extends$123 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1$161 = Observable_1$2;
var Notification_1$6 = Notification_1$2;
var ColdObservable_1 = ColdObservable_1$1;
var HotObservable_1 = HotObservable_1$1;
var SubscriptionLog_1 = SubscriptionLog_1$2;
var VirtualTimeScheduler_1$1 = VirtualTimeScheduler_1$2;
var defaultMaxFrame = 750;
var TestScheduler$1 = function (_super) {
    __extends$123(TestScheduler, _super);
    function TestScheduler(assertDeepEqual) {
        _super.call(this, VirtualTimeScheduler_1$1.VirtualAction, defaultMaxFrame);
        this.assertDeepEqual = assertDeepEqual;
        this.hotObservables = [];
        this.coldObservables = [];
        this.flushTests = [];
    }
    TestScheduler.prototype.createTime = function (marbles) {
        var indexOf = marbles.indexOf('|');
        if (indexOf === -1) {
            throw new Error('marble diagram for time should have a completion marker "|"');
        }
        return indexOf * TestScheduler.frameTimeFactor;
    };
    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
        if (marbles.indexOf('^') !== -1) {
            throw new Error('cold observable cannot have subscription offset "^"');
        }
        if (marbles.indexOf('!') !== -1) {
            throw new Error('cold observable cannot have unsubscription marker "!"');
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error);
        var cold = new ColdObservable_1.ColdObservable(messages, this);
        this.coldObservables.push(cold);
        return cold;
    };
    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
        if (marbles.indexOf('!') !== -1) {
            throw new Error('hot observable cannot have unsubscription marker "!"');
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error);
        var subject = new HotObservable_1.HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    };
    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
        var _this = this;
        var messages = [];
        observable.subscribe(function (value) {
            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1$6.Notification.createNext(value) });
        }, function (err) {
            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1$6.Notification.createError(err) });
        }, function () {
            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1$6.Notification.createComplete() });
        });
        return messages;
    };
    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
        var _this = this;
        if (unsubscriptionMarbles === void 0) {
            unsubscriptionMarbles = null;
        }
        var actual = [];
        var flushTest = { actual: actual, ready: false };
        var unsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
        var subscription;
        this.schedule(function () {
            subscription = observable.subscribe(function (x) {
                var value = x;
                // Support Observable-of-Observables
                if (x instanceof Observable_1$161.Observable) {
                    value = _this.materializeInnerObservable(value, _this.frame);
                }
                actual.push({ frame: _this.frame, notification: Notification_1$6.Notification.createNext(value) });
            }, function (err) {
                actual.push({ frame: _this.frame, notification: Notification_1$6.Notification.createError(err) });
            }, function () {
                actual.push({ frame: _this.frame, notification: Notification_1$6.Notification.createComplete() });
            });
        }, 0);
        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
            this.schedule(function () {
                return subscription.unsubscribe();
            }, unsubscriptionFrame);
        }
        this.flushTests.push(flushTest);
        return {
            toBe: function (marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
            }
        };
    };
    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
        var flushTest = { actual: actualSubscriptionLogs, ready: false };
        this.flushTests.push(flushTest);
        return {
            toBe: function (marbles) {
                var marblesArray = typeof marbles === 'string' ? [marbles] : marbles;
                flushTest.ready = true;
                flushTest.expected = marblesArray.map(function (marbles) {
                    return TestScheduler.parseMarblesAsSubscriptions(marbles);
                });
            }
        };
    };
    TestScheduler.prototype.flush = function () {
        var hotObservables = this.hotObservables;
        while (hotObservables.length > 0) {
            hotObservables.shift().setup();
        }
        _super.prototype.flush.call(this);
        var readyFlushTests = this.flushTests.filter(function (test) {
            return test.ready;
        });
        while (readyFlushTests.length > 0) {
            var test = readyFlushTests.shift();
            this.assertDeepEqual(test.actual, test.expected);
        }
    };
    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {
        if (typeof marbles !== 'string') {
            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
        }
        var len = marbles.length;
        var groupStart = -1;
        var subscriptionFrame = Number.POSITIVE_INFINITY;
        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
        for (var i = 0; i < len; i++) {
            var frame = i * this.frameTimeFactor;
            var c = marbles[i];
            switch (c) {
                case '-':
                case ' ':
                    break;
                case '(':
                    groupStart = frame;
                    break;
                case ')':
                    groupStart = -1;
                    break;
                case '^':
                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
                        throw new Error('found a second subscription point \'^\' in a ' + 'subscription marble diagram. There can only be one.');
                    }
                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                case '!':
                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                        throw new Error('found a second subscription point \'^\' in a ' + 'subscription marble diagram. There can only be one.');
                    }
                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                default:
                    throw new Error('there can only be \'^\' and \'!\' markers in a ' + 'subscription marble diagram. Found instead \'' + c + '\'.');
            }
        }
        if (unsubscriptionFrame < 0) {
            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
        } else {
            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
        }
    };
    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
        if (materializeInnerObservables === void 0) {
            materializeInnerObservables = false;
        }
        if (marbles.indexOf('!') !== -1) {
            throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker "!"');
        }
        var len = marbles.length;
        var testMessages = [];
        var subIndex = marbles.indexOf('^');
        var frameOffset = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
        var getValue = typeof values !== 'object' ? function (x) {
            return x;
        } : function (x) {
            // Support Observable-of-Observables
            if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {
                return values[x].messages;
            }
            return values[x];
        };
        var groupStart = -1;
        for (var i = 0; i < len; i++) {
            var frame = i * this.frameTimeFactor + frameOffset;
            var notification = void 0;
            var c = marbles[i];
            switch (c) {
                case '-':
                case ' ':
                    break;
                case '(':
                    groupStart = frame;
                    break;
                case ')':
                    groupStart = -1;
                    break;
                case '|':
                    notification = Notification_1$6.Notification.createComplete();
                    break;
                case '^':
                    break;
                case '#':
                    notification = Notification_1$6.Notification.createError(errorValue || 'error');
                    break;
                default:
                    notification = Notification_1$6.Notification.createNext(getValue(c));
                    break;
            }
            if (notification) {
                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
            }
        }
        return testMessages;
    };
    return TestScheduler;
}(VirtualTimeScheduler_1$1.VirtualTimeScheduler);
var TestScheduler_2 = TestScheduler$1;

var TestScheduler_1$1 = {
    TestScheduler: TestScheduler_2
};

var root_1$16 = root;
var RequestAnimationFrameDefinition = function () {
    function RequestAnimationFrameDefinition(root$$1) {
        if (root$$1.requestAnimationFrame) {
            this.cancelAnimationFrame = root$$1.cancelAnimationFrame.bind(root$$1);
            this.requestAnimationFrame = root$$1.requestAnimationFrame.bind(root$$1);
        } else if (root$$1.mozRequestAnimationFrame) {
            this.cancelAnimationFrame = root$$1.mozCancelAnimationFrame.bind(root$$1);
            this.requestAnimationFrame = root$$1.mozRequestAnimationFrame.bind(root$$1);
        } else if (root$$1.webkitRequestAnimationFrame) {
            this.cancelAnimationFrame = root$$1.webkitCancelAnimationFrame.bind(root$$1);
            this.requestAnimationFrame = root$$1.webkitRequestAnimationFrame.bind(root$$1);
        } else if (root$$1.msRequestAnimationFrame) {
            this.cancelAnimationFrame = root$$1.msCancelAnimationFrame.bind(root$$1);
            this.requestAnimationFrame = root$$1.msRequestAnimationFrame.bind(root$$1);
        } else if (root$$1.oRequestAnimationFrame) {
            this.cancelAnimationFrame = root$$1.oCancelAnimationFrame.bind(root$$1);
            this.requestAnimationFrame = root$$1.oRequestAnimationFrame.bind(root$$1);
        } else {
            this.cancelAnimationFrame = root$$1.clearTimeout.bind(root$$1);
            this.requestAnimationFrame = function (cb) {
                return root$$1.setTimeout(cb, 1000 / 60);
            };
        }
    }
    return RequestAnimationFrameDefinition;
}();
var RequestAnimationFrameDefinition_1 = RequestAnimationFrameDefinition;
var AnimationFrame_1$1 = new RequestAnimationFrameDefinition(root_1$16.root);

var AnimationFrame = {
    RequestAnimationFrameDefinition: RequestAnimationFrameDefinition_1,
    AnimationFrame: AnimationFrame_1$1
};

var __extends$127 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1$6 = AsyncAction_1$1;
var AnimationFrame_1 = AnimationFrame;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AnimationFrameAction = function (_super) {
    __extends$127(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1$6.AsyncAction);
var AnimationFrameAction_2 = AnimationFrameAction;

var AnimationFrameAction_1$1 = {
    AnimationFrameAction: AnimationFrameAction_2
};

var __extends$128 = commonjsGlobal && commonjsGlobal.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1$6 = AsyncScheduler_1$1;
var AnimationFrameScheduler = function (_super) {
    __extends$128(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        _super.apply(this, arguments);
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1$6.AsyncScheduler);
var AnimationFrameScheduler_2 = AnimationFrameScheduler;

var AnimationFrameScheduler_1$1 = {
    AnimationFrameScheduler: AnimationFrameScheduler_2
};

var AnimationFrameAction_1 = AnimationFrameAction_1$1;
var AnimationFrameScheduler_1 = AnimationFrameScheduler_1$1;
var animationFrame_1$1 = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

var animationFrame = {
	animationFrame: animationFrame_1$1
};

/* tslint:disable:no-unused-variable */
// Subject imported before Observable to bypass circular dependency issue since
// Subject extends Observable and Observable references Subject in it's
// definition
var Subject_1 = Subject_1$1;
var Subject = Subject_1.Subject;
var AnonymousSubject = Subject_1.AnonymousSubject;
/* tslint:enable:no-unused-variable */
var Observable_1 = Observable_1$2;
var Observable = Observable_1.Observable;
// statics
/* tslint:disable:no-use-before-declare */

//dom


//operators


/* tslint:disable:no-unused-variable */
var Subscription_1 = Subscription_1$3;
var Subscription = Subscription_1.Subscription;
var Subscriber_1 = Subscriber_1$3;
var Subscriber = Subscriber_1.Subscriber;
var AsyncSubject_1 = AsyncSubject_1$2;
var AsyncSubject = AsyncSubject_1.AsyncSubject;
var ReplaySubject_1 = ReplaySubject_1$2;
var ReplaySubject = ReplaySubject_1.ReplaySubject;
var BehaviorSubject_1 = BehaviorSubject_1$2;
var BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
var ConnectableObservable_1 = ConnectableObservable_1$2;
var ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
var Notification_1 = Notification_1$2;
var Notification = Notification_1.Notification;
var EmptyError_1 = EmptyError_1$2;
var EmptyError = EmptyError_1.EmptyError;
var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError_1$2;
var ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
var ObjectUnsubscribedError_1 = ObjectUnsubscribedError_1$2;
var ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
var TimeoutError_1 = TimeoutError_1$2;
var TimeoutError = TimeoutError_1.TimeoutError;
var UnsubscriptionError_1 = UnsubscriptionError_1$2;
var UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
var timeInterval_1 = timeInterval_1$2;
var TimeInterval = timeInterval_1.TimeInterval;
var timestamp_1 = timestamp_1$2;
var Timestamp = timestamp_1.Timestamp;
var TestScheduler_1 = TestScheduler_1$1;
var TestScheduler = TestScheduler_1.TestScheduler;
var VirtualTimeScheduler_1 = VirtualTimeScheduler_1$2;
var VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
var AjaxObservable_1 = AjaxObservable_1$2;
var AjaxResponse = AjaxObservable_1.AjaxResponse;
var AjaxError = AjaxObservable_1.AjaxError;
var AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;
var asap_1 = asap;
var async_1 = async;
var queue_1 = queue;
var animationFrame_1 = animationFrame;
var rxSubscriber_1 = rxSubscriber;
var iterator_1 = iterator;
var observable_1 = observable;
/* tslint:enable:no-unused-variable */
/**
 * @typedef {Object} Rx.Scheduler
 * @property {Scheduler} queue Schedules on a queue in the current event frame
 * (trampoline scheduler). Use this for iteration operations.
 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
 * fastest transport mechanism available, either Node.js' `process.nextTick()`
 * or Web Worker MessageChannel or setTimeout or others. Use this for
 * asynchronous conversions.
 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
 * time-based operations.
 * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.
 * Use this for synchronizing with the platform's painting
 */
var Scheduler = {
  asap: asap_1.asap,
  queue: queue_1.queue,
  animationFrame: animationFrame_1.animationFrame,
  async: async_1.async
};
var Scheduler_1 = Scheduler;
/**
 * @typedef {Object} Rx.Symbol
 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
 * an object that has all of the traits of an Rx Subscriber, including the
 * ability to add and remove subscriptions to the subscription chain and
 * guarantees involving event triggering (can't "next" after unsubscription,
 * etc).
 * @property {Symbol|string} observable A symbol to use as a property name to
 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
 * to retrieve an iterator from an object.
 */
var Symbol = {
  rxSubscriber: rxSubscriber_1.$$rxSubscriber,
  observable: observable_1.$$observable,
  iterator: iterator_1.$$iterator
};
var Symbol_1 = Symbol;

var Rx = {
  Subject: Subject,
  AnonymousSubject: AnonymousSubject,
  Observable: Observable,
  Subscription: Subscription,
  Subscriber: Subscriber,
  AsyncSubject: AsyncSubject,
  ReplaySubject: ReplaySubject,
  BehaviorSubject: BehaviorSubject,
  ConnectableObservable: ConnectableObservable,
  Notification: Notification,
  EmptyError: EmptyError,
  ArgumentOutOfRangeError: ArgumentOutOfRangeError,
  ObjectUnsubscribedError: ObjectUnsubscribedError,
  TimeoutError: TimeoutError,
  UnsubscriptionError: UnsubscriptionError,
  TimeInterval: TimeInterval,
  Timestamp: Timestamp,
  TestScheduler: TestScheduler,
  VirtualTimeScheduler: VirtualTimeScheduler,
  AjaxResponse: AjaxResponse,
  AjaxError: AjaxError,
  AjaxTimeoutError: AjaxTimeoutError,
  Scheduler: Scheduler_1,
  Symbol: Symbol_1
};

// Streams
let actions$ = new Rx.Subject();
let socketOutgoing$ = new Rx.Subject();

// Model
let initModel = { text: '', messages: [], connected: false };

// Update
function update(model, [action, value]) {
  let { text, messages, connected } = model;

  switch (action) {
    case 'message':
      return Object.assign({}, model, { messages: [...messages, value] });
    case 'changeText':
      return Object.assign({}, model, { text: value });
    case 'clearText':
      return Object.assign({}, model, { text: '' });
    case 'connected':
      return Object.assign({}, model, { connected: value });
  }
}

// View
function view({ text, messages, connected }) {
  let v = ['div', {}, [['input', { props: { placeholder: 'Send message', autofocus: true, value: text },
    on: { input: handleInput }, hook: { postpatch: focusElement } }], ['button', { props: { disabled: !connected }, on: { click: [handleClick, text] } }, 'Send'], ['span', {}, connected ? '' : ' Connecting...'], ['div', { style: { paddingTop: '7px' } }, messages.map(displayMessage)]]];

  return v;
}

function focusElement(oldVnode, vnode) {
  return vnode.elm.focus();
}

function displayMessage(msg) {
  return ['div', {}, msg];
}

function handleInput(e) {
  let value = e.target.value.trim();
  actions$.next(['changeText', value]);
}

function handleClick(text) {
  actions$.next(['clearText']);
  socketOutgoing$.next(text);
}

// Websocket
let ws = new index$1('wss://echo.websocket.org');

let online$ = Rx.Observable.interval(500).map(() => navigator.onLine).distinctUntilChanged();

let socketConnected$ = Rx.Observable.create(subscriber => {
  ws.onopen = () => subscriber.next(true);
  ws.onclose = () => subscriber.next(false);
});

let connected$ = socketConnected$.combineLatest(online$, (connected, online) => connected && online).publishBehavior(false).refCount();

socketOutgoing$.withLatestFrom(connected$, (msg, connected) => [msg, connected]).filter(([, connected]) => connected).subscribe(([msg]) => ws.send(msg));

let socketIncoming$ = Rx.Observable.create(subscriber => {
  ws.onmessage = msg => subscriber.next(msg);
});

let effects$ = socketIncoming$.map(msgEvent => ['message', msgEvent.data]).merge(connected$.map(connected => ['connected', connected]));

// Reduce
let model$ = actions$.merge(effects$).do(x => console.log('Actions', x)).scan(update, initModel).startWith(initModel).do(x => console.log('Model', x));

// Render
let view$ = model$.map(view);
render(view$, document.getElementById('container'));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9zbmFiYmRvbS92bm9kZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zbmFiYmRvbS9pcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zbmFiYmRvbS9odG1sZG9tYXBpLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NuYWJiZG9tL3NuYWJiZG9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NuYWJiZG9tL2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc25hYmJkb20vbW9kdWxlcy9jbGFzcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zbmFiYmRvbS9tb2R1bGVzL3Byb3BzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc25hYmJkb20vbW9kdWxlcy9ldmVudGxpc3RlbmVycy5qcyIsIi4uLy4uL3NyYy9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWNvbm5lY3Rpbmctd2Vic29ja2V0L2Rpc3QvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3Jvb3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzRnVuY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9lcnJvck9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpcHRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9yeFN1YnNjcmliZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpYmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC90b1N1YnNjcmliZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvb2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL09ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9Bc3luY1N1YmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0JvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0JvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzU2NoZWR1bGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL091dGVyU3Vic2NyaWJlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNQcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvSW5uZXJTdWJzY3JpYmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NvbWJpbmVMYXRlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VBbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jb25jYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2NvbmNhdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2NvbmNhdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvRGVmZXJPYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9kZWZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2RlZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9lbXB0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2VtcHR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Gb3JrSm9pbk9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2ZvcmtKb2luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZm9ya0pvaW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1Byb21pc2VPYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9JdGVyYXRvck9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0FycmF5TGlrZU9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9Ob3RpZmljYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9vYnNlcnZlT24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Zyb21PYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvRnJvbUV2ZW50T2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZnJvbUV2ZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0dlbmVyYXRlT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2dlbmVyYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9JZk9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2lmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvaWYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzTnVtZXJpYy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9BY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9TY2hlZHVsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvYXN5bmMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0ludGVydmFsT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvaW50ZXJ2YWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9pbnRlcnZhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL21lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcmFjZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL3JhY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL25vb3AuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL05ldmVyT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvbmV2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9uZXZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1BhaXJzT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvcGFpcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9wYWlycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvUmFuZ2VPYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9yYW5nZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL3JhbmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Vc2luZ09ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL3VzaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvdXNpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Vycm9yT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvdGhyb3cuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS90aHJvdy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNEYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9UaW1lck9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL3RpbWVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvdGltZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci96aXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL3ppcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL3ppcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZG9tL0FqYXhPYnNlcnZhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9kb20vYWpheC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2RvbS9hamF4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL1F1ZXVlQWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL1F1ZXVlU2NoZWR1bGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL3F1ZXVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvUmVwbGF5U3ViamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9kb20vV2ViU29ja2V0U3ViamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZG9tL3dlYlNvY2tldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9idWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvYnVmZmVyQ291bnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyQ291bnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9idWZmZXJUaW1lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2J1ZmZlclRpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9idWZmZXJUb2dnbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvYnVmZmVyV2hlbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY2F0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jb21iaW5lQWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2NvbWJpbmVBbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvY29tYmluZUxhdGVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9jb25jYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jb25jYXRBbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0QWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VNYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jb25jYXRNYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvY29uY2F0TWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VNYXBUby5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NvbmNhdE1hcFRvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcFRvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY291bnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvY291bnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kZW1hdGVyaWFsaXplLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kZWJvdW5jZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RlYm91bmNlVGltZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RlbGF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2RlbGF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZGVsYXlXaGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2RlbGF5V2hlbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZGlzdGluY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZGlzdGluY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9leGhhdXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2V4aGF1c3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9leGhhdXN0TWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2V4aGF1c3RNYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9leHBhbmQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZXhwYW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2VsZW1lbnRBdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9lbGVtZW50QXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmluYWxseS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmluZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9maW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2ZpbmRJbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvRW1wdHlFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpcnN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9NYXBQb2x5ZmlsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9GYXN0TWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZ3JvdXBCeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9ncm91cEJ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9pc0VtcHR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2lzRW1wdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9hdWRpdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9hdWRpdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2F1ZGl0VGltZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9hdWRpdFRpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9sYXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2xhc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9sZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbGV0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZXZlcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZXZlcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWFwVG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWFwVG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tYXRlcmlhbGl6ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3JlZHVjZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21heC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9tYXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBUby5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21lcmdlU2Nhbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZVNjYW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9taW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tdWx0aWNhc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbXVsdGljYXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL29ic2VydmVPbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9vbkVycm9yUmVzdW1lTmV4dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3BhaXJ3aXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3BhaXJ3aXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9ub3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9wYXJ0aXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcGFydGl0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcGx1Y2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcGx1Y2suanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9wdWJsaXNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9CZWhhdmlvclN1YmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9wdWJsaXNoQmVoYXZpb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcHVibGlzaFJlcGxheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9wdWJsaXNoUmVwbGF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcHVibGlzaExhc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcHVibGlzaExhc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcmFjZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9yZWR1Y2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9yZXBlYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcmVwZWF0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcmVwZWF0V2hlbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9yZXBlYXRXaGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcmV0cnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcmV0cnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9yZXRyeVdoZW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcmV0cnlXaGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc2FtcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3NhbXBsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NhbXBsZVRpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc2FtcGxlVGltZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NjYW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc2Nhbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NlcXVlbmNlRXF1YWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NoYXJlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3NoYXJlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc2luZ2xlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3NpbmdsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NraXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NraXBVbnRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9za2lwVW50aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9za2lwV2hpbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc2tpcFdoaWxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvSW1tZWRpYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9hc2FwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9TdWJzY3JpYmVPbk9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zdWJzY3JpYmVPbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zdWJzY3JpYmVPbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3N3aXRjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwVG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90YWtlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3Rha2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90YWtlTGFzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90YWtlTGFzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3Rha2VVbnRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90YWtlVW50aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90YWtlV2hpbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGFrZVdoaWxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGhyb3R0bGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGhyb3R0bGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90aHJvdHRsZVRpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGhyb3R0bGVUaW1lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGltZUludGVydmFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3RpbWVJbnRlcnZhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvVGltZW91dEVycm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGltZW91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90aW1lb3V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGltZW91dFdpdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGltZW91dFdpdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90aW1lc3RhbXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGltZXN0YW1wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdG9BcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90b0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3RvUHJvbWlzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3dpbmRvdy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3cuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci93aW5kb3dDb3VudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3dpbmRvd1RpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivd2luZG93VGltZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3dpbmRvd1RvZ2dsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci93aW5kb3dUb2dnbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci93aW5kb3dXaGVuLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3dpbmRvd1doZW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci96aXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci96aXBBbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvemlwQWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdGVzdGluZy9TdWJzY3JpcHRpb25Mb2cuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy90ZXN0aW5nL1N1YnNjcmlwdGlvbkxvZ2dhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9hcHBseU1peGlucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3Rlc3RpbmcvQ29sZE9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy90ZXN0aW5nL0hvdE9ic2VydmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvVmlydHVhbFRpbWVTY2hlZHVsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy90ZXN0aW5nL1Rlc3RTY2hlZHVsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL0FuaW1hdGlvbkZyYW1lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lQWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvUnguanMiLCJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbCwgZGF0YSwgY2hpbGRyZW4sIHRleHQsIGVsbSkge1xuICB2YXIga2V5ID0gZGF0YSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZGF0YS5rZXk7XG4gIHJldHVybiB7c2VsOiBzZWwsIGRhdGE6IGRhdGEsIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LCBlbG06IGVsbSwga2V5OiBrZXl9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheTogQXJyYXkuaXNBcnJheSxcbiAgcHJpbWl0aXZlOiBmdW5jdGlvbihzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHMgPT09ICdudW1iZXInOyB9LFxufTtcbiIsImZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSl7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKXtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KXtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuXG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKXtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpe1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpe1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKXtcbiAgcmV0dXJuIG5vZGUucGFyZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSl7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lKG5vZGUpe1xuICByZXR1cm4gbm9kZS50YWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KXtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50XG59O1xuIiwiLy8ganNoaW50IG5ld2NhcDogZmFsc2Vcbi8qIGdsb2JhbCByZXF1aXJlLCBtb2R1bGUsIGRvY3VtZW50LCBOb2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWTm9kZSA9IHJlcXVpcmUoJy4vdm5vZGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciBkb21BcGkgPSByZXF1aXJlKCcuL2h0bWxkb21hcGknKTtcblxuZnVuY3Rpb24gaXNVbmRlZihzKSB7IHJldHVybiBzID09PSB1bmRlZmluZWQ7IH1cbmZ1bmN0aW9uIGlzRGVmKHMpIHsgcmV0dXJuIHMgIT09IHVuZGVmaW5lZDsgfVxuXG52YXIgZW1wdHlOb2RlID0gVk5vZGUoJycsIHt9LCBbXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUodm5vZGUxLCB2bm9kZTIpIHtcbiAgcmV0dXJuIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiYgdm5vZGUxLnNlbCA9PT0gdm5vZGUyLnNlbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIG1hcCA9IHt9LCBrZXk7XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95JywgJ3ByZScsICdwb3N0J107XG5cbmZ1bmN0aW9uIGluaXQobW9kdWxlcywgYXBpKSB7XG4gIHZhciBpLCBqLCBjYnMgPSB7fTtcblxuICBpZiAoaXNVbmRlZihhcGkpKSBhcGkgPSBkb21BcGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAobW9kdWxlc1tqXVtob29rc1tpXV0gIT09IHVuZGVmaW5lZCkgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdChlbG0pIHtcbiAgICB2YXIgaWQgPSBlbG0uaWQgPyAnIycgKyBlbG0uaWQgOiAnJztcbiAgICB2YXIgYyA9IGVsbS5jbGFzc05hbWUgPyAnLicgKyBlbG0uY2xhc3NOYW1lLnNwbGl0KCcgJykuam9pbignLicpIDogJyc7XG4gICAgcmV0dXJuIFZOb2RlKGFwaS50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSArIGlkICsgYywge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS1saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGFwaS5wYXJlbnROb2RlKGNoaWxkRWxtKTtcbiAgICAgICAgYXBpLnJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIHZhciBpLCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlbG0sIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4sIHNlbCA9IHZub2RlLnNlbDtcbiAgICBpZiAoaXNEZWYoc2VsKSkge1xuICAgICAgLy8gUGFyc2Ugc2VsZWN0b3JcbiAgICAgIHZhciBoYXNoSWR4ID0gc2VsLmluZGV4T2YoJyMnKTtcbiAgICAgIHZhciBkb3RJZHggPSBzZWwuaW5kZXhPZignLicsIGhhc2hJZHgpO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoSWR4ID4gMCA/IGhhc2hJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgdmFyIGRvdCA9IGRvdElkeCA+IDAgPyBkb3RJZHggOiBzZWwubGVuZ3RoO1xuICAgICAgdmFyIHRhZyA9IGhhc2hJZHggIT09IC0xIHx8IGRvdElkeCAhPT0gLTEgPyBzZWwuc2xpY2UoMCwgTWF0aC5taW4oaGFzaCwgZG90KSkgOiBzZWw7XG4gICAgICBlbG0gPSB2bm9kZS5lbG0gPSBpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ucykgPyBhcGkuY3JlYXRlRWxlbWVudE5TKGksIHRhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFwaS5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICBpZiAoaGFzaCA8IGRvdCkgZWxtLmlkID0gc2VsLnNsaWNlKGhhc2ggKyAxLCBkb3QpO1xuICAgICAgaWYgKGRvdElkeCA+IDApIGVsbS5jbGFzc05hbWUgPSBzZWwuc2xpY2UoZG90ICsgMSkucmVwbGFjZSgvXFwuL2csICcgJyk7XG4gICAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXMucHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICAgIGFwaS5hcHBlbmRDaGlsZChlbG0sIGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgaWYgKGkuY3JlYXRlKSBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgaWYgKGkuaW5zZXJ0KSBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbSA9IHZub2RlLmVsbSA9IGFwaS5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlLmVsbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSksIGJlZm9yZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sodm5vZGUpIHtcbiAgICB2YXIgaSwgaiwgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIGkodm5vZGUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgaSwgbGlzdGVuZXJzLCBybSwgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2guc2VsKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKGNoLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkgY2JzLnJlbW92ZVtpXShjaCwgcm0pO1xuICAgICAgICAgIGlmIChpc0RlZihpID0gY2guZGF0YSkgJiYgaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgICAgaShjaCwgcm0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgYXBpLnJlbW92ZUNoaWxkKHBhcmVudEVsbSwgY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwLCBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIGJlZm9yZTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWR4SW5PbGQgPSBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV07XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGFwaS5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBlbG1Ub01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgYmVmb3JlID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHgrMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCsxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgdmFyIGksIGhvb2s7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhKSAmJiBpc0RlZihob29rID0gaS5ob29rKSAmJiBpc0RlZihpID0gaG9vay5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbSwgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbiwgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSByZXR1cm47XG4gICAgaWYgKCFzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgdmFyIHBhcmVudEVsbSA9IGFwaS5wYXJlbnROb2RlKG9sZFZub2RlLmVsbSk7XG4gICAgICBlbG0gPSBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBhcGkuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtLCBvbGRWbm9kZS5lbG0pO1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7XG4gICAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGFwaS5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucG9zdHBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgaSwgZWxtLCBwYXJlbnQ7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucHJlLmxlbmd0aDsgKytpKSBjYnMucHJlW2ldKCk7XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5zZWwpKSB7XG4gICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICBwYXJlbnQgPSBhcGkucGFyZW50Tm9kZShlbG0pO1xuXG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cbiAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYXBpLmluc2VydEJlZm9yZShwYXJlbnQsIHZub2RlLmVsbSwgYXBpLm5leHRTaWJsaW5nKGVsbSkpO1xuICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50LCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWVbaV0uZGF0YS5ob29rLmluc2VydChpbnNlcnRlZFZub2RlUXVldWVbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnBvc3QubGVuZ3RoOyArK2kpIGNicy5wb3N0W2ldKCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtpbml0OiBpbml0fTtcbiIsInZhciBWTm9kZSA9IHJlcXVpcmUoJy4vdm5vZGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuZnVuY3Rpb24gYWRkTlMoZGF0YSwgY2hpbGRyZW4sIHNlbCkge1xuICBkYXRhLm5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuICBpZiAoc2VsICE9PSAnZm9yZWlnbk9iamVjdCcgJiYgY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFkZE5TKGNoaWxkcmVuW2ldLmRhdGEsIGNoaWxkcmVuW2ldLmNoaWxkcmVuLCBjaGlsZHJlbltpXS5zZWwpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGgoc2VsLCBiLCBjKSB7XG4gIHZhciBkYXRhID0ge30sIGNoaWxkcmVuLCB0ZXh0LCBpO1xuICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0YSA9IGI7XG4gICAgaWYgKGlzLmFycmF5KGMpKSB7IGNoaWxkcmVuID0gYzsgfVxuICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShjKSkgeyB0ZXh0ID0gYzsgfVxuICB9IGVsc2UgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpcy5hcnJheShiKSkgeyBjaGlsZHJlbiA9IGI7IH1cbiAgICBlbHNlIGlmIChpcy5wcmltaXRpdmUoYikpIHsgdGV4dCA9IGI7IH1cbiAgICBlbHNlIHsgZGF0YSA9IGI7IH1cbiAgfVxuICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaXMucHJpbWl0aXZlKGNoaWxkcmVuW2ldKSkgY2hpbGRyZW5baV0gPSBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWxbMF0gPT09ICdzJyAmJiBzZWxbMV0gPT09ICd2JyAmJiBzZWxbMl0gPT09ICdnJykge1xuICAgIGFkZE5TKGRhdGEsIGNoaWxkcmVuLCBzZWwpO1xuICB9XG4gIHJldHVybiBWTm9kZShzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCB1bmRlZmluZWQpO1xufTtcbiIsImZ1bmN0aW9uIHVwZGF0ZUNsYXNzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgY3VyLCBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRDbGFzcyA9IG9sZFZub2RlLmRhdGEuY2xhc3MsXG4gICAgICBrbGFzcyA9IHZub2RlLmRhdGEuY2xhc3M7XG5cbiAgaWYgKCFvbGRDbGFzcyAmJiAha2xhc3MpIHJldHVybjtcbiAgb2xkQ2xhc3MgPSBvbGRDbGFzcyB8fCB7fTtcbiAga2xhc3MgPSBrbGFzcyB8fCB7fTtcblxuICBmb3IgKG5hbWUgaW4gb2xkQ2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzW25hbWVdKSB7XG4gICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIGtsYXNzKSB7XG4gICAgY3VyID0ga2xhc3NbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkQ2xhc3NbbmFtZV0pIHtcbiAgICAgIGVsbS5jbGFzc0xpc3RbY3VyID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlQ2xhc3MsIHVwZGF0ZTogdXBkYXRlQ2xhc3N9O1xuIiwiZnVuY3Rpb24gdXBkYXRlUHJvcHMob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEucHJvcHMsIHByb3BzID0gdm5vZGUuZGF0YS5wcm9wcztcblxuICBpZiAoIW9sZFByb3BzICYmICFwcm9wcykgcmV0dXJuO1xuICBvbGRQcm9wcyA9IG9sZFByb3BzIHx8IHt9O1xuICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKCFwcm9wc1trZXldKSB7XG4gICAgICBkZWxldGUgZWxtW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICBvbGQgPSBvbGRQcm9wc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1ciAmJiAoa2V5ICE9PSAndmFsdWUnIHx8IGVsbVtrZXldICE9PSBjdXIpKSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVQcm9wcywgdXBkYXRlOiB1cGRhdGVQcm9wc307XG4iLCJ2YXIgcmFmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24oZm4pIHsgcmFmKGZ1bmN0aW9uKCkgeyByYWYoZm4pOyB9KTsgfTtcblxuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gIG5leHRGcmFtZShmdW5jdGlvbigpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZFN0eWxlID0gb2xkVm5vZGUuZGF0YS5zdHlsZSxcbiAgICAgIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZTtcblxuICBpZiAoIW9sZFN0eWxlICYmICFzdHlsZSkgcmV0dXJuO1xuICBvbGRTdHlsZSA9IG9sZFN0eWxlIHx8IHt9O1xuICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICB2YXIgb2xkSGFzRGVsID0gJ2RlbGF5ZWQnIGluIG9sZFN0eWxlO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmICghc3R5bGVbbmFtZV0pIHtcbiAgICAgIGVsbS5zdHlsZVtuYW1lXSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBjdXIgPSBzdHlsZVtuYW1lXTtcbiAgICBpZiAobmFtZSA9PT0gJ2RlbGF5ZWQnKSB7XG4gICAgICBmb3IgKG5hbWUgaW4gc3R5bGUuZGVsYXllZCkge1xuICAgICAgICBjdXIgPSBzdHlsZS5kZWxheWVkW25hbWVdO1xuICAgICAgICBpZiAoIW9sZEhhc0RlbCB8fCBjdXIgIT09IG9sZFN0eWxlLmRlbGF5ZWRbbmFtZV0pIHtcbiAgICAgICAgICBzZXROZXh0RnJhbWUoZWxtLnN0eWxlLCBuYW1lLCBjdXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICE9PSAncmVtb3ZlJyAmJiBjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICBlbG0uc3R5bGVbbmFtZV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVzdHJveVN0eWxlKHZub2RlKSB7XG4gIHZhciBzdHlsZSwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBzID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgaWYgKCFzIHx8ICEoc3R5bGUgPSBzLmRlc3Ryb3kpKSByZXR1cm47XG4gIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgIGVsbS5zdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVtb3ZlU3R5bGUodm5vZGUsIHJtKSB7XG4gIHZhciBzID0gdm5vZGUuZGF0YS5zdHlsZTtcbiAgaWYgKCFzIHx8ICFzLnJlbW92ZSkge1xuICAgIHJtKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lLCBlbG0gPSB2bm9kZS5lbG0sIGlkeCwgaSA9IDAsIG1heER1ciA9IDAsXG4gICAgICBjb21wU3R5bGUsIHN0eWxlID0gcy5yZW1vdmUsIGFtb3VudCA9IDAsIGFwcGxpZWQgPSBbXTtcbiAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgYXBwbGllZC5wdXNoKG5hbWUpO1xuICAgIGVsbS5zdHlsZVtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICB9XG4gIGNvbXBTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxtKTtcbiAgdmFyIHByb3BzID0gY29tcFN0eWxlWyd0cmFuc2l0aW9uLXByb3BlcnR5J10uc3BsaXQoJywgJyk7XG4gIGZvciAoOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihhcHBsaWVkLmluZGV4T2YocHJvcHNbaV0pICE9PSAtMSkgYW1vdW50Kys7XG4gIH1cbiAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbihldikge1xuICAgIGlmIChldi50YXJnZXQgPT09IGVsbSkgLS1hbW91bnQ7XG4gICAgaWYgKGFtb3VudCA9PT0gMCkgcm0oKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlU3R5bGUsIHVwZGF0ZTogdXBkYXRlU3R5bGUsIGRlc3Ryb3k6IGFwcGx5RGVzdHJveVN0eWxlLCByZW1vdmU6IGFwcGx5UmVtb3ZlU3R5bGV9O1xuIiwiZnVuY3Rpb24gaW52b2tlSGFuZGxlcihoYW5kbGVyLCB2bm9kZSwgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBjYWxsIGZ1bmN0aW9uIGhhbmRsZXJcbiAgICBoYW5kbGVyLmNhbGwodm5vZGUsIGV2ZW50LCB2bm9kZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBjYWxsIGhhbmRsZXIgd2l0aCBhcmd1bWVudHNcbiAgICBpZiAodHlwZW9mIGhhbmRsZXJbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBzaW5nbGUgYXJndW1lbnQgZm9yIHBlcmZvcm1hbmNlXG4gICAgICBpZiAoaGFuZGxlci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaGFuZGxlclswXS5jYWxsKHZub2RlLCBoYW5kbGVyWzFdLCBldmVudCwgdm5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBoYW5kbGVyLnNsaWNlKDEpO1xuICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuICAgICAgICBhcmdzLnB1c2godm5vZGUpO1xuICAgICAgICBoYW5kbGVyWzBdLmFwcGx5KHZub2RlLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FsbCBtdWx0aXBsZSBoYW5kbGVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludm9rZUhhbmRsZXIoaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50LCB2bm9kZSkge1xuICB2YXIgbmFtZSA9IGV2ZW50LnR5cGUsXG4gICAgICBvbiA9IHZub2RlLmRhdGEub247XG5cbiAgLy8gY2FsbCBldmVudCBoYW5kbGVyKHMpIGlmIGV4aXN0c1xuICBpZiAob24gJiYgb25bbmFtZV0pIHtcbiAgICBpbnZva2VIYW5kbGVyKG9uW25hbWVdLCB2bm9kZSwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50LCBoYW5kbGVyLnZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVFdmVudExpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbixcbiAgICAgIG9sZExpc3RlbmVyID0gb2xkVm5vZGUubGlzdGVuZXIsXG4gICAgICBvbGRFbG0gPSBvbGRWbm9kZS5lbG0sXG4gICAgICBvbiA9IHZub2RlICYmIHZub2RlLmRhdGEub24sXG4gICAgICBlbG0gPSB2bm9kZSAmJiB2bm9kZS5lbG0sXG4gICAgICBuYW1lO1xuXG4gIC8vIG9wdGltaXphdGlvbiBmb3IgcmV1c2VkIGltbXV0YWJsZSBoYW5kbGVyc1xuICBpZiAob2xkT24gPT09IG9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGV4aXN0aW5nIGxpc3RlbmVycyB3aGljaCBubyBsb25nZXIgdXNlZFxuICBpZiAob2xkT24gJiYgb2xkTGlzdGVuZXIpIHtcbiAgICAvLyBpZiBlbGVtZW50IGNoYW5nZWQgb3IgZGVsZXRlZCB3ZSByZW1vdmUgYWxsIGV4aXN0aW5nIGxpc3RlbmVycyB1bmNvbmRpdGlvbmFsbHlcbiAgICBpZiAoIW9uKSB7XG4gICAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIGlmIGVsZW1lbnQgd2FzIGNoYW5nZWQgb3IgZXhpc3RpbmcgbGlzdGVuZXJzIHJlbW92ZWRcbiAgICAgICAgb2xkRWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgb2xkTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciBpZiBleGlzdGluZyBsaXN0ZW5lciByZW1vdmVkXG4gICAgICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgICAgICBvbGRFbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBvbGRMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIG5ldyBsaXN0ZW5lcnMgd2hpY2ggaGFzIG5vdCBhbHJlYWR5IGF0dGFjaGVkXG4gIGlmIChvbikge1xuICAgIC8vIHJldXNlIGV4aXN0aW5nIGxpc3RlbmVyIG9yIGNyZWF0ZSBuZXdcbiAgICB2YXIgbGlzdGVuZXIgPSB2bm9kZS5saXN0ZW5lciA9IG9sZFZub2RlLmxpc3RlbmVyIHx8IGNyZWF0ZUxpc3RlbmVyKCk7XG4gICAgLy8gdXBkYXRlIHZub2RlIGZvciBsaXN0ZW5lclxuICAgIGxpc3RlbmVyLnZub2RlID0gdm5vZGU7XG5cbiAgICAvLyBpZiBlbGVtZW50IGNoYW5nZWQgb3IgYWRkZWQgd2UgYWRkIGFsbCBuZWVkZWQgbGlzdGVuZXJzIHVuY29uZGl0aW9uYWxseVxuICAgIGlmICghb2xkT24pIHtcbiAgICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgICAvLyBhZGQgbGlzdGVuZXIgaWYgZWxlbWVudCB3YXMgY2hhbmdlZCBvciBuZXcgbGlzdGVuZXJzIGFkZGVkXG4gICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgICAvLyBhZGQgbGlzdGVuZXIgaWYgbmV3IGxpc3RlbmVyIGFkZGVkXG4gICAgICAgIGlmICghb2xkT25bbmFtZV0pIHtcbiAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUV2ZW50TGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZUV2ZW50TGlzdGVuZXJzLFxuICBkZXN0cm95OiB1cGRhdGVFdmVudExpc3RlbmVyc1xufTtcbiIsImltcG9ydCBzbmFiYmRvbSBmcm9tICdzbmFiYmRvbS9zbmFiYmRvbS5qcydcbmltcG9ydCBoIGZyb20gJ3NuYWJiZG9tL2guanMnXG5pbXBvcnQgc25hYkNsYXNzIGZyb20gJ3NuYWJiZG9tL21vZHVsZXMvY2xhc3MuanMnXG5pbXBvcnQgc25hYlByb3BzIGZyb20gJ3NuYWJiZG9tL21vZHVsZXMvcHJvcHMuanMnXG5pbXBvcnQgc25hYlN0eWxlIGZyb20gJ3NuYWJiZG9tL21vZHVsZXMvc3R5bGUuanMnXG5pbXBvcnQgc25hYkV2ZW50IGZyb20gJ3NuYWJiZG9tL21vZHVsZXMvZXZlbnRsaXN0ZW5lcnMuanMnXG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0h5cGVyU2NyaXB0KG5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBsZXQgW3NlbCwgZGF0YSwgY2hpbGRyZW5dID0gbm9kZVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICByZXR1cm4gaChzZWwsIGRhdGEsIGNoaWxkcmVuLm1hcChjb252ZXJ0VG9IeXBlclNjcmlwdCkpXG4gICAgfVxuICAgIHJldHVybiBoLmFwcGx5KG51bGwsIG5vZGUpXG4gIH1cbiAgcmV0dXJuIG5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2aWV3JCwgY29udGFpbmVyKSB7XG4gIGxldCBwYXRjaCA9IHNuYWJiZG9tLmluaXQoW3NuYWJDbGFzcywgc25hYlByb3BzLCBzbmFiU3R5bGUsIHNuYWJFdmVudF0pXG4gIGxldCB2bm9kZSA9IGNvbnRhaW5lclxuXG4gIHZpZXckXG4gICAgLm1hcChjb252ZXJ0VG9IeXBlclNjcmlwdClcbiAgICAuc3Vic2NyaWJlKG5ld1Zub2RlID0+IHtcbiAgICAgIHBhdGNoKHZub2RlLCBuZXdWbm9kZSlcbiAgICAgIHZub2RlID0gbmV3Vm5vZGVcbiAgICB9KVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNXZWJTb2NrZXQgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuQ0xPU0lORyA9PT0gMjtcbn07XG52YXIgaXNHbG9iYWxXZWJTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnICYmIGlzV2ViU29ja2V0KFdlYlNvY2tldCk7XG59O1xudmFyIGdldERlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBjb25zdHJ1Y3RvcjogaXNHbG9iYWxXZWJTb2NrZXQoKSA/IFdlYlNvY2tldCA6IG51bGwsXG4gICAgbWF4UmVjb25uZWN0aW9uRGVsYXk6IDEwMDAwLFxuICAgIG1pblJlY29ubmVjdGlvbkRlbGF5OiAxNTAwLFxuICAgIHJlY29ubmVjdGlvbkRlbGF5R3Jvd0ZhY3RvcjogMS4zLFxuICAgIGNvbm5lY3Rpb25UaW1lb3V0OiA0MDAwLFxuICAgIG1heFJldHJpZXM6IEluZmluaXR5LFxuICAgIGRlYnVnOiBmYWxzZSxcbn0pOyB9O1xudmFyIGJ5cGFzc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHNyYywgZHN0LCBuYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRzdCwgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNyY1tuYW1lXTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgc3JjW25hbWVdID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn07XG52YXIgaW5pdFJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHJldHVybiAoY29uZmlnLm1pblJlY29ubmVjdGlvbkRlbGF5ICsgTWF0aC5yYW5kb20oKSAqIGNvbmZpZy5taW5SZWNvbm5lY3Rpb25EZWxheSk7XG59O1xudmFyIHVwZGF0ZVJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24gKGNvbmZpZywgcHJldmlvdXNEZWxheSkge1xuICAgIHZhciBuZXdEZWxheSA9IHByZXZpb3VzRGVsYXkgKiBjb25maWcucmVjb25uZWN0aW9uRGVsYXlHcm93RmFjdG9yO1xuICAgIHJldHVybiAobmV3RGVsYXkgPiBjb25maWcubWF4UmVjb25uZWN0aW9uRGVsYXkpXG4gICAgICAgID8gY29uZmlnLm1heFJlY29ubmVjdGlvbkRlbGF5XG4gICAgICAgIDogbmV3RGVsYXk7XG59O1xudmFyIExFVkVMXzBfRVZFTlRTID0gWydvbm9wZW4nLCAnb25jbG9zZScsICdvbm1lc3NhZ2UnLCAnb25lcnJvciddO1xudmFyIHJlYXNzaWduRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAod3MsIG9sZFdzLCBsaXN0ZW5lcnMpIHtcbiAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgbGlzdGVuZXJzW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfYVswXSwgb3B0aW9ucyA9IF9hWzFdO1xuICAgICAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChvbGRXcykge1xuICAgICAgICBMRVZFTF8wX0VWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHdzW25hbWVdID0gb2xkV3NbbmFtZV07IH0pO1xuICAgIH1cbn07XG52YXIgUmVjb25uZWN0aW5nV2Vic29ja2V0ID0gZnVuY3Rpb24gKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciB3cztcbiAgICB2YXIgY29ubmVjdGluZ1RpbWVvdXQ7XG4gICAgdmFyIHJlY29ubmVjdERlbGF5ID0gMDtcbiAgICB2YXIgcmV0cmllc0NvdW50ID0gMDtcbiAgICB2YXIgc2hvdWxkUmV0cnkgPSB0cnVlO1xuICAgIHZhciBzYXZlZE9uQ2xvc2UgPSBudWxsO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgICAvLyByZXF1aXJlIG5ldyB0byBjb25zdHJ1Y3RcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb25uZWN0aW5nV2Vic29ja2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVjb25uZWN0aW5nV2ViU29ja2V0JzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3JcIik7XG4gICAgfVxuICAgIC8vIFNldCBjb25maWcuIE5vdCB1c2luZyBgT2JqZWN0LmFzc2lnbmAgYmVjYXVzZSBvZiBJRTExXG4gICAgdmFyIGNvbmZpZyA9IGdldERlZmF1bHRPcHRpb25zKCk7XG4gICAgT2JqZWN0LmtleXMoY29uZmlnKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KTsgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29uZmlnW2tleV0gPSBvcHRpb25zW2tleV07IH0pO1xuICAgIGlmICghaXNXZWJTb2NrZXQoY29uZmlnLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci4gU2V0IGBvcHRpb25zLmNvbnN0cnVjdG9yYCcpO1xuICAgIH1cbiAgICB2YXIgbG9nID0gY29uZmlnLmRlYnVnID8gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFsnUldTOiddLmNvbmNhdChwYXJhbXMpKTtcbiAgICB9IDogZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIE5vdCB1c2luZyBkaXNwYXRjaEV2ZW50LCBvdGhlcndpc2Ugd2UgbXVzdCB1c2UgYSBET00gRXZlbnQgb2JqZWN0XG4gICAgICogRGVmZXJyZWQgYmVjYXVzZSB3ZSB3YW50IHRvIGhhbmRsZSB0aGUgY2xvc2UgZXZlbnQgYmVmb3JlIHRoaXNcbiAgICAgKi9cbiAgICB2YXIgZW1pdEVycm9yID0gZnVuY3Rpb24gKGNvZGUsIG1zZykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgZXJyLmNvZGUgPSBjb2RlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMuZXJyb3IpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZXJyb3IuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBfYVswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cy5vbmVycm9yKSB7XG4gICAgICAgICAgICB3cy5vbmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9LCAwKTsgfTtcbiAgICB2YXIgaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZygnY2xvc2UnKTtcbiAgICAgICAgcmV0cmllc0NvdW50Kys7XG4gICAgICAgIGxvZygncmV0cmllcyBjb3VudDonLCByZXRyaWVzQ291bnQpO1xuICAgICAgICBpZiAocmV0cmllc0NvdW50ID4gY29uZmlnLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcignRUhPU1RET1dOJywgJ1RvbyBtYW55IGZhaWxlZCBjb25uZWN0aW9uIGF0dGVtcHRzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWNvbm5lY3REZWxheSkge1xuICAgICAgICAgICAgcmVjb25uZWN0RGVsYXkgPSBpbml0UmVjb25uZWN0aW9uRGVsYXkoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gdXBkYXRlUmVjb25uZWN0aW9uRGVsYXkoY29uZmlnLCByZWNvbm5lY3REZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdyZWNvbm5lY3REZWxheTonLCByZWNvbm5lY3REZWxheSk7XG4gICAgICAgIGlmIChzaG91bGRSZXRyeSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjb25uZWN0LCByZWNvbm5lY3REZWxheSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2coJ2Nvbm5lY3QnKTtcbiAgICAgICAgdmFyIG9sZFdzID0gd3M7XG4gICAgICAgIHdzID0gbmV3IGNvbmZpZy5jb25zdHJ1Y3Rvcih1cmwsIHByb3RvY29scyk7XG4gICAgICAgIGNvbm5lY3RpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2coJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgICAgICBlbWl0RXJyb3IoJ0VUSU1FRE9VVCcsICdDb25uZWN0aW9uIHRpbWVvdXQnKTtcbiAgICAgICAgfSwgY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgbG9nKCdieXBhc3MgcHJvcGVydGllcycpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gd3MpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIG1vdmUgdG8gY29uc3RhbnRcbiAgICAgICAgICAgIGlmIChbJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsICdjbG9zZScsICdzZW5kJ10uaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIGJ5cGFzc1Byb3BlcnR5KHdzLCBfdGhpcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3cy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3RpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgIGxvZygnb3BlbicpO1xuICAgICAgICAgICAgcmVjb25uZWN0RGVsYXkgPSBpbml0UmVjb25uZWN0aW9uRGVsYXkoY29uZmlnKTtcbiAgICAgICAgICAgIGxvZygncmVjb25uZWN0RGVsYXk6JywgcmVjb25uZWN0RGVsYXkpO1xuICAgICAgICAgICAgcmV0cmllc0NvdW50ID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICByZWFzc2lnbkV2ZW50TGlzdGVuZXJzKHdzLCBvbGRXcywgbGlzdGVuZXJzKTtcbiAgICAgICAgLy8gYmVjYXVzZSB3aGVuIGNsb3Npbmcgd2l0aCBmYXN0Q2xvc2U9dHJ1ZSwgaXQgaXMgc2F2ZWQgYW5kIHNldCB0byBudWxsIHRvIGF2b2lkIGRvdWJsZSBjYWxsc1xuICAgICAgICB3cy5vbmNsb3NlID0gd3Mub25jbG9zZSB8fCBzYXZlZE9uQ2xvc2U7XG4gICAgICAgIHNhdmVkT25DbG9zZSA9IG51bGw7XG4gICAgfTtcbiAgICBsb2coJ2luaXQnKTtcbiAgICBjb25uZWN0KCk7XG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24sIF9hKSB7XG4gICAgICAgIGlmIChjb2RlID09PSB2b2lkIDApIHsgY29kZSA9IDEwMDA7IH1cbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7IHJlYXNvbiA9ICcnOyB9XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmtlZXBDbG9zZWQsIGtlZXBDbG9zZWQgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYi5mYXN0Q2xvc2UsIGZhc3RDbG9zZSA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIF9lID0gX2IuZGVsYXksIGRlbGF5ID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZTtcbiAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IGRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHNob3VsZFJldHJ5ID0gIWtlZXBDbG9zZWQ7XG4gICAgICAgIHdzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIGlmIChmYXN0Q2xvc2UpIHtcbiAgICAgICAgICAgIHZhciBmYWtlQ2xvc2VFdmVudF8xID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgd2FzQ2xlYW46IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXhlY3V0ZSBjbG9zZSBsaXN0ZW5lcnMgc29vbiB3aXRoIGEgZmFrZSBjbG9zZUV2ZW50XG4gICAgICAgICAgICAvLyBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgV1MgaW5zdGFuY2Ugc28gdGhleVxuICAgICAgICAgICAgLy8gZG9uJ3QgZ2V0IGZpcmVkIG9uIHRoZSByZWFsIGNsb3NlLlxuICAgICAgICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICAgICAgICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgLy8gcnVuIGFuZCByZW1vdmUgbGV2ZWwyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMuY2xvc2UpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmNsb3NlLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9hWzBdLCBvcHRpb25zID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGZha2VDbG9zZUV2ZW50XzEpO1xuICAgICAgICAgICAgICAgICAgICB3cy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJ1biBhbmQgcmVtb3ZlIGxldmVsMFxuICAgICAgICAgICAgaWYgKHdzLm9uY2xvc2UpIHtcbiAgICAgICAgICAgICAgICBzYXZlZE9uQ2xvc2UgPSB3cy5vbmNsb3NlO1xuICAgICAgICAgICAgICAgIHdzLm9uY2xvc2UoZmFrZUNsb3NlRXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgd3Mub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHdzLnNlbmQoZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzW3R5cGVdKSkge1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnNbdHlwZV0uc29tZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IF9hWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBsID09PSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW3R5cGVdLnB1c2goW2xpc3RlbmVyLCBvcHRpb25zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBbW2xpc3RlbmVyLCBvcHRpb25zXV07XG4gICAgICAgIH1cbiAgICAgICAgd3MuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGVuZXJzW3R5cGVdKSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJzW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IF9hWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBSZWNvbm5lY3RpbmdXZWJzb2NrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogd2luZG93OiBicm93c2VyIGluIERPTSBtYWluIHRocmVhZFxuICogc2VsZjogYnJvd3NlciBpbiBXZWJXb3JrZXJcbiAqIGdsb2JhbDogTm9kZS5qcy9vdGhlclxuICovXG5leHBvcnRzLnJvb3QgPSAodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cud2luZG93ID09PSB3aW5kb3cgJiYgd2luZG93XG4gICAgfHwgdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGZcbiAgICB8fCB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwpO1xuaWYgKCFleHBvcnRzLnJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1J4SlMgY291bGQgbm90IGZpbmQgYW55IGdsb2JhbCBjb250ZXh0ICh3aW5kb3csIHNlbGYsIGdsb2JhbCknKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gdHlwZW9mIGFueSBzbyB0aGF0IGl0IHdlIGRvbid0IGhhdmUgdG8gY2FzdCB3aGVuIGNvbXBhcmluZyBhIHJlc3VsdCB0byB0aGUgZXJyb3Igb2JqZWN0XG5leHBvcnRzLmVycm9yT2JqZWN0ID0geyBlOiB7fSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vZXJyb3JPYmplY3QnKTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIG9uZSBvciBtb3JlIGVycm9ycyBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGVcbiAqIGB1bnN1YnNjcmliZWAgb2YgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufS5cbiAqL1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmlwdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgZXJyb3JzID9cbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcbiAgXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHsgcmV0dXJuICgoaSArIDEpICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCkpOyB9KS5qb2luKCdcXG4gICcpIDogJycpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbnN1YnNjcmlwdGlvbkVycm9yID0gVW5zdWJzY3JpcHRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2lzT2JqZWN0Jyk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlLCBzdWNoIGFzIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZS4gQVxuICogU3Vic2NyaXB0aW9uIGhhcyBvbmUgaW1wb3J0YW50IG1ldGhvZCwgYHVuc3Vic2NyaWJlYCwgdGhhdCB0YWtlcyBubyBhcmd1bWVudFxuICogYW5kIGp1c3QgZGlzcG9zZXMgdGhlIHJlc291cmNlIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHN1YnNjcmlwdGlvbnMgbWF5IGJlIGdyb3VwZWQgdG9nZXRoZXIgdGhyb3VnaCB0aGUgYGFkZCgpYFxuICogbWV0aG9kLCB3aGljaCB3aWxsIGF0dGFjaCBhIGNoaWxkIFN1YnNjcmlwdGlvbiB0byB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24uXG4gKiBXaGVuIGEgU3Vic2NyaXB0aW9uIGlzIHVuc3Vic2NyaWJlZCwgYWxsIGl0cyBjaGlsZHJlbiAoYW5kIGl0cyBncmFuZGNoaWxkcmVuKVxuICogd2lsbCBiZSB1bnN1YnNjcmliZWQgYXMgd2VsbC5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXG4gKi9cbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW3Vuc3Vic2NyaWJlXSBBIGZ1bmN0aW9uIGRlc2NyaWJpbmcgaG93IHRvXG4gICAgICogcGVyZm9ybSB0aGUgZGlzcG9zYWwgb2YgcmVzb3VyY2VzIHdoZW4gdGhlIGB1bnN1YnNjcmliZWAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgU3Vic2NyaXB0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdW5zdWJzY3JpYmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSwgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgKGVycm9ycyA9IGVycm9ycyB8fCBbXSkucHVzaChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc3ViLnVuc3Vic2NyaWJlKS5jYWxsKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRlYXIgZG93biB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSgpIG9mIHRoaXNcbiAgICAgKiBTdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGVhciBkb3duIGJlaW5nIGFkZGVkIGlzIGEgc3Vic2NyaXB0aW9uIHRoYXQgaXMgYWxyZWFkeVxuICAgICAqIHVuc3Vic2NyaWJlZCwgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGBhZGRgIGlzIGJlaW5nIGNhbGxlZCBvbiwgb3IgaXNcbiAgICAgKiBgU3Vic2NyaXB0aW9uLkVNUFRZYCwgaXQgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHN1YnNjcmlwdGlvbiBpcyBhbHJlYWR5IGluIGFuIGBjbG9zZWRgIHN0YXRlLCB0aGUgcGFzc2VkXG4gICAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RlYXJkb3duTG9naWN9IHRlYXJkb3duIFRoZSBhZGRpdGlvbmFsIGxvZ2ljIHRvIGV4ZWN1dGUgb25cbiAgICAgKiB0ZWFyZG93bi5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IFJldHVybnMgdGhlIFN1YnNjcmlwdGlvbiB1c2VkIG9yIGNyZWF0ZWQgdG8gYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgaW5uZXIgc3Vic2NyaXB0aW9ucyBsaXN0LiBUaGlzIFN1YnNjcmlwdGlvbiBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICogbGlzdC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICBpZiAoIXRlYXJkb3duIHx8ICh0ZWFyZG93biA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVhcmRvd24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWIgPSB0ZWFyZG93bjtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5jbG9zZWQgfHwgdHlwZW9mIHN1Yi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKSkucHVzaChzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgICAqIHVuc3Vic2NyaWJlIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUgcHJvY2VzcyBvZiB0aGlzIFN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIEhBQ0s6IFRoaXMgbWlnaHQgYmUgcmVkdW5kYW50IGJlY2F1c2Ugb2YgdGhlIGxvZ2ljIGluIGBhZGQoKWBcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsIHx8IChzdWJzY3JpcHRpb24gPT09IHRoaXMpIHx8IChzdWJzY3JpcHRpb24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgU3ltYm9sID0gcm9vdF8xLnJvb3QuU3ltYm9sO1xuZXhwb3J0cy4kJHJ4U3Vic2NyaWJlciA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSA/XG4gICAgU3ltYm9sLmZvcigncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnhTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnQsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQudW5zdWJzY3JpYmUuYmluZChjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnVuc3Vic2NyaWJlID0gdGhpcy51bnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLl9uZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudCwgdGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclVuc3ViID0gZnVuY3Rpb24gKGZuLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgX3BhcmVudC51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2ZXInKTtcbmZ1bmN0aW9uIHRvU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciBpbnN0YW5jZW9mIFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKE9ic2VydmVyXzEuZW1wdHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBnZXRTeW1ib2xPYnNlcnZhYmxlKGNvbnRleHQpIHtcbiAgICB2YXIgJCRvYnNlcnZhYmxlO1xuICAgIHZhciBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiAkJG9ic2VydmFibGU7XG59XG5leHBvcnRzLmdldFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlO1xuZXhwb3J0cy4kJG9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuX3N1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZm9yRWFjaFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgYSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcGFyYW0ge1Byb21pc2VDb25zdHJ1Y3Rvcn0gW1Byb21pc2VDdG9yXSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIFByb21pc2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBlaXRoZXIgcmVzb2x2ZXMgb24gb2JzZXJ2YWJsZSBjb21wbGV0aW9uIG9yXG4gICAgICogIHJlamVjdHMgd2l0aCB0aGUgaGFuZGxlZCBlcnJvclxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgaWYgKHJvb3RfMS5yb290LlJ4ICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZyAmJiByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzY3JpcHRpb24sIHRoZW4gd2UgY2FuIHN1cm1pc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgaGFuZGxpbmcgaXMgYXN5bmNocm9ub3VzLiBBbnkgZXJyb3JzIHRocm93blxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGJlIHJlamVjdGVkIGV4cGxpY2l0bHkgYW5kIHVuc3Vic2NyaWJlIG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBOTyBzdWJzY3JpcHRpb24sIHRoZW4gd2UncmUgZ2V0dGluZyBhIG5leHRlZFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBzeW5jaHJvbm91c2x5IGR1cmluZyBzdWJzY3JpcHRpb24uIFdlIGNhbiBqdXN0IGNhbGwgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGVycm9ycywgT2JzZXJ2YWJsZSdzIGBzdWJzY3JpYmVgIHdpbGwgZW5zdXJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmlwdGlvbiBsb2dpYyBpcyBjYWxsZWQsIHRoZW4gc3luY2hyb25vdXNseSByZXRocm93IHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgdGhhdCwgUHJvbWlzZSB3aWxsIHRyYXAgdGhlIGVycm9yIGFuZCBzZW5kIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdGhlIHJlamVjdGlvbiBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJvcCBwb2ludCBkZWZpbmVkIGJ5IHRoZSBlczctb2JzZXJ2YWJsZSBzcGVjIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhpcyBpbnN0YW5jZSBvZiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIEhBQ0s6IFNpbmNlIFR5cGVTY3JpcHQgaW5oZXJpdHMgc3RhdGljIHByb3BlcnRpZXMgdG9vLCB3ZSBoYXZlIHRvXG4gICAgLy8gZmlnaHQgYWdhaW5zdCBUeXBlU2NyaXB0IGhlcmUgc28gU3ViamVjdCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBzdGF0aWMgY3JlYXRlIHNpZ25hdHVyZVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sZCBPYnNlcnZhYmxlIGJ5IGNhbGxpbmcgdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlPyB0aGUgc3Vic2NyaWJlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBjb2xkIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgaW52YWxpZCBiZWNhdXNlIHRoZSBvYmplY3QgaGFzIGJlZW5cbiAqIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBTdWJqZWN0fVxuICogQHNlZSB7QGxpbmsgQmVoYXZpb3JTdWJqZWN0fVxuICpcbiAqIEBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvclxuICovXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RVbnN1YnNjcmliZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdvYmplY3QgdW5zdWJzY3JpYmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3ViamVjdFN1YnNjcmlwdGlvbicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0U3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3ViamVjdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaWJlciA9IFN1YmplY3RTdWJzY3JpYmVyO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdDxUPlxuICovXG52YXIgU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIFN1YmplY3QucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaWJlcih0aGlzKTtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5W2ldLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbl8xLlN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0O1xuLyoqXG4gKiBAY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPlxuICovXG52YXIgQW5vbnltb3VzU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5uZXh0KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbn0oU3ViamVjdCkpO1xuZXhwb3J0cy5Bbm9ueW1vdXNTdWJqZWN0ID0gQW5vbnltb3VzU3ViamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEBjbGFzcyBBc3luY1N1YmplY3Q8VD5cbiAqL1xudmFyIEFzeW5jU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1N1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmhhc05leHQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTmV4dCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jU3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuQXN5bmNTdWJqZWN0ID0gQXN5bmNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBBc3luY1N1YmplY3RfMSA9IHJlcXVpcmUoJy4uL0FzeW5jU3ViamVjdCcpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlKGNhbGxiYWNrRnVuYywgc2VsZWN0b3IsIGFyZ3MsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0Z1bmMgPSBjYWxsYmFja0Z1bmM7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjYWxsYmFjayBBUEkgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5HaXZlIGl0IGEgZnVuY3Rpb24gYGZgIG9mIHR5cGUgYGYoeCwgY2FsbGJhY2spYCBhbmRcbiAgICAgKiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIGBnYCB0aGF0IHdoZW4gY2FsbGVkIGFzIGBnKHgpYCB3aWxsIG91dHB1dCBhblxuICAgICAqIE9ic2VydmFibGUuPC9zcGFuPlxuICAgICAqXG4gICAgICogYGJpbmRDYWxsYmFja2AgaXMgbm90IGFuIG9wZXJhdG9yIGJlY2F1c2UgaXRzIGlucHV0IGFuZCBvdXRwdXQgYXJlIG5vdFxuICAgICAqIE9ic2VydmFibGVzLiBUaGUgaW5wdXQgaXMgYSBmdW5jdGlvbiBgZnVuY2Agd2l0aCBzb21lIHBhcmFtZXRlcnMsIGJ1dCB0aGVcbiAgICAgKiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBgZnVuY2AgY2FsbHMgd2hlbiBpdCBpc1xuICAgICAqIGRvbmUuIFRoZSBvdXRwdXQgb2YgYGJpbmRDYWxsYmFja2AgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzYW1lXG4gICAgICogcGFyYW1ldGVycyBhcyBgZnVuY2AsIGV4Y2VwdCB0aGUgbGFzdCBvbmUgKHRoZSBjYWxsYmFjaykuIFdoZW4gdGhlIG91dHB1dFxuICAgICAqIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50cywgaXQgd2lsbCByZXR1cm4gYW4gT2JzZXJ2YWJsZSB3aGVyZSB0aGVcbiAgICAgKiByZXN1bHRzIHdpbGwgYmUgZGVsaXZlcmVkIHRvLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBqUXVlcnkncyBnZXRKU09OIHRvIGFuIE9ic2VydmFibGUgQVBJPC9jYXB0aW9uPlxuICAgICAqIC8vIFN1cHBvc2Ugd2UgaGF2ZSBqUXVlcnkuZ2V0SlNPTignL215L3VybCcsIGNhbGxiYWNrKVxuICAgICAqIHZhciBnZXRKU09OQXNPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2soalF1ZXJ5LmdldEpTT04pO1xuICAgICAqIHZhciByZXN1bHQgPSBnZXRKU09OQXNPYnNlcnZhYmxlKCcvbXkvdXJsJyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgYmluZE5vZGVDYWxsYmFja31cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlXG4gICAgICogY2FsbGJhY2sgYW5kIG1hcHMgdGhvc2UgYSB2YWx1ZSB0byBlbWl0IG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBjYWxsYmFja3MuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24oLi4ucGFyYW1zOiAqKTogT2JzZXJ2YWJsZX0gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgICAqIE9ic2VydmFibGUgdGhhdCBkZWxpdmVycyB0aGUgc2FtZSB2YWx1ZXMgdGhlIGNhbGxiYWNrIHdvdWxkIGRlbGl2ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgYmluZENhbGxiYWNrXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZnVuYywgc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkgeyBzZWxlY3RvciA9IHVuZGVmaW5lZDsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRDYWxsYmFja09ic2VydmFibGUoZnVuYywgc2VsZWN0b3IsIGFyZ3MsIHNjaGVkdWxlcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBjYWxsYmFja0Z1bmMgPSB0aGlzLmNhbGxiYWNrRnVuYztcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdF8xLkFzeW5jU3ViamVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJBcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGhhbmRsZXJGbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNvdXJjZS5zZWxlY3Rvciwgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzEgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQocmVzdWx0XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QubmV4dChpbm5lckFyZ3MubGVuZ3RoID09PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gdXNlIG5hbWVkIGZ1bmN0aW9uIGluc3RhbmNlIHRvIGF2b2lkIGNsb3N1cmUuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5zb3VyY2UgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNhbGxiYWNrRnVuYykuYXBwbHkodGhpcywgYXJncy5jb25jYXQoaGFuZGxlcikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoQm91bmRDYWxsYmFja09ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHsgc291cmNlOiB0aGlzLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zb3VyY2UsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICB2YXIgY2FsbGJhY2tGdW5jID0gc291cmNlLmNhbGxiYWNrRnVuYywgYXJncyA9IHNvdXJjZS5hcmdzLCBzY2hlZHVsZXIgPSBzb3VyY2Uuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgIHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3RfMS5Bc3luY1N1YmplY3QoKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBoYW5kbGVyRm4uc291cmNlO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNvdXJjZS5zZWxlY3Rvciwgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEVycm9yLCAwLCB7IGVycjogZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHJlc3VsdF8yLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5uZXJBcmdzLmxlbmd0aCA9PT0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgaW4gd2l0aG91dCBjbG9zdXJlXG4gICAgICAgICAgICBoYW5kbGVyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNhbGxiYWNrRnVuYykuYXBwbHkodGhpcywgYXJncy5jb25jYXQoaGFuZGxlcikpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmFkZChzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRDYWxsYmFja09ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlID0gQm91bmRDYWxsYmFja09ic2VydmFibGU7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHZhbHVlID0gYXJnLnZhbHVlLCBzdWJqZWN0ID0gYXJnLnN1YmplY3Q7XG4gICAgc3ViamVjdC5uZXh0KHZhbHVlKTtcbiAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEVycm9yKGFyZykge1xuICAgIHZhciBlcnIgPSBhcmcuZXJyLCBzdWJqZWN0ID0gYXJnLnN1YmplY3Q7XG4gICAgc3ViamVjdC5lcnJvcihlcnIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm91bmRDYWxsYmFja09ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQm91bmRDYWxsYmFja09ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQm91bmRDYWxsYmFja09ic2VydmFibGUnKTtcbmV4cG9ydHMuYmluZENhbGxiYWNrID0gQm91bmRDYWxsYmFja09ic2VydmFibGVfMS5Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kQ2FsbGJhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJpbmRDYWxsYmFja18xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2snKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmJpbmRDYWxsYmFjayA9IGJpbmRDYWxsYmFja18xLmJpbmRDYWxsYmFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRDYWxsYmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgQXN5bmNTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9Bc3luY1N1YmplY3QnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZShjYWxsYmFja0Z1bmMsIHNlbGVjdG9yLCBhcmdzLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tGdW5jID0gY2FsbGJhY2tGdW5jO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFjayBBUEkgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW5cbiAgICAgKiBPYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MganVzdCBsaWtlIHtAbGluayBiaW5kQ2FsbGJhY2t9LCBidXQgdGhlXG4gICAgICogY2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClgLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIGBiaW5kTm9kZUNhbGxiYWNrYCBpcyBub3QgYW4gb3BlcmF0b3IgYmVjYXVzZSBpdHMgaW5wdXQgYW5kIG91dHB1dCBhcmUgbm90XG4gICAgICogT2JzZXJ2YWJsZXMuIFRoZSBpbnB1dCBpcyBhIGZ1bmN0aW9uIGBmdW5jYCB3aXRoIHNvbWUgcGFyYW1ldGVycywgYnV0IHRoZVxuICAgICAqIGxhc3QgcGFyYW1ldGVyIG11c3QgYmUgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGBmdW5jYCBjYWxscyB3aGVuIGl0IGlzXG4gICAgICogZG9uZS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIGZvbGxvdyBOb2RlLmpzIGNvbnZlbnRpb25zLFxuICAgICAqIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgaXMgYW4gZXJyb3IsIHdoaWxlIHJlbWFpbmluZ1xuICAgICAqIGFyZ3VtZW50cyBhcmUgdGhlIGNhbGxiYWNrIHJlc3VsdC4gVGhlIG91dHB1dCBvZiBgYmluZE5vZGVDYWxsYmFja2AgaXMgYVxuICAgICAqIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyBgZnVuY2AsIGV4Y2VwdCB0aGUgbGFzdCBvbmUgKHRoZVxuICAgICAqIGNhbGxiYWNrKS4gV2hlbiB0aGUgb3V0cHV0IGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50cywgaXQgd2lsbFxuICAgICAqIHJldHVybiBhbiBPYnNlcnZhYmxlIHdoZXJlIHRoZSByZXN1bHRzIHdpbGwgYmUgZGVsaXZlcmVkIHRvLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+UmVhZCBhIGZpbGUgZnJvbSB0aGUgZmlsZXN5c3RlbSBhbmQgZ2V0IHRoZSBkYXRhIGFzIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XG4gICAgICogaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuICAgICAqIHZhciByZWFkRmlsZUFzT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuYmluZE5vZGVDYWxsYmFjayhmcy5yZWFkRmlsZSk7XG4gICAgICogdmFyIHJlc3VsdCA9IHJlYWRGaWxlQXNPYnNlcnZhYmxlKCcuL3JvYWROYW1lcy50eHQnLCAndXRmOCcpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlXG4gICAgICogY2FsbGJhY2sgYW5kIG1hcHMgdGhvc2UgYSB2YWx1ZSB0byBlbWl0IG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICAgKiBjYWxsYmFja3MuXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24oLi4ucGFyYW1zOiAqKTogT2JzZXJ2YWJsZX0gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgICAqIE9ic2VydmFibGUgdGhhdCBkZWxpdmVycyB0aGUgc2FtZSB2YWx1ZXMgdGhlIE5vZGUuanMgY2FsbGJhY2sgd291bGRcbiAgICAgKiBkZWxpdmVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGJpbmROb2RlQ2FsbGJhY2tcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZnVuYywgc2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHZvaWQgMCkgeyBzZWxlY3RvciA9IHVuZGVmaW5lZDsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlKGZ1bmMsIHNlbGVjdG9yLCBhcmdzLCBzY2hlZHVsZXIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuYyA9IHRoaXMuY2FsbGJhY2tGdW5jO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QgPSB0aGlzLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyRm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyQXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gc291cmNlLnNlbGVjdG9yLCBzdWJqZWN0ID0gc291cmNlLnN1YmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KHJlc3VsdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQoaW5uZXJBcmdzLmxlbmd0aCA9PT0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiBpbnN0YW5jZSB0byBhdm9pZCBjbG9zdXJlLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuc291cmNlID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7IHNvdXJjZTogdGhpcywgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlID0gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlO1xuZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgLy8gWFhYOiBjYXN0IHRvIGBhbnlgIHRvIGFjY2VzcyB0byB0aGUgcHJpdmF0ZSBmaWVsZCBpbiBgc291cmNlYC5cbiAgICB2YXIgX2EgPSBzb3VyY2UsIGNhbGxiYWNrRnVuYyA9IF9hLmNhbGxiYWNrRnVuYywgYXJncyA9IF9hLmFyZ3MsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICB2YXIgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICBzdWJqZWN0ID0gc291cmNlLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKCkge1xuICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlID0gaGFuZGxlckZuLnNvdXJjZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNvdXJjZS5zZWxlY3Rvciwgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0O1xuICAgICAgICAgICAgdmFyIGVyciA9IGlubmVyQXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8yID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0XzIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogcmVzdWx0XzIsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlubmVyQXJncy5sZW5ndGggPT09IDEgPyBpbm5lckFyZ3NbMF0gOiBpbm5lckFyZ3M7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogdmFsdWUsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgaW4gd2l0aG91dCBjbG9zdXJlXG4gICAgICAgIGhhbmRsZXIuc291cmNlID0gc291cmNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGYuYWRkKHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIHN1YmplY3QuY29tcGxldGUoKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0LmVycm9yKGVycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0JvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5iaW5kTm9kZUNhbGxiYWNrID0gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlXzEuQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmROb2RlQ2FsbGJhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJpbmROb2RlQ2FsbGJhY2tfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjaycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuYmluZE5vZGVDYWxsYmFjayA9IGJpbmROb2RlQ2FsbGJhY2tfMS5iaW5kTm9kZUNhbGxiYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZE5vZGVDYWxsYmFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNTY2hlZHVsZXIgPSBpc1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBTY2FsYXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2FsYXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBzdGF0ZS5kb25lLCB2YWx1ZSA9IHN0YXRlLnZhbHVlLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBTY2FsYXJPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2NhbGFyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU2NhbGFyT2JzZXJ2YWJsZSA9IFNjYWxhck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2FsYXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdjb21wbGV0ZScsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9lbXB0eS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBjb21wbGV0ZS48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBvbmx5IG9kZCBudW1iZXJzIHRvIHRoZSBzZXF1ZW5jZSAnYScsICdiJywgJ2MnPC9jYXB0aW9uPlxuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IGludGVydmFsLm1lcmdlTWFwKHggPT5cbiAgICAgKiAgIHggJSAyID09PSAxID8gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKSA6IFJ4Lk9ic2VydmFibGUuZW1wdHkoKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyB0byB0aGUgY29uc29sZTpcbiAgICAgKiAvLyB4IGlzIGVxdWFsIHRvIHRoZSBjb3VudCBvbiB0aGUgaW50ZXJ2YWwgZWcoMCwxLDIsMywuLi4pXG4gICAgICogLy8geCB3aWxsIG9jY3VyIGV2ZXJ5IDEwMDBtc1xuICAgICAqIC8vIGlmIHggJSAyIGlzIGVxdWFsIHRvIDEgcHJpbnQgYWJjXG4gICAgICogLy8gaWYgeCAlIDIgaXMgbm90IGVxdWFsIHRvIDEgbm90aGluZyB3aWxsIGJlIG91dHB1dFxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIFNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gXCJlbXB0eVwiIE9ic2VydmFibGU6IGVtaXRzIG9ubHkgdGhlIGNvbXBsZXRlXG4gICAgICogbm90aWZpY2F0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGVtcHR5XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFbXB0eU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVtcHR5T2JzZXJ2YWJsZSA9IEVtcHR5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgU2NoZWR1bGVyLCB3aGljaCBtZWFucyB0aGUgYG5leHRgXG4gICAgICogbm90aWZpY2F0aW9ucyBhcmUgc2VudCBzeW5jaHJvbm91c2x5LCBhbHRob3VnaCB3aXRoIGEgZGlmZmVyZW50IFNjaGVkdWxlclxuICAgICAqIGl0IGlzIHBvc3NpYmxlIHRvIGRldGVybWluZSB3aGVuIHRob3NlIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBkZWxpdmVyZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IDEwLCAyMCwgMzAsIHRoZW4gJ2EnLCAnYicsICdjJywgdGhlbiBzdGFydCB0aWNraW5nIGV2ZXJ5IHNlY29uZC48L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKDEwLCAyMCwgMzApO1xuICAgICAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKTtcbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBudW1iZXJzLmNvbmNhdChsZXR0ZXJzKS5jb25jYXQoaW50ZXJ2YWwpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLlR9IHZhbHVlcyBBcmd1bWVudHMgdGhhdCByZXByZXNlbnQgYG5leHRgIHZhbHVlcyB0byBiZSBlbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BcnJheU9ic2VydmFibGUgPSBBcnJheU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT3V0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT3V0ZXJTdWJzY3JpYmVyID0gT3V0ZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzUHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdCkge1xuICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdpdGVyYXRvciBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgICAgICB2YXIgU2V0XzEgPSByb290LlNldDtcbiAgICAgICAgaWYgKFNldF8xICYmIHR5cGVvZiBuZXcgU2V0XzEoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNYXBfMSA9IHJvb3QuTWFwO1xuICAgICAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgICAgIGlmIChNYXBfMSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXBfMS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBNYXBfMS5wcm90b3R5cGVba2V5XSA9PT0gTWFwXzEucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG59XG5leHBvcnRzLnN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsO1xuZXhwb3J0cy4kJGl0ZXJhdG9yID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJTdWJzY3JpYmVyKHBhcmVudCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub3V0ZXJWYWx1ZSA9IG91dGVyVmFsdWU7XG4gICAgICAgIHRoaXMub3V0ZXJJbmRleCA9IG91dGVySW5kZXg7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodGhpcy5vdXRlclZhbHVlLCB2YWx1ZSwgdGhpcy5vdXRlckluZGV4LCB0aGlzLmluZGV4KyssIHRoaXMpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5Q29tcGxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbm5lclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLklubmVyU3Vic2NyaWJlciA9IElubmVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmVyU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcbnZhciBpc1Byb21pc2VfMSA9IHJlcXVpcmUoJy4vaXNQcm9taXNlJyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xudmFyIElubmVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vSW5uZXJTdWJzY3JpYmVyJyk7XG52YXIgb2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL29ic2VydmFibGUnKTtcbmZ1bmN0aW9uIHN1YnNjcmliZVRvUmVzdWx0KG91dGVyU3Vic2NyaWJlciwgcmVzdWx0LCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gbmV3IElubmVyU3Vic2NyaWJlcl8xLklubmVyU3Vic2NyaWJlcihvdXRlclN1YnNjcmliZXIsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpO1xuICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xuICAgICAgICBpZiAocmVzdWx0Ll9pc1NjYWxhcikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWJzY3JpYmUoZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXlfMS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW4gJiYgIWRlc3RpbmF0aW9uLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGRlc3RpbmF0aW9uLmVycm9yKGVycik7IH0pXG4gICAgICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBFc2NhcGluZyB0aGUgUHJvbWlzZSB0cmFwOiBnbG9iYWxseSB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgICByb290XzEucm9vdC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHRbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSByZXN1bHRbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBvYnMgPSByZXN1bHRbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0oKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnMuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZScpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnMuc3Vic2NyaWJlKG5ldyBJbm5lclN1YnNjcmliZXJfMS5Jbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlzT2JqZWN0XzEuaXNPYmplY3QocmVzdWx0KSA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIHJlc3VsdCArIFwiJ1wiO1xuICAgICAgICB2YXIgbXNnID0gKFwiWW91IHByb3ZpZGVkIFwiICsgdmFsdWUgKyBcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuXCIpXG4gICAgICAgICAgICArICcgWW91IGNhbiBwcm92aWRlIGFuIE9ic2VydmFibGUsIFByb21pc2UsIEFycmF5LCBvciBJdGVyYWJsZS4nO1xuICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgVHlwZUVycm9yKG1zZykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuc3Vic2NyaWJlVG9SZXN1bHQgPSBzdWJzY3JpYmVUb1Jlc3VsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvUmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBub25lID0ge307XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGUgd2hvc2UgdmFsdWVzIGFyZVxuICogY2FsY3VsYXRlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVzIG9mIGVhY2ggb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciBhbnkgaW5wdXQgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBpdFxuICogY29tcHV0ZXMgYSBmb3JtdWxhIHVzaW5nIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dHMsIHRoZW4gZW1pdHNcbiAqIHRoZSBvdXRwdXQgb2YgdGhhdCBmb3JtdWxhLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbWJpbmVMYXRlc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvbWJpbmVMYXRlc3RgIGNvbWJpbmVzIHRoZSB2YWx1ZXMgZnJvbSB0aGlzIE9ic2VydmFibGUgd2l0aCB2YWx1ZXMgZnJvbVxuICogT2JzZXJ2YWJsZXMgcGFzc2VkIGFzIGFyZ3VtZW50cy4gVGhpcyBpcyBkb25lIGJ5IHN1YnNjcmliaW5nIHRvIGVhY2hcbiAqIE9ic2VydmFibGUsIGluIG9yZGVyLCBhbmQgY29sbGVjdGluZyBhbiBhcnJheSBvZiBlYWNoIG9mIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGFueSB0aW1lIGFueSBvZiB0aGUgaW5wdXQgT2JzZXJ2YWJsZXMgZW1pdHMsIHRoZW4gZWl0aGVyIHRha2luZyB0aGF0XG4gKiBhcnJheSBhbmQgcGFzc2luZyBpdCBhcyBhcmd1bWVudHMgdG8gYW4gb3B0aW9uYWwgYHByb2plY3RgIGZ1bmN0aW9uIGFuZFxuICogZW1pdHRpbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGF0LCBvciBqdXN0IGVtaXR0aW5nIHRoZSBhcnJheSBvZiByZWNlbnRcbiAqIHZhbHVlcyBkaXJlY3RseSBpZiB0aGVyZSBpcyBubyBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RHluYW1pY2FsbHkgY2FsY3VsYXRlIHRoZSBCb2R5LU1hc3MgSW5kZXggZnJvbSBhbiBPYnNlcnZhYmxlIG9mIHdlaWdodCBhbmQgb25lIGZvciBoZWlnaHQ8L2NhcHRpb24+XG4gKiB2YXIgd2VpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZig3MCwgNzIsIDc2LCA3OSwgNzUpO1xuICogdmFyIGhlaWdodCA9IFJ4Lk9ic2VydmFibGUub2YoMS43NiwgMS43NywgMS43OCk7XG4gKiB2YXIgYm1pID0gd2VpZ2h0LmNvbWJpbmVMYXRlc3QoaGVpZ2h0LCAodywgaCkgPT4gdyAvIChoICogaCkpO1xuICogYm1pLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdCTUkgaXMgJyArIHgpKTtcbiAqXG4gKiAvLyBXaXRoIG91dHB1dCB0byBjb25zb2xlOlxuICogLy8gQk1JIGlzIDI0LjIxMjI5MzM4ODQyOTc1M1xuICogLy8gQk1JIGlzIDIzLjkzOTQ4MDk5MjA1MjA5XG4gKiAvLyBCTUkgaXMgMjMuNjcxMjUzNjI5NTkyMjIyXG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9qZWN0XSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBwcm9qZWN0IHRoZSB2YWx1ZXMgZnJvbVxuICogdGhlIGNvbWJpbmVkIGxhdGVzdCB2YWx1ZXMgaW50byBhIG5ldyB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGNvbWJpbmVMYXRlc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVMYXRlc3QoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2plY3QgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGZpcnN0IGFuZCBvbmx5IG90aGVyIGFyZ3VtZW50IGJlc2lkZXMgdGhlIHJlc3VsdFNlbGVjdG9yIGlzIGFuIGFycmF5XG4gICAgLy8gYXNzdW1lIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBgY29tYmluZUxhdGVzdChbb2JzMSwgb2JzMiwgb2JzM10sIHByb2plY3QpYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgIG9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIG9ic2VydmFibGVzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLCBuZXcgQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XG52YXIgQ29tYmluZUxhdGVzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21iaW5lTGF0ZXN0T3BlcmF0b3IocHJvamVjdCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBDb21iaW5lTGF0ZXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21iaW5lTGF0ZXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5Db21iaW5lTGF0ZXN0T3BlcmF0b3IgPSBDb21iaW5lTGF0ZXN0T3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tYmluZUxhdGVzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBbXTtcbiAgICB9XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMucHVzaChub25lKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUpO1xuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBsZW47XG4gICAgICAgICAgICB0aGlzLnRvUmVzcG9uZCA9IGxlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG9ic2VydmFibGVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAodW51c2VkKSB7XG4gICAgICAgIGlmICgodGhpcy5hY3RpdmUgLT0gMSkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICB2YXIgb2xkVmFsID0gdmFsdWVzW291dGVySW5kZXhdO1xuICAgICAgICB2YXIgdG9SZXNwb25kID0gIXRoaXMudG9SZXNwb25kXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogb2xkVmFsID09PSBub25lID8gLS10aGlzLnRvUmVzcG9uZCA6IHRoaXMudG9SZXNwb25kO1xuICAgICAgICB2YWx1ZXNbb3V0ZXJJbmRleF0gPSBpbm5lclZhbHVlO1xuICAgICAgICBpZiAodG9SZXNwb25kID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlcy5zbGljZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQ29tYmluZUxhdGVzdFN1YnNjcmliZXIgPSBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgY29tYmluZUxhdGVzdF8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3IvY29tYmluZUxhdGVzdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGUgd2hvc2UgdmFsdWVzIGFyZVxuICogY2FsY3VsYXRlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVzIG9mIGVhY2ggb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciBhbnkgaW5wdXQgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBpdFxuICogY29tcHV0ZXMgYSBmb3JtdWxhIHVzaW5nIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dHMsIHRoZW4gZW1pdHNcbiAqIHRoZSBvdXRwdXQgb2YgdGhhdCBmb3JtdWxhLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbWJpbmVMYXRlc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvbWJpbmVMYXRlc3RgIGNvbWJpbmVzIHRoZSB2YWx1ZXMgZnJvbSBhbGwgdGhlIE9ic2VydmFibGVzIHBhc3NlZCBhc1xuICogYXJndW1lbnRzLiBUaGlzIGlzIGRvbmUgYnkgc3Vic2NyaWJpbmcgdG8gZWFjaCBPYnNlcnZhYmxlLCBpbiBvcmRlciwgYW5kXG4gKiBjb2xsZWN0aW5nIGFuIGFycmF5IG9mIGVhY2ggb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBhbnkgdGltZSBhbnkgb2YgdGhlXG4gKiBpbnB1dCBPYnNlcnZhYmxlcyBlbWl0cywgdGhlbiBlaXRoZXIgdGFraW5nIHRoYXQgYXJyYXkgYW5kIHBhc3NpbmcgaXQgYXNcbiAqIGFyZ3VtZW50cyB0byBhbiBvcHRpb25hbCBgcHJvamVjdGAgZnVuY3Rpb24gYW5kIGVtaXR0aW5nIHRoZSByZXR1cm4gdmFsdWUgb2ZcbiAqIHRoYXQsIG9yIGp1c3QgZW1pdHRpbmcgdGhlIGFycmF5IG9mIHJlY2VudCB2YWx1ZXMgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm9cbiAqIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EeW5hbWljYWxseSBjYWxjdWxhdGUgdGhlIEJvZHktTWFzcyBJbmRleCBmcm9tIGFuIE9ic2VydmFibGUgb2Ygd2VpZ2h0IGFuZCBvbmUgZm9yIGhlaWdodDwvY2FwdGlvbj5cbiAqIHZhciB3ZWlnaHQgPSBSeC5PYnNlcnZhYmxlLm9mKDcwLCA3MiwgNzYsIDc5LCA3NSk7XG4gKiB2YXIgaGVpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZigxLjc2LCAxLjc3LCAxLjc4KTtcbiAqIHZhciBibWkgPSBSeC5PYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3Qod2VpZ2h0LCBoZWlnaHQsICh3LCBoKSA9PiB3IC8gKGggKiBoKSk7XG4gKiBibWkuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0JNSSBpcyAnICsgeCkpO1xuICpcbiAqIC8vIFdpdGggb3V0cHV0IHRvIGNvbnNvbGU6XG4gKiAvLyBCTUkgaXMgMjQuMjEyMjkzMzg4NDI5NzUzXG4gKiAvLyBCTUkgaXMgMjMuOTM5NDgwOTkyMDUyMDlcbiAqIC8vIEJNSSBpcyAyMy42NzEyNTM2Mjk1OTIyMjJcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayB3aXRoTGF0ZXN0RnJvbX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG9ic2VydmFibGUxIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG9ic2VydmFibGUyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2plY3RdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHByb2plY3QgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgY29tYmluZWQgbGF0ZXN0IHZhbHVlcyBpbnRvIGEgbmV3IHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBTY2hlZHVsZXIgdG8gdXNlIGZvciBzdWJzY3JpYmluZyB0b1xuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IE9ic2VydmFibGUsIG9yIGFuIGFycmF5IG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbVxuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBjb21iaW5lTGF0ZXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb21iaW5lTGF0ZXN0KCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG51bGw7XG4gICAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIob2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2plY3QgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIGZpcnN0IGFuZCBvbmx5IG90aGVyIGFyZ3VtZW50IGJlc2lkZXMgdGhlIHJlc3VsdFNlbGVjdG9yIGlzIGFuIGFycmF5XG4gICAgLy8gYXNzdW1lIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBgY29tYmluZUxhdGVzdChbb2JzMSwgb2JzMiwgb2JzM10sIHByb2plY3QpYFxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgIG9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzLCBzY2hlZHVsZXIpLmxpZnQobmV3IGNvbWJpbmVMYXRlc3RfMS5Db21iaW5lTGF0ZXN0T3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy5jb21iaW5lTGF0ZXN0ID0gY29tYmluZUxhdGVzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbWJpbmVMYXRlc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvY29tYmluZUxhdGVzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3RfMS5jb21iaW5lTGF0ZXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZUxhdGVzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSB3aGljaFxuICogY29uY3VycmVudGx5IGRlbGl2ZXJzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgZW1pdHRlZCBvbiB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlQWxsYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhc1xuICogYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgaXQgc3Vic2NyaWJlcyB0byB0aGF0IGFuZCBkZWxpdmVycyBhbGwgdGhlIHZhbHVlcyBmcm9tIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5XG4gKiBjb21wbGV0ZXMgb25jZSBhbGwgaW5uZXIgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnlcbiAqIGEgaW5uZXIgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwYXduIGEgbmV3IGludGVydmFsIE9ic2VydmFibGUgZm9yIGVhY2ggY2xpY2sgZXZlbnQsIGFuZCBibGVuZCB0aGVpciBvdXRwdXRzIGFzIG9uZSBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IGZyb20gMCB0byA5IGV2ZXJ5IHNlY29uZCBmb3IgZWFjaCBjbGljaywgYnV0IG9ubHkgYWxsb3cgMiBjb25jdXJyZW50IHRpbWVyczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKDIpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbm5lclxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGNvbWluZyBmcm9tIGFsbCB0aGVcbiAqIGlubmVyIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZUFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkpO1xufVxuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xudmFyIE1lcmdlQWxsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkge1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZUFsbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlQWxsT3BlcmF0b3IgPSBNZXJnZUFsbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZUFsbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZUFsbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25jdXJyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIH1cbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlQWxsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlQWxsU3Vic2NyaWJlciA9IE1lcmdlQWxsU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBzZXF1ZW50aWFsbHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIGFmdGVyIHRoZSBjdXJyZW50IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbmNhdGVuYXRlcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieVxuICogc2VxdWVudGlhbGx5IGVtaXR0aW5nIHRoZWlyIHZhbHVlcywgb25lIE9ic2VydmFibGUgYWZ0ZXIgdGhlIG90aGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBKb2lucyB0aGlzIE9ic2VydmFibGUgd2l0aCBtdWx0aXBsZSBvdGhlciBPYnNlcnZhYmxlcyBieSBzdWJzY3JpYmluZyB0byB0aGVtXG4gKiBvbmUgYXQgYSB0aW1lLCBzdGFydGluZyB3aXRoIHRoZSBzb3VyY2UsIGFuZCBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLiBXaWxsIHdhaXQgZm9yIGVhY2ggT2JzZXJ2YWJsZSB0byBjb21wbGV0ZSBiZWZvcmUgbW92aW5nXG4gKiBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhIHRpbWVyIGNvdW50aW5nIGZyb20gMCB0byAzIHdpdGggYSBzeW5jaHJvbm91cyBzZXF1ZW5jZSBmcm9tIDEgdG8gMTA8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCk7XG4gKiB2YXIgc2VxdWVuY2UgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lci5jb25jYXQoc2VxdWVuY2UpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluOlxuICogLy8gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gMyAtaW1tZWRpYXRlLT4gMSAuLi4gMTBcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSAzIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciByZXN1bHQgPSB0aW1lcjEuY29uY2F0KHRpbWVyMiwgdGltZXIzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgYWZ0ZXIgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBTY2hlZHVsZXIgdG8gc2NoZWR1bGUgZWFjaFxuICogT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbGwgdmFsdWVzIG9mIGVhY2ggcGFzc2VkIE9ic2VydmFibGUgbWVyZ2VkIGludG8gYVxuICogc2luZ2xlIE9ic2VydmFibGUsIGluIG9yZGVyLCBpbiBzZXJpYWwgZmFzaGlvbi5cbiAqIEBtZXRob2QgY29uY2F0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbChjb25jYXRTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW0gb25lIGF0IGEgdGltZSBhbmRcbiAqIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gV2lsbCB3YWl0IGZvciBlYWNoXG4gKiBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbjpcbiAqIC8vIDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDMgLWltbWVkaWF0ZS0+IDEgLi4uIDEwXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgMyBPYnNlcnZhYmxlczwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIxLCB0aW1lcjIsIHRpbWVyMyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChQcmludHMgdG8gY29uc29sZSBzZXF1ZW50aWFsbHkpXG4gKiAvLyAtMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gLi4uIDlcbiAqIC8vIC0yMDAwbXMtPiAwIC0yMDAwbXMtPiAxIC0yMDAwbXMtPiAuLi4gNVxuICogLy8gLTUwMG1zLT4gMCAtNTAwbXMtPiAxIC01MDBtcy0+IC4uLiA5XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBpbnB1dDEgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb25jYXRlbmF0ZSB3aXRoIG90aGVycy5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gaW5wdXQyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgd2l0aCBvdGhlcnMuXG4gKiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIEFuIG9wdGlvbmFsIFNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdFN0YXRpYygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gICAgdmFyIGFyZ3MgPSBvYnNlcnZhYmxlcztcbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihhcmdzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSBudWxsICYmIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzLCBzY2hlZHVsZXIpLmxpZnQobmV3IG1lcmdlQWxsXzEuTWVyZ2VBbGxPcGVyYXRvcigxKSk7XG59XG5leHBvcnRzLmNvbmNhdFN0YXRpYyA9IGNvbmNhdFN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL2NvbmNhdCcpO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXRfMS5jb25jYXRTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9jb25jYXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNvbmNhdCA9IGNvbmNhdF8xLmNvbmNhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIERlZmVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlck9ic2VydmFibGUob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQsIG9uIHN1YnNjcmliZSwgY2FsbHMgYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IHRvXG4gICAgICogbWFrZSBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIG5ldyBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIHRoZSBPYnNlcnZhYmxlIGxhemlseSwgdGhhdCBpcywgb25seSB3aGVuIGl0XG4gICAgICogaXMgc3Vic2NyaWJlZC5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGRlZmVyYCBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0aGUgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIE9ic2VydmVyXG4gICAgICogc3Vic2NyaWJlcywgYW5kIGNyZWF0ZSBhIGZyZXNoIE9ic2VydmFibGUgZm9yIGVhY2ggT2JzZXJ2ZXIuIEl0IHdhaXRzIHVudGlsXG4gICAgICogYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgYW5kIHRoZW4gaXQgZ2VuZXJhdGVzIGFuIE9ic2VydmFibGUsXG4gICAgICogdHlwaWNhbGx5IHdpdGggYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBkb2VzIHRoaXMgYWZyZXNoIGZvciBlYWNoXG4gICAgICogc3Vic2NyaWJlciwgc28gYWx0aG91Z2ggZWFjaCBzdWJzY3JpYmVyIG1heSB0aGluayBpdCBpcyBzdWJzY3JpYmluZyB0byB0aGVcbiAgICAgKiBzYW1lIE9ic2VydmFibGUsIGluIGZhY3QgZWFjaCBzdWJzY3JpYmVyIGdldHMgaXRzIG93biBpbmRpdmlkdWFsXG4gICAgICogT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byBlaXRoZXIgYW4gT2JzZXJ2YWJsZSBvZiBjbGlja3Mgb3IgYW4gT2JzZXJ2YWJsZSBvZiBpbnRlcnZhbCwgYXQgcmFuZG9tPC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3NPckludGVydmFsID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICogICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2xpY2tzT3JJbnRlcnZhbC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgYmVoYXZpb3I6XG4gICAgICogLy8gSWYgdGhlIHJlc3VsdCBvZiBNYXRoLnJhbmRvbSgpIGlzIGdyZWF0ZXIgdGhhbiAwLjUgaXQgd2lsbCBsaXN0ZW5cbiAgICAgKiAvLyBmb3IgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBcImRvY3VtZW50XCI7IHdoZW4gZG9jdW1lbnQgaXMgY2xpY2tlZCBpdFxuICAgICAqIC8vIHdpbGwgbG9nIGEgTW91c2VFdmVudCBvYmplY3QgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSByZXN1bHQgaXMgbGVzc1xuICAgICAqIC8vIHRoYW4gMC41IGl0IHdpbGwgZW1pdCBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBPYnNlcnZhYmxlfFByb21pc2V9IG9ic2VydmFibGVGYWN0b3J5IFRoZSBPYnNlcnZhYmxlXG4gICAgICogZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggT2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlLiBNYXkgYWxzbyByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5XG4gICAgICogdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHdob3NlIE9ic2VydmVycycgc3Vic2NyaXB0aW9ucyB0cmlnZ2VyXG4gICAgICogYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGRlZmVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBEZWZlck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIERlZmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRGVmZXJPYnNlcnZhYmxlID0gRGVmZXJPYnNlcnZhYmxlO1xudmFyIERlZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIGZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLnRyeURlZmVyKCk7XG4gICAgfVxuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NhbGxGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mYWN0b3J5KCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlclN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIERlZmVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9EZWZlck9ic2VydmFibGUnKTtcbmV4cG9ydHMuZGVmZXIgPSBEZWZlck9ic2VydmFibGVfMS5EZWZlck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRlZmVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2RlZmVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5kZWZlciA9IGRlZmVyXzEuZGVmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmVtcHR5ID0gRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBlbXB0eV8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9lbXB0eScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZW1wdHkgPSBlbXB0eV8xLmVtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRm9ya0pvaW5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ya0pvaW5PYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZvcmtKb2luT2JzZXJ2YWJsZShzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzb3VyY2VzXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZvcmtKb2luXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGb3JrSm9pbk9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgc291cmNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlcyA9PT0gbnVsbCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlc1tzb3VyY2VzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHRTZWxlY3RvciA9IHNvdXJjZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IGFuZCBvbmx5IG90aGVyIGFyZ3VtZW50IGJlc2lkZXMgdGhlIHJlc3VsdFNlbGVjdG9yIGlzIGFuIGFycmF5XG4gICAgICAgIC8vIGFzc3VtZSBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYGZvcmtKb2luKFtvYnMxLCBvYnMyLCBvYnMzXSwgcmVzdWx0U2VsZWN0b3IpYFxuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheV8xLmlzQXJyYXkoc291cmNlc1swXSkpIHtcbiAgICAgICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcmtKb2luT2JzZXJ2YWJsZShzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcik7XG4gICAgfTtcbiAgICBGb3JrSm9pbk9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IEZvcmtKb2luU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNvdXJjZXMsIHRoaXMucmVzdWx0U2VsZWN0b3IpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcmtKb2luT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRm9ya0pvaW5PYnNlcnZhYmxlID0gRm9ya0pvaW5PYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGb3JrSm9pblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JrSm9pblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ya0pvaW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzb3VyY2VzLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSAwO1xuICAgICAgICB0aGlzLmhhdmVWYWx1ZXMgPSAwO1xuICAgICAgICB2YXIgbGVuID0gc291cmNlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudG90YWwgPSBsZW47XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBzb3VyY2UsIG51bGwsIGkpO1xuICAgICAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24ub3V0ZXJJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEZvcmtKb2luU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIGlmICghaW5uZXJTdWIuX2hhc1ZhbHVlKSB7XG4gICAgICAgICAgICBpbm5lclN1Yi5faGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oYXZlVmFsdWVzKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZvcmtKb2luU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGF2ZVZhbHVlcyA9IF9hLmhhdmVWYWx1ZXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIHZhbHVlcyA9IF9hLnZhbHVlcztcbiAgICAgICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIGlmICghaW5uZXJTdWIuX2hhc1ZhbHVlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGxldGVkKys7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlZCAhPT0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVWYWx1ZXMgPT09IGxlbikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0U2VsZWN0b3IgPyByZXN1bHRTZWxlY3Rvci5hcHBseSh0aGlzLCB2YWx1ZXMpIDogdmFsdWVzO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBGb3JrSm9pblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ya0pvaW5PYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEZvcmtKb2luT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gb3JrSm9pbk9ic2VydmFibGUnKTtcbmV4cG9ydHMuZm9ya0pvaW4gPSBGb3JrSm9pbk9ic2VydmFibGVfMS5Gb3JrSm9pbk9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ya0pvaW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZvcmtKb2luXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2ZvcmtKb2luJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mb3JrSm9pbiA9IGZvcmtKb2luXzEuZm9ya0pvaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JrSm9pbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgUHJvbWlzZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9taXNlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9taXNlT2JzZXJ2YWJsZShwcm9taXNlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFByb21pc2UgdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5SZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBqdXN0IGVtaXRzIHRoZSBQcm9taXNlJ3NcbiAgICAgKiByZXNvbHZlZCB2YWx1ZSwgdGhlbiBjb21wbGV0ZXMuPC9zcGFuPlxuICAgICAqXG4gICAgICogQ29udmVydHMgYW4gRVMyMDE1IFByb21pc2Ugb3IgYSBQcm9taXNlcy9BKyBzcGVjIGNvbXBsaWFudCBQcm9taXNlIHRvIGFuXG4gICAgICogT2JzZXJ2YWJsZS4gSWYgdGhlIFByb21pc2UgcmVzb2x2ZXMgd2l0aCBhIHZhbHVlLCB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAgICAgKiBlbWl0cyB0aGF0IHJlc29sdmVkIHZhbHVlIGFzIGEgYG5leHRgLCBhbmQgdGhlbiBjb21wbGV0ZXMuIElmIHRoZSBQcm9taXNlXG4gICAgICogaXMgcmVqZWN0ZWQsIHRoZW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHRoZSBjb3JyZXNwb25kaW5nIEVycm9yLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSBGZXRjaCB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmZyb21Qcm9taXNlKGZldGNoKCdodHRwOi8vbXlzZXJ2ZXIuY29tLycpKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBiaW5kQ2FsbGJhY2t9XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSB0byBiZSBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEFuIG9wdGlvbmFsIFNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZGVsaXZlcnkgb2YgdGhlIHJlc29sdmVkIHZhbHVlIChvciB0aGUgcmVqZWN0aW9uKS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHdoaWNoIHdyYXBzIHRoZSBQcm9taXNlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21Qcm9taXNlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBQcm9taXNlT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAocHJvbWlzZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZU9ic2VydmFibGUocHJvbWlzZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFByb21pc2VPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHByb21pc2UgdHJhcCwgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICByb290XzEucm9vdC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NjYWxhcikge1xuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHRoaXMudmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB2YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEVycm9yLCAwLCB7IGVycjogZXJyLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHRoZSBwcm9taXNlIHRyYXAsIHRocm93IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuUHJvbWlzZU9ic2VydmFibGUgPSBQcm9taXNlT2JzZXJ2YWJsZTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEVycm9yKGFyZykge1xuICAgIHZhciBlcnIgPSBhcmcuZXJyLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvbWlzZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBJdGVyYXRvck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJdGVyYXRvck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXRlcmF0b3JPYnNlcnZhYmxlKGl0ZXJhdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoaXRlcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBJdGVyYXRvck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvck9ic2VydmFibGUoaXRlcmF0b3IsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIGhhc0Vycm9yID0gc3RhdGUuaGFzRXJyb3IsIGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3IsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc3RhdGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgSXRlcmF0b3JPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaXRlcmF0b3IgPSBfYS5pdGVyYXRvciwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEl0ZXJhdG9yT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCwgaXRlcmF0b3I6IGl0ZXJhdG9yLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJdGVyYXRvck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkl0ZXJhdG9yT2JzZXJ2YWJsZSA9IEl0ZXJhdG9yT2JzZXJ2YWJsZTtcbnZhciBTdHJpbmdJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nSXRlcmF0b3Ioc3RyLCBpZHgsIGxlbikge1xuICAgICAgICBpZiAoaWR4ID09PSB2b2lkIDApIHsgaWR4ID0gMDsgfVxuICAgICAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gc3RyLmxlbmd0aDsgfVxuICAgICAgICB0aGlzLnN0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzKTsgfTtcbiAgICBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWR4IDwgdGhpcy5sZW4gPyB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pZHgrKylcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5nSXRlcmF0b3I7XG59KCkpO1xudmFyIEFycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoYXJyLCBpZHgsIGxlbikge1xuICAgICAgICBpZiAoaWR4ID09PSB2b2lkIDApIHsgaWR4ID0gMDsgfVxuICAgICAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gdG9MZW5ndGgoYXJyKTsgfVxuICAgICAgICB0aGlzLmFyciA9IGFycjtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXJyW3RoaXMuaWR4KytdXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5SXRlcmF0b3I7XG59KCkpO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3Iob2JqKSB7XG4gICAgdmFyIGkgPSBvYmpbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXTtcbiAgICBpZiAoIWkgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihvYmopO1xuICAgIH1cbiAgICBpZiAoIWkgJiYgb2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xuICAgIH1cbiAgICBpZiAoIWkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqZWN0IGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKTtcbn1cbnZhciBtYXhTYWZlSW50ZWdlciA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5mdW5jdGlvbiB0b0xlbmd0aChvKSB7XG4gICAgdmFyIGxlbiA9ICtvLmxlbmd0aDtcbiAgICBpZiAoaXNOYU4obGVuKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGxlbiA9PT0gMCB8fCAhbnVtYmVySXNGaW5pdGUobGVuKSkge1xuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICBsZW4gPSBzaWduKGxlbikgKiBNYXRoLmZsb29yKE1hdGguYWJzKGxlbikpO1xuICAgIGlmIChsZW4gPD0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGxlbiA+IG1heFNhZmVJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYXhTYWZlSW50ZWdlcjtcbiAgICB9XG4gICAgcmV0dXJuIGxlbjtcbn1cbmZ1bmN0aW9uIG51bWJlcklzRmluaXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgcm9vdF8xLnJvb3QuaXNGaW5pdGUodmFsdWUpO1xufVxuZnVuY3Rpb24gc2lnbih2YWx1ZSkge1xuICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gK3ZhbHVlO1xuICAgIGlmICh2YWx1ZUFzTnVtYmVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUFzTnVtYmVyO1xuICAgIH1cbiAgICBpZiAoaXNOYU4odmFsdWVBc051bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZUFzTnVtYmVyIDwgMCA/IC0xIDogMTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUl0ZXJhdG9yT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEFycmF5TGlrZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheUxpa2VPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5TGlrZU9ic2VydmFibGUoYXJyYXlMaWtlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXlMaWtlID0gYXJyYXlMaWtlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgJiYgYXJyYXlMaWtlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycmF5TGlrZVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheUxpa2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcnJheUxpa2UsIHNjaGVkdWxlcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZV8xLlNjYWxhck9ic2VydmFibGUoYXJyYXlMaWtlWzBdLCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpa2VPYnNlcnZhYmxlKGFycmF5TGlrZSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJyYXlMaWtlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXlMaWtlID0gc3RhdGUuYXJyYXlMaWtlLCBpbmRleCA9IHN0YXRlLmluZGV4LCBsZW5ndGggPSBzdGF0ZS5sZW5ndGgsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5TGlrZVtpbmRleF0pO1xuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheUxpa2VPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYXJyYXlMaWtlID0gX2EuYXJyYXlMaWtlLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEFycmF5TGlrZU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheUxpa2U6IGFycmF5TGlrZSwgaW5kZXg6IGluZGV4LCBsZW5ndGg6IGxlbmd0aCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheUxpa2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlMaWtlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQXJyYXlMaWtlT2JzZXJ2YWJsZSA9IEFycmF5TGlrZU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheUxpa2VPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcHVzaC1iYXNlZCBldmVudCBvciB2YWx1ZSB0aGF0IGFuIHtAbGluayBPYnNlcnZhYmxlfSBjYW4gZW1pdC5cbiAqIFRoaXMgY2xhc3MgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igb3BlcmF0b3JzIHRoYXQgbWFuYWdlIG5vdGlmaWNhdGlvbnMsXG4gKiBsaWtlIHtAbGluayBtYXRlcmlhbGl6ZX0sIHtAbGluayBkZW1hdGVyaWFsaXplfSwge0BsaW5rIG9ic2VydmVPbn0sIGFuZFxuICogb3RoZXJzLiBCZXNpZGVzIHdyYXBwaW5nIHRoZSBhY3R1YWwgZGVsaXZlcmVkIHZhbHVlLCBpdCBhbHNvIGFubm90YXRlcyBpdFxuICogd2l0aCBtZXRhZGF0YSBvZiwgZm9yIGluc3RhbmNlLCB3aGF0IHR5cGUgb2YgcHVzaCBtZXNzYWdlIGl0IGlzIChgbmV4dGAsXG4gKiBgZXJyb3JgLCBvciBgY29tcGxldGVgKS5cbiAqXG4gKiBAc2VlIHtAbGluayBtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIGRlbWF0ZXJpYWxpemV9XG4gKiBAc2VlIHtAbGluayBvYnNlcnZlT259XG4gKlxuICogQGNsYXNzIE5vdGlmaWNhdGlvbjxUPlxuICovXG52YXIgTm90aWZpY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb24oa2luZCwgdmFsdWUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0ga2luZCA9PT0gJ04nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxpdmVycyB0byB0aGUgZ2l2ZW4gYG9ic2VydmVyYCB0aGUgdmFsdWUgd3JhcHBlZCBieSB0aGlzIE5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlclxuICAgICAqIEByZXR1cm5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuY29tcGxldGUgJiYgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gc29tZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrcywgZGVsaXZlciB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICogY3VycmVudCBOb3RpZmljYXRpb24gdG8gdGhlIGNvcnJlY3RseSBjb3JyZXNwb25kaW5nIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0IEFuIE9ic2VydmVyIGBuZXh0YCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogYW55KTogdm9pZH0gW2Vycm9yXSBBbiBPYnNlcnZlciBgZXJyb3JgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBBbiBPYnNlcnZlciBgY29tcGxldGVgIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmRvID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCAmJiBuZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlICYmIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIE9ic2VydmVyIG9yIGl0cyBpbmRpdmlkdWFsIGNhbGxiYWNrIGZ1bmN0aW9ucywgYW5kIGNhbGxzIGBvYnNlcnZlYFxuICAgICAqIG9yIGBkb2AgbWV0aG9kcyBhY2NvcmRpbmdseS5cbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gbmV4dE9yT2JzZXJ2ZXIgQW4gT2JzZXJ2ZXIgb3JcbiAgICAgKiB0aGUgYG5leHRgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyICYmIHR5cGVvZiBuZXh0T3JPYnNlcnZlci5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBqdXN0IGRlbGl2ZXJzIHRoZSBub3RpZmljYXRpb24gcmVwcmVzZW50ZWRcbiAgICAgKiBieSB0aGlzIE5vdGlmaWNhdGlvbiBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vZih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aHJvdyh0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBub3RpZmljYXRpb24ga2luZCB2YWx1ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYG5leHRgIGZyb20gYVxuICAgICAqIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcIm5leHRcIiBOb3RpZmljYXRpb24gcmVwcmVzZW50aW5nIHRoZVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignTicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bmRlZmluZWRWYWx1ZU5vdGlmaWNhdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBlcnJvcmAgZnJvbSBhXG4gICAgICogZ2l2ZW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGVycm9yLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxUPn0gVGhlIFwiZXJyb3JcIiBOb3RpZmljYXRpb24gcmVwcmVzZW50aW5nIHRoZVxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb24oJ0UnLCB1bmRlZmluZWQsIGVycik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgY29tcGxldGVgLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxhbnk+fSBUaGUgdmFsdWVsZXNzIFwiY29tcGxldGVcIiBOb3RpZmljYXRpb24uXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZU5vdGlmaWNhdGlvbjtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ0MnKTtcbiAgICBOb3RpZmljYXRpb24udW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdOJywgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xufSgpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcGFyYW0gZGVsYXlcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBvYnNlcnZlT25cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmVPbihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgT2JzZXJ2ZU9uT3BlcmF0b3Ioc2NoZWR1bGVyLCBkZWxheSkpO1xufVxuZXhwb3J0cy5vYnNlcnZlT24gPSBvYnNlcnZlT247XG52YXIgT2JzZXJ2ZU9uT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVPbk9wZXJhdG9yKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgfVxuICAgIE9ic2VydmVPbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNjaGVkdWxlciwgdGhpcy5kZWxheSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmVPbk9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uT3BlcmF0b3IgPSBPYnNlcnZlT25PcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT2JzZXJ2ZU9uU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ic2VydmVPblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2NoZWR1bGVyLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIH1cbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgbm90aWZpY2F0aW9uID0gYXJnLm5vdGlmaWNhdGlvbiwgZGVzdGluYXRpb24gPSBhcmcuZGVzdGluYXRpb247XG4gICAgICAgIG5vdGlmaWNhdGlvbi5vYnNlcnZlKGRlc3RpbmF0aW9uKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTWVzc2FnZSA9IGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCwgdGhpcy5kZWxheSwgbmV3IE9ic2VydmVPbk1lc3NhZ2Uobm90aWZpY2F0aW9uLCB0aGlzLmRlc3RpbmF0aW9uKSkpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZU9uU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uU3Vic2NyaWJlciA9IE9ic2VydmVPblN1YnNjcmliZXI7XG52YXIgT2JzZXJ2ZU9uTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uTWVzc2FnZShub3RpZmljYXRpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlT25NZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2ZU9uTWVzc2FnZSA9IE9ic2VydmVPbk1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlT24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc1Byb21pc2VfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNQcm9taXNlJyk7XG52YXIgUHJvbWlzZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vUHJvbWlzZU9ic2VydmFibGUnKTtcbnZhciBJdGVyYXRvck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vSXRlcmF0b3JPYnNlcnZhYmxlJyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIEFycmF5TGlrZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQXJyYXlMaWtlT2JzZXJ2YWJsZScpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgb2JzZXJ2ZU9uXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvci9vYnNlcnZlT24nKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlMaWtlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBGcm9tT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyb21PYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21PYnNlcnZhYmxlKGlzaCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgICB0aGlzLmlzaCA9IGlzaDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBmcm9tIGFuIEFycmF5LCBhbiBhcnJheS1saWtlIG9iamVjdCwgYSBQcm9taXNlLCBhblxuICAgICAqIGl0ZXJhYmxlIG9iamVjdCwgb3IgYW4gT2JzZXJ2YWJsZS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db252ZXJ0cyBhbG1vc3QgYW55dGhpbmcgdG8gYW4gT2JzZXJ2YWJsZS48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2Zyb20ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBDb252ZXJ0IHZhcmlvdXMgb3RoZXIgb2JqZWN0cyBhbmQgZGF0YSB0eXBlcyBpbnRvIE9ic2VydmFibGVzLiBgZnJvbWBcbiAgICAgKiBjb252ZXJ0cyBhIFByb21pc2Ugb3IgYW4gYXJyYXktbGlrZSBvciBhblxuICAgICAqIFtpdGVyYWJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYWJsZSlcbiAgICAgKiBvYmplY3QgaW50byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGl0ZW1zIGluIHRoYXQgcHJvbWlzZSBvciBhcnJheSBvclxuICAgICAqIGl0ZXJhYmxlLiBBIFN0cmluZywgaW4gdGhpcyBjb250ZXh0LCBpcyB0cmVhdGVkIGFzIGFuIGFycmF5IG9mIGNoYXJhY3RlcnMuXG4gICAgICogT2JzZXJ2YWJsZS1saWtlIG9iamVjdHMgKGNvbnRhaW5zIGEgZnVuY3Rpb24gbmFtZWQgd2l0aCB0aGUgRVMyMDE1IFN5bWJvbFxuICAgICAqIGZvciBPYnNlcnZhYmxlKSBjYW4gYWxzbyBiZSBjb252ZXJ0ZWQgdGhyb3VnaCB0aGlzIG9wZXJhdG9yLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydHMgYW4gYXJyYXkgdG8gYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgYXJyYXkgPSBbMTAsIDIwLCAzMF07XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbShhcnJheSk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAgICAgKiAvLyAxMCAyMCAzMFxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBhbiBpbmZpbml0ZSBpdGVyYWJsZSAoZnJvbSBhIGdlbmVyYXRvcikgdG8gYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICAgKiBmdW5jdGlvbiogZ2VuZXJhdGVEb3VibGVzKHNlZWQpIHtcbiAgICAgKiAgIHZhciBpID0gc2VlZDtcbiAgICAgKiAgIHdoaWxlICh0cnVlKSB7XG4gICAgICogICAgIHlpZWxkIGk7XG4gICAgICogICAgIGkgPSAyICogaTsgLy8gZG91YmxlIGl0XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGl0ZXJhdG9yID0gZ2VuZXJhdGVEb3VibGVzKDMpO1xuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmZyb20oaXRlcmF0b3IpLnRha2UoMTApO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gICAgICogLy8gMyA2IDEyIDI0IDQ4IDk2IDE5MiAzODQgNzY4IDE1MzZcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnR9XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tUHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0PFQ+fSBpc2ggQSBzdWJzY3JpYmFibGUgb2JqZWN0LCBhIFByb21pc2UsIGFuXG4gICAgICogT2JzZXJ2YWJsZS1saWtlLCBhbiBBcnJheSwgYW4gaXRlcmFibGUgb3IgYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYmVcbiAgICAgKiBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gICAgICogZW1pc3Npb25zIG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBUaGUgT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlIG9yaWdpbmFsbHkgZnJvbSB0aGVcbiAgICAgKiBpbnB1dCBvYmplY3QgdGhhdCB3YXMgY29udmVydGVkLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21cbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEZyb21PYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpc2gsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNoW29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzaCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlICYmICFzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5XzEuaXNBcnJheShpc2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKGlzaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VPYnNlcnZhYmxlXzEuUHJvbWlzZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlzaFtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpc2ggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvck9ic2VydmFibGVfMS5JdGVyYXRvck9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2UoaXNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZV8xLkFycmF5TGlrZU9ic2VydmFibGUoaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKGlzaCAhPT0gbnVsbCAmJiB0eXBlb2YgaXNoIHx8IGlzaCkgKyAnIGlzIG5vdCBvYnNlcnZhYmxlJyk7XG4gICAgfTtcbiAgICBGcm9tT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpc2ggPSB0aGlzLmlzaDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpc2hbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0oKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNoW29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdKCkuc3Vic2NyaWJlKG5ldyBvYnNlcnZlT25fMS5PYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgMCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkZyb21PYnNlcnZhYmxlID0gRnJvbU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gcm9tT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mcm9tID0gRnJvbU9ic2VydmFibGVfMS5Gcm9tT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmcm9tXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb20nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb20gPSBmcm9tXzEuZnJvbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtbWl0dGVyKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLm9uID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoub2ZmID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdChzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdG9TdHJpbmcuY2FsbChzb3VyY2VPYmopID09PSAnW29iamVjdCBOb2RlTGlzdF0nO1xufVxuZnVuY3Rpb24gaXNIVE1MQ29sbGVjdGlvbihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdG9TdHJpbmcuY2FsbChzb3VyY2VPYmopID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nO1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldChzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRnJvbUV2ZW50T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyb21FdmVudE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbUV2ZW50T2JzZXJ2YWJsZShzb3VyY2VPYmosIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlT2JqID0gc291cmNlT2JqO1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGUgY29taW5nIGZyb20gdGhlXG4gICAgICogZ2l2ZW4gZXZlbnQgdGFyZ2V0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBmcm9tIERPTSBldmVudHMsIG9yIE5vZGVcbiAgICAgKiBFdmVudEVtaXR0ZXIgZXZlbnRzIG9yIG90aGVycy48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2Zyb21FdmVudC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBieSBhdHRhY2hpbmcgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gXCJldmVudCB0YXJnZXRcIixcbiAgICAgKiB3aGljaCBtYXkgYmUgYW4gb2JqZWN0IHdpdGggYGFkZEV2ZW50TGlzdGVuZXJgIGFuZCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAsXG4gICAgICogYSBOb2RlLmpzIEV2ZW50RW1pdHRlciwgYSBqUXVlcnkgc3R5bGUgRXZlbnRFbWl0dGVyLCBhIE5vZGVMaXN0IGZyb20gdGhlXG4gICAgICogRE9NLCBvciBhbiBIVE1MQ29sbGVjdGlvbiBmcm9tIHRoZSBET00uIFRoZSBldmVudCBoYW5kbGVyIGlzIGF0dGFjaGVkIHdoZW5cbiAgICAgKiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCwgYW5kIHJlbW92ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIGlzXG4gICAgICogdW5zdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgY2xpY2tzIGhhcHBlbmluZyBvbiB0aGUgRE9NIGRvY3VtZW50PC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gICAgICogY2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW46XG4gICAgICogLy8gTW91c2VFdmVudCBvYmplY3QgbG9nZ2VkIHRvIGNvbnNvbGUgZXZlcnl0aW1lIGEgY2xpY2tcbiAgICAgKiAvLyBvY2N1cnMgb24gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldExpa2V9IHRhcmdldCBUaGUgRE9NRWxlbWVudCwgZXZlbnQgdGFyZ2V0LCBOb2RlLmpzXG4gICAgICogRXZlbnRFbWl0dGVyLCBOb2RlTGlzdCBvciBIVE1MQ29sbGVjdGlvbiB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXIgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSBvZiBpbnRlcmVzdCwgYmVpbmcgZW1pdHRlZCBieSB0aGVcbiAgICAgKiBgdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRocm91Z2ggdG8gYWRkRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7U2VsZWN0b3JNZXRob2RTaWduYXR1cmU8VD59IFtzZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAgICAgKiBwb3N0LXByb2Nlc3MgcmVzdWx0cy4gSXQgdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBldmVudCBoYW5kbGVyIGFuZFxuICAgICAqIHNob3VsZCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn1cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBmcm9tRXZlbnRcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zLCBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcm9tRXZlbnRPYnNlcnZhYmxlKHRhcmdldCwgZXZlbnROYW1lLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZTtcbiAgICAgICAgaWYgKGlzTm9kZUxpc3Qoc291cmNlT2JqKSB8fCBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VPYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9ialtpXSwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMSA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8xLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMiA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMi5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc05vZGVTdHlsZUV2ZW50RW1taXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8zID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8zLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlT2JqID0gdGhpcy5zb3VyY2VPYmo7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0aGlzLmV2ZW50TmFtZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRPYnNlcnZhYmxlID0gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRnJvbUV2ZW50T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gcm9tRXZlbnRPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmZyb21FdmVudCA9IEZyb21FdmVudE9ic2VydmFibGVfMS5Gcm9tRXZlbnRPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb21FdmVudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbUV2ZW50ID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkSGFuZGxlciA9IGFkZEhhbmRsZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlSGFuZGxlciA9IHJlbW92ZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gYW4gQVBJIGJhc2VkIG9uIGFkZEhhbmRsZXIvcmVtb3ZlSGFuZGxlclxuICAgICAqIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db252ZXJ0cyBhbnkgYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyIEFQSSB0byBhblxuICAgICAqIE9ic2VydmFibGUuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tRXZlbnRQYXR0ZXJuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGJ5IHVzaW5nIHRoZSBgYWRkSGFuZGxlcmAgYW5kIGByZW1vdmVIYW5kbGVyYFxuICAgICAqIGZ1bmN0aW9ucyB0byBhZGQgYW5kIHJlbW92ZSB0aGUgaGFuZGxlcnMsIHdpdGggYW4gb3B0aW9uYWwgc2VsZWN0b3JcbiAgICAgKiBmdW5jdGlvbiB0byBwcm9qZWN0IHRoZSBldmVudCBhcmd1bWVudHMgdG8gYSByZXN1bHQuIFRoZSBgYWRkSGFuZGxlcmAgaXNcbiAgICAgKiBjYWxsZWQgd2hlbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCwgYW5kIGByZW1vdmVIYW5kbGVyYCBpc1xuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXMgdW5zdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgY2xpY2tzIGhhcHBlbmluZyBvbiB0aGUgRE9NIGRvY3VtZW50PC9jYXB0aW9uPlxuICAgICAqIGZ1bmN0aW9uIGFkZENsaWNrSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHJlbW92ZUNsaWNrSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICogICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudFBhdHRlcm4oXG4gICAgICogICBhZGRDbGlja0hhbmRsZXIsXG4gICAgICogICByZW1vdmVDbGlja0hhbmRsZXJcbiAgICAgKiApO1xuICAgICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFuZGxlcjogRnVuY3Rpb24pOiBhbnl9IGFkZEhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gICAgICogYSBgaGFuZGxlcmAgZnVuY3Rpb24gYXMgYXJndW1lbnQgYW5kIGF0dGFjaGVzIGl0IHNvbWVob3cgdG8gdGhlIGFjdHVhbFxuICAgICAqIHNvdXJjZSBvZiBldmVudHMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihoYW5kbGVyOiBGdW5jdGlvbik6IHZvaWR9IHJlbW92ZUhhbmRsZXIgQSBmdW5jdGlvbiB0aGF0XG4gICAgICogdGFrZXMgYSBgaGFuZGxlcmAgZnVuY3Rpb24gYXMgYXJndW1lbnQgYW5kIHJlbW92ZXMgaXQgaW4gY2FzZSBpdCB3YXNcbiAgICAgKiBwcmV2aW91c2x5IGF0dGFjaGVkIHVzaW5nIGBhZGRIYW5kbGVyYC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFyZ3M6IGFueSk6IFR9IFtzZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAgICAgKiBwb3N0LXByb2Nlc3MgcmVzdWx0cy4gSXQgdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBldmVudCBoYW5kbGVyIGFuZFxuICAgICAqIHNob3VsZCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn1cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBmcm9tRXZlbnRQYXR0ZXJuXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZW1vdmVIYW5kbGVyID0gdGhpcy5yZW1vdmVIYW5kbGVyO1xuICAgICAgICB2YXIgaGFuZGxlciA9ICEhdGhpcy5zZWxlY3RvciA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fY2FsbFNlbGVjdG9yKHN1YnNjcmliZXIsIGFyZ3MpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHsgc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICB0aGlzLl9jYWxsQWRkSGFuZGxlcihoYW5kbGVyLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQobmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL1RPRE86IGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmb3J3YXJkIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIHJlbW92ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2FsbFNlbGVjdG9yID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlbGVjdG9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2FsbEFkZEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgZXJyb3JTdWJzY3JpYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZSA9IEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbUV2ZW50UGF0dGVybiA9IEZyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlXzEuRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50UGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbUV2ZW50UGF0dGVybl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mcm9tRXZlbnRQYXR0ZXJuID0gZnJvbUV2ZW50UGF0dGVybl8xLmZyb21FdmVudFBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnRQYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFByb21pc2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1Byb21pc2VPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmZyb21Qcm9taXNlID0gUHJvbWlzZU9ic2VydmFibGVfMS5Qcm9taXNlT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tUHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbVByb21pc2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZnJvbVByb21pc2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb21Qcm9taXNlID0gZnJvbVByb21pc2VfMS5mcm9tUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21Qcm9taXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgc2VsZlNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgR2VuZXJhdGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2VuZXJhdGVPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlT2JzZXJ2YWJsZShpbml0aWFsU3RhdGUsIGNvbmRpdGlvbiwgaXRlcmF0ZSwgcmVzdWx0U2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLml0ZXJhdGUgPSBpdGVyYXRlO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBHZW5lcmF0ZU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZU9yT3B0aW9ucywgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZU9yT3B0aW9ucy5pbml0aWFsU3RhdGUsIGluaXRpYWxTdGF0ZU9yT3B0aW9ucy5jb25kaXRpb24sIGluaXRpYWxTdGF0ZU9yT3B0aW9ucy5pdGVyYXRlLCBpbml0aWFsU3RhdGVPck9wdGlvbnMucmVzdWx0U2VsZWN0b3IgfHwgc2VsZlNlbGVjdG9yLCBpbml0aWFsU3RhdGVPck9wdGlvbnMuc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUgPT09IHVuZGVmaW5lZCB8fCBpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZU9ic2VydmFibGUoaW5pdGlhbFN0YXRlT3JPcHRpb25zLCBjb25kaXRpb24sIGl0ZXJhdGUsIHNlbGZTZWxlY3RvciwgcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlKGluaXRpYWxTdGF0ZU9yT3B0aW9ucywgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEdlbmVyYXRlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgICAgICBpZiAodGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShHZW5lcmF0ZU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGU6IHRoaXMuaXRlcmF0ZSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHRoaXMuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yOiB0aGlzLnJlc3VsdFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb25kaXRpb24gPSBfYS5jb25kaXRpb24sIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGl0ZXJhdGUgPSBfYS5pdGVyYXRlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvblJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBjb25kaXRpb24oc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbmRpdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRTZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBpdGVyYXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICB9O1xuICAgIEdlbmVyYXRlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIGNvbmRpdGlvbiA9IHN0YXRlLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRJdGVyYXRlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gc3RhdGUuaXRlcmF0ZShzdGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm5lZWRJdGVyYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uUmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBjb25kaXRpb24oc3RhdGUuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbmRpdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZS5yZXN1bHRTZWxlY3RvcihzdGF0ZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIHJldHVybiBHZW5lcmF0ZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkdlbmVyYXRlT2JzZXJ2YWJsZSA9IEdlbmVyYXRlT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlbmVyYXRlT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgR2VuZXJhdGVPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL0dlbmVyYXRlT2JzZXJ2YWJsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZ2VuZXJhdGUgPSBHZW5lcmF0ZU9ic2VydmFibGVfMS5HZW5lcmF0ZU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBJZk9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJZk9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWZPYnNlcnZhYmxlKGNvbmRpdGlvbiwgdGhlblNvdXJjZSwgZWxzZVNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudGhlblNvdXJjZSA9IHRoZW5Tb3VyY2U7XG4gICAgICAgIHRoaXMuZWxzZVNvdXJjZSA9IGVsc2VTb3VyY2U7XG4gICAgfVxuICAgIElmT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWZPYnNlcnZhYmxlKGNvbmRpdGlvbiwgdGhlblNvdXJjZSwgZWxzZVNvdXJjZSk7XG4gICAgfTtcbiAgICBJZk9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb25kaXRpb24gPSBfYS5jb25kaXRpb24sIHRoZW5Tb3VyY2UgPSBfYS50aGVuU291cmNlLCBlbHNlU291cmNlID0gX2EuZWxzZVNvdXJjZTtcbiAgICAgICAgcmV0dXJuIG5ldyBJZlN1YnNjcmliZXIoc3Vic2NyaWJlciwgY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBJZk9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLklmT2JzZXJ2YWJsZSA9IElmT2JzZXJ2YWJsZTtcbnZhciBJZlN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJZlN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWZTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50aGVuU291cmNlID0gdGhlblNvdXJjZTtcbiAgICAgICAgdGhpcy5lbHNlU291cmNlID0gZWxzZVNvdXJjZTtcbiAgICAgICAgdGhpcy50cnlJZigpO1xuICAgIH1cbiAgICBJZlN1YnNjcmliZXIucHJvdG90eXBlLnRyeUlmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb25kaXRpb24gPSBfYS5jb25kaXRpb24sIHRoZW5Tb3VyY2UgPSBfYS50aGVuU291cmNlLCBlbHNlU291cmNlID0gX2EuZWxzZVNvdXJjZTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbmRpdGlvbigpO1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHJlc3VsdCA/IHRoZW5Tb3VyY2UgOiBlbHNlU291cmNlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgc291cmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJZlN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWZPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIElmT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9JZk9ic2VydmFibGUnKTtcbmV4cG9ydHMuX2lmID0gSWZPYnNlcnZhYmxlXzEuSWZPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpZl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9pZicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuaWYgPSBpZl8xLl9pZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xuZnVuY3Rpb24gaXNOdW1lcmljKHZhbCkge1xuICAgIC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcbiAgICAvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG4gICAgLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gICAgLy8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG4gICAgcmV0dXJuICFpc0FycmF5XzEuaXNBcnJheSh2YWwpICYmICh2YWwgLSBwYXJzZUZsb2F0KHZhbCkgKyAxKSA+PSAwO1xufVxuZXhwb3J0cy5pc051bWVyaWMgPSBpc051bWVyaWM7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc051bWVyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBBIHVuaXQgb2Ygd29yayB0byBiZSBleGVjdXRlZCBpbiBhIHtAbGluayBTY2hlZHVsZXJ9LiBBbiBhY3Rpb24gaXMgdHlwaWNhbGx5XG4gKiBjcmVhdGVkIGZyb20gd2l0aGluIGEgU2NoZWR1bGVyIGFuZCBhbiBSeEpTIHVzZXIgZG9lcyBub3QgbmVlZCB0byBjb25jZXJuXG4gKiB0aGVtc2VsdmVzIGFib3V0IGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYW4gQWN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBBY3Rpb248VD4gZXh0ZW5kcyBTdWJzY3JpcHRpb24ge1xuICogICBuZXcgKHNjaGVkdWxlcjogU2NoZWR1bGVyLCB3b3JrOiAoc3RhdGU/OiBUKSA9PiB2b2lkKTtcbiAqICAgc2NoZWR1bGUoc3RhdGU/OiBULCBkZWxheTogbnVtYmVyID0gMCk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBBY3Rpb248VD5cbiAqL1xudmFyIEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhpcyBhY3Rpb24gb24gaXRzIHBhcmVudCBTY2hlZHVsZXIgZm9yIGV4ZWN1dGlvbi4gTWF5IGJlIHBhc3NlZFxuICAgICAqIHNvbWUgY29udGV4dCBvYmplY3QsIGBzdGF0ZWAuIE1heSBoYXBwZW4gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgYGRlbGF5YCBwYXJhbWV0ZXIsIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXldIFRpbWUgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB3b3JrLCB3aGVyZSB0aGVcbiAgICAgKiB0aW1lIHVuaXQgaXMgaW1wbGljaXQgYW5kIGRlZmluZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIEFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBBY3Rpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5BY3Rpb24gPSBBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFzeW5jQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgcmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwZW5kaW5nIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoaXMgYWN0aW9uIGhhcyBiZWVuIHNjaGVkdWxlZCwgb3JcbiAgICAgICAgLy8gaGFzIHJlY3Vyc2l2ZWx5IHJlc2NoZWR1bGVkIGl0c2VsZi5cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICAvL1xuICAgICAgICAvLyBJbXBvcnRhbnQgaW1wbGVtZW50YXRpb24gbm90ZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWN0aW9ucyBvbmx5IGV4ZWN1dGUgb25jZSBieSBkZWZhdWx0LCB1bmxlc3MgcmVzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHNjaGVkdWxlZCBjYWxsYmFjay4gVGhpcyBhbGxvd3MgdXMgdG8gaW1wbGVtZW50IHNpbmdsZSBhbmQgcmVwZWF0XG4gICAgICAgIC8vIGFjdGlvbnMgdmlhIHRoZSBzYW1lIGNvZGUgcGF0aCwgd2l0aG91dCBhZGRpbmcgQVBJIHN1cmZhY2UgYXJlYSwgYXMgd2VsbFxuICAgICAgICAvLyBhcyBtaW1pYyB0cmFkaXRpb25hbCByZWN1cnNpb24gYnV0IGFjcm9zcyBhc3luY2hyb25vdXMgYm91bmRhcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgSlMgcnVudGltZXMgYW5kIHRpbWVycyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGludGVydmFscyBhY2hpZXZlZCBieVxuICAgICAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIHZzLiBhIHNpbmdsZSBgc2V0SW50ZXJ2YWxgIGNhbGwuIEFuIGludGVydmFsIG9mXG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgY2FuIGJlIGluZGl2aWR1YWxseSBkZWxheWVkLCB3aGljaCBkZWxheXNcbiAgICAgICAgLy8gc2NoZWR1bGluZyB0aGUgbmV4dCBgc2V0VGltZW91dGAsIGFuZCBzbyBvbi4gYHNldEludGVydmFsYCBhdHRlbXB0cyB0b1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhlIGludGVydmFsIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBtb3JlIHByZWNpc2VseSB0byB0aGVcbiAgICAgICAgLy8gaW50ZXJ2YWwgcGVyaW9kLCByZWdhcmRsZXNzIG9mIGxvYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2UgdXNlIGBzZXRJbnRlcnZhbGAgdG8gc2NoZWR1bGUgc2luZ2xlIGFuZCByZXBlYXQgYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiByZXNjaGVkdWxlcyBpdHNlbGYgd2l0aCB0aGUgc2FtZSBkZWxheSwgdGhlIGludGVydmFsIGlzIG5vdFxuICAgICAgICAvLyBjYW5jZWxlZC4gSWYgdGhlIGFjdGlvbiBkb2Vzbid0IHJlc2NoZWR1bGUsIG9yIHJlc2NoZWR1bGVzIHdpdGggYVxuICAgICAgICAvLyBkaWZmZXJlbnQgZGVsYXksIHRoZSBpbnRlcnZhbCB3aWxsIGJlIGNhbmNlbGVkIGFmdGVyIHNjaGVkdWxlZCBjYWxsYmFja1xuICAgICAgICAvLyBleGVjdXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBoYXMgYWxyZWFkeSBhbiBhc3luYyBJZCwgZG9uJ3QgcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IHRoaXMucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCB0aGlzLmlkLCBkZWxheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3Quc2V0SW50ZXJ2YWwoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCB0aGlzKSwgZGVsYXkpO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBpcyByZXNjaGVkdWxlZCB3aXRoIHRoZSBzYW1lIGRlbGF5IHRpbWUsIGRvbid0IGNsZWFyIHRoZSBpbnRlcnZhbCBpZC5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIHRoaXMuZGVsYXkgPT09IGRlbGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgYWN0aW9uJ3MgZGVsYXkgdGltZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBkZWxheSxcbiAgICAgICAgLy8gY2xlYXIgdGhlIGludGVydmFsIGlkXG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5jbGVhckludGVydmFsKGlkKSAmJiB1bmRlZmluZWQgfHwgdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgZXhlY3V0ZXMgdGhpcyBhY3Rpb24gYW5kIHRoZSBgd29ya2AgaXQgY29udGFpbnMuXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmcgPT09IGZhbHNlICYmIHRoaXMuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGVxdWV1ZSBpZiB0aGUgYWN0aW9uIGRpZG4ndCByZXNjaGVkdWxlIGl0c2VsZi4gRG9uJ3QgY2FsbFxuICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmUoKSwgYmVjYXVzZSB0aGUgYWN0aW9uIGNvdWxkIHJlc2NoZWR1bGUgbGF0ZXIuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgLy8gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uIGRvV29yayhjb3VudGVyKSB7XG4gICAgICAgICAgICAvLyAgIC8qIC4uLiBJJ20gYSBidXN5IHdvcmtlciBiZWUgLi4uICovXG4gICAgICAgICAgICAvLyAgIHZhciBvcmlnaW5hbEFjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICAvLyAgIC8qIHdhaXQgMTAwbXMgYmVmb3JlIHJlc2NoZWR1bGluZyB0aGUgYWN0aW9uICovXG4gICAgICAgICAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgIG9yaWdpbmFsQWN0aW9uLnNjaGVkdWxlKGNvdW50ZXIgKyAxKTtcbiAgICAgICAgICAgIC8vICAgfSwgMTAwKTtcbiAgICAgICAgICAgIC8vIH0sIDEwMDApO1xuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZCh0aGlzLnNjaGVkdWxlciwgdGhpcy5pZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndvcmsoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUgPSAhIWUgJiYgZSB8fCBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgICAgIHZhciBpbmRleCA9IGFjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgdGhpcy53b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbl8xLkFjdGlvbikpO1xuZXhwb3J0cy5Bc3luY0FjdGlvbiA9IEFzeW5jQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNBY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEFuIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCBhIGRhdGEgc3RydWN0dXJlIHRvIG9yZGVyIHRhc2tzIGFuZCBzY2hlZHVsZSB0aGVpclxuICogZXhlY3V0aW9uLiBQcm92aWRlcyBhIG5vdGlvbiBvZiAocG90ZW50aWFsbHkgdmlydHVhbCkgdGltZSwgdGhyb3VnaCB0aGVcbiAqIGBub3coKWAgZ2V0dGVyIG1ldGhvZC5cbiAqXG4gKiBFYWNoIHVuaXQgb2Ygd29yayBpbiBhIFNjaGVkdWxlciBpcyBjYWxsZWQgYW4ge0BsaW5rIEFjdGlvbn0uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIFNjaGVkdWxlciB7XG4gKiAgIG5vdygpOiBudW1iZXI7XG4gKiAgIHNjaGVkdWxlKHdvcmssIGRlbGF5Pywgc3RhdGU/KTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIFNjaGVkdWxlclxuICovXG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7IG5vdyA9IFNjaGVkdWxlci5ub3c7IH1cbiAgICAgICAgdGhpcy5TY2hlZHVsZXJBY3Rpb24gPSBTY2hlZHVsZXJBY3Rpb247XG4gICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiwgYHdvcmtgLCBmb3IgZXhlY3V0aW9uLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW5cbiAgICAgKiB0aGUgZnV0dXJlLCBhY2NvcmRpbmcgdG8gdGhlIGBkZWxheWAgcGFyYW1ldGVyLCBpZiBzcGVjaWZpZWQuIE1heSBiZSBwYXNzZWRcbiAgICAgKiBzb21lIGNvbnRleHQgb2JqZWN0LCBgc3RhdGVgLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYHdvcmtgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIGFyZ3VtZW50cyB3aWxsIGJlIHByb2Nlc3NlZCBhbiBzdG9yZWQgYXMgYW4gQWN0aW9uIG9iamVjdCBpbiBhXG4gICAgICogcXVldWUgb2YgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RhdGU6ID9UKTogP1N1YnNjcmlwdGlvbn0gd29yayBBIGZ1bmN0aW9uIHJlcHJlc2VudGluZyBhXG4gICAgICogdGFzaywgb3Igc29tZSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgd29yaywgd2hlcmUgdGhlXG4gICAgICogdGltZSB1bml0IGlzIGltcGxpY2l0IGFuZCBkZWZpbmVkIGJ5IHRoZSBTY2hlZHVsZXIgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBBIHN1YnNjcmlwdGlvbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHVuc3Vic2NyaWJlXG4gICAgICogdGhlIHNjaGVkdWxlZCB3b3JrLlxuICAgICAqL1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAod29yaywgZGVsYXksIHN0YXRlKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU2NoZWR1bGVyQWN0aW9uKHRoaXMsIHdvcmspLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIubm93ID0gRGF0ZS5ub3cgPyBEYXRlLm5vdyA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICtuZXcgRGF0ZSgpOyB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xuZXhwb3J0cy5TY2hlZHVsZXIgPSBTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL1NjaGVkdWxlcicpO1xudmFyIEFzeW5jU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNTY2hlZHVsZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBTY2hlZHVsZXIgaXMgY3VycmVudGx5IGV4ZWN1dGluZyBhIGJhdGNoIG9mXG4gICAgICAgICAqIHF1ZXVlZCBhY3Rpb25zLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCBJRCB1c2VkIHRvIHRyYWNrIHRoZSBsYXRlc3QgYXN5bmNocm9ub3VzIHRhc2sgc3VjaCBhcyB0aG9zZVxuICAgICAgICAgKiBjb21pbmcgZnJvbSBgc2V0VGltZW91dGAsIGBzZXRJbnRlcnZhbGAsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLCBhbmRcbiAgICAgICAgICogb3RoZXJzLlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEFzeW5jU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpOyAvLyBleGhhdXN0IHRoZSBzY2hlZHVsZXIgcXVldWVcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jU2NoZWR1bGVyO1xufShTY2hlZHVsZXJfMS5TY2hlZHVsZXIpKTtcbmV4cG9ydHMuQXN5bmNTY2hlZHVsZXIgPSBBc3luY1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFzeW5jQWN0aW9uXzEgPSByZXF1aXJlKCcuL0FzeW5jQWN0aW9uJyk7XG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vQXN5bmNTY2hlZHVsZXInKTtcbmV4cG9ydHMuYXN5bmMgPSBuZXcgQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcihBc3luY0FjdGlvbl8xLkFzeW5jQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEludGVydmFsT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludGVydmFsT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnRlcnZhbE9ic2VydmFibGUocGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKHBlcmlvZCA9PT0gdm9pZCAwKSB7IHBlcmlvZCA9IDA7IH1cbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGVyaW9kID0gcGVyaW9kO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFpc051bWVyaWNfMS5pc051bWVyaWMocGVyaW9kKSB8fCBwZXJpb2QgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgfHwgdHlwZW9mIHNjaGVkdWxlci5zY2hlZHVsZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHNlcXVlbnRpYWwgbnVtYmVycyBldmVyeSBzcGVjaWZpZWRcbiAgICAgKiBpbnRlcnZhbCBvZiB0aW1lLCBvbiBhIHNwZWNpZmllZCBTY2hlZHVsZXIuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgaW5jcmVtZW50YWwgbnVtYmVycyBwZXJpb2RpY2FsbHkgaW4gdGltZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2ludGVydmFsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGludGVydmFsYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZlxuICAgICAqIGFzY2VuZGluZyBpbnRlZ2Vycywgd2l0aCBhIGNvbnN0YW50IGludGVydmFsIG9mIHRpbWUgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaXMgbm90IHNlbnQgaW1tZWRpYXRlbHksIGJ1dFxuICAgICAqIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IHBlcmlvZCBoYXMgcGFzc2VkLiBCeSBkZWZhdWx0LCB0aGlzIG9wZXJhdG9yIHVzZXMgdGhlXG4gICAgICogYGFzeW5jYCBTY2hlZHVsZXIgdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91IG1heSBwYXNzIGFueVxuICAgICAqIFNjaGVkdWxlciB0byBpdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiBudW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHRpbWVyfVxuICAgICAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2Q9MF0gVGhlIGludGVydmFsIHNpemUgaW4gbWlsbGlzZWNvbmRzIChieSBkZWZhdWx0KVxuICAgICAqIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBieSB0aGUgc2NoZWR1bGVyJ3MgY2xvY2suXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzZXF1ZW50aWFsIG51bWJlciBlYWNoIHRpbWVcbiAgICAgKiBpbnRlcnZhbC5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBpbnRlcnZhbFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgSW50ZXJ2YWxPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAocGVyaW9kID09PSB2b2lkIDApIHsgcGVyaW9kID0gMDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsT2JzZXJ2YWJsZShwZXJpb2QsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBJbnRlcnZhbE9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBwZXJpb2QgPSBzdGF0ZS5wZXJpb2Q7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ICs9IDE7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG4gICAgfTtcbiAgICBJbnRlcnZhbE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgcGVyaW9kID0gdGhpcy5wZXJpb2Q7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKEludGVydmFsT2JzZXJ2YWJsZS5kaXNwYXRjaCwgcGVyaW9kLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIsIHBlcmlvZDogcGVyaW9kXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnZhbE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkludGVydmFsT2JzZXJ2YWJsZSA9IEludGVydmFsT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUludGVydmFsT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBJbnRlcnZhbE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vSW50ZXJ2YWxPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmludGVydmFsID0gSW50ZXJ2YWxPYnNlcnZhYmxlXzEuSW50ZXJ2YWxPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVydmFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpbnRlcnZhbF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9pbnRlcnZhbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuaW50ZXJ2YWwgPSBpbnRlcnZhbF8xLmludGVydmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJ2YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIGNvbmN1cnJlbnRseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5IGJsZW5kaW5nXG4gKiB0aGVpciB2YWx1ZXMgaW50byBvbmUgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VgIHN1YnNjcmliZXMgdG8gZWFjaCBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIChlaXRoZXIgdGhlIHNvdXJjZSBvciBhblxuICogT2JzZXJ2YWJsZSBnaXZlbiBhcyBhcmd1bWVudCksIGFuZCBzaW1wbHkgZm9yd2FyZHMgKHdpdGhvdXQgZG9pbmcgYW55XG4gKiB0cmFuc2Zvcm1hdGlvbikgYWxsIHRoZSB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0IE9ic2VydmFibGVzIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5IGNvbXBsZXRlcyBvbmNlIGFsbCBpbnB1dCBPYnNlcnZhYmxlc1xuICogaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnkgYW4gaW5wdXQgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5XG4gKiBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciB0d28gT2JzZXJ2YWJsZXM6IDFzIGludGVydmFsIGFuZCBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3NPclRpbWVyID0gY2xpY2tzLm1lcmdlKHRpbWVyKTtcbiAqIGNsaWNrc09yVGltZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIDMgT2JzZXJ2YWJsZXMsIGJ1dCBvbmx5IDIgcnVuIGNvbmN1cnJlbnRseTwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgY29uY3VycmVudCA9IDI7IC8vIHRoZSBhcmd1bWVudFxuICogdmFyIG1lcmdlZCA9IHRpbWVyMS5tZXJnZSh0aW1lcjIsIHRpbWVyMywgY29uY3VycmVudCk7XG4gKiBtZXJnZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBtZXJnZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIFNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nXG4gKiBjb25jdXJyZW5jeSBvZiBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBldmVyeSBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbChtZXJnZVN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIGNvbmN1cnJlbnRseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5IGJsZW5kaW5nXG4gKiB0aGVpciB2YWx1ZXMgaW50byBvbmUgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VgIHN1YnNjcmliZXMgdG8gZWFjaCBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIChhcyBhcmd1bWVudHMpLCBhbmQgc2ltcGx5XG4gKiBmb3J3YXJkcyAod2l0aG91dCBkb2luZyBhbnkgdHJhbnNmb3JtYXRpb24pIGFsbCB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dFxuICogT2JzZXJ2YWJsZXMgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seSBjb21wbGV0ZXNcbiAqIG9uY2UgYWxsIGlucHV0IE9ic2VydmFibGVzIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5IGFuIGlucHV0XG4gKiBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgdHdvIE9ic2VydmFibGVzOiAxcyBpbnRlcnZhbCBhbmQgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzT3JUaW1lciA9IFJ4Lk9ic2VydmFibGUubWVyZ2UoY2xpY2tzLCB0aW1lcik7XG4gKiBjbGlja3NPclRpbWVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyB0aW1lciB3aWxsIGVtaXQgYXNjZW5kaW5nIHZhbHVlcywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpIHRvIGNvbnNvbGVcbiAqIC8vIGNsaWNrcyBsb2dzIE1vdXNlRXZlbnRzIHRvIGNvbnNvbGUgZXZlcnl0aW1lIHRoZSBcImRvY3VtZW50XCIgaXMgY2xpY2tlZFxuICogLy8gU2luY2UgdGhlIHR3byBzdHJlYW1zIGFyZSBtZXJnZWQgeW91IHNlZSB0aGVzZSBoYXBwZW5pbmdcbiAqIC8vIGFzIHRoZXkgb2NjdXIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgMyBPYnNlcnZhYmxlcywgYnV0IG9ubHkgMiBydW4gY29uY3VycmVudGx5PC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciBjb25jdXJyZW50ID0gMjsgLy8gdGhlIGFyZ3VtZW50XG4gKiB2YXIgbWVyZ2VkID0gUnguT2JzZXJ2YWJsZS5tZXJnZSh0aW1lcjEsIHRpbWVyMiwgdGltZXIzLCBjb25jdXJyZW50KTtcbiAqIG1lcmdlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gLSBGaXJzdCB0aW1lcjEgYW5kIHRpbWVyMiB3aWxsIHJ1biBjb25jdXJyZW50bHlcbiAqIC8vIC0gdGltZXIxIHdpbGwgZW1pdCBhIHZhbHVlIGV2ZXJ5IDEwMDBtcyBmb3IgMTAgaXRlcmF0aW9uc1xuICogLy8gLSB0aW1lcjIgd2lsbCBlbWl0IGEgdmFsdWUgZXZlcnkgMjAwMG1zIGZvciA2IGl0ZXJhdGlvbnNcbiAqIC8vIC0gYWZ0ZXIgdGltZXIxIGhpdHMgaXQncyBtYXggaXRlcmF0aW9uLCB0aW1lcjIgd2lsbFxuICogLy8gICBjb250aW51ZSwgYW5kIHRpbWVyMyB3aWxsIHN0YXJ0IHRvIHJ1biBjb25jdXJyZW50bHkgd2l0aCB0aW1lcjJcbiAqIC8vIC0gd2hlbiB0aW1lcjIgaGl0cyBpdCdzIG1heCBpdGVyYXRpb24gaXQgdGVybWluYXRlcywgYW5kXG4gKiAvLyAgIHRpbWVyMyB3aWxsIGNvbnRpbnVlIHRvIGVtaXQgYSB2YWx1ZSBldmVyeSA1MDBtcyB1bnRpbCBpdCBpcyBjb21wbGV0ZVxuICpcbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICpcbiAqIEBwYXJhbSB7Li4uT2JzZXJ2YWJsZX0gb2JzZXJ2YWJsZXMgSW5wdXQgT2JzZXJ2YWJsZXMgdG8gbWVyZ2UgdG9nZXRoZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgU2NoZWR1bGVyIHRvIHVzZSBmb3IgbWFuYWdpbmdcbiAqIGNvbmN1cnJlbmN5IG9mIGlucHV0IE9ic2VydmFibGVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIHRoYXQgYXJlIHRoZSByZXN1bHQgb2ZcbiAqIGV2ZXJ5IGlucHV0IE9ic2VydmFibGUuXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIG1lcmdlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZVN0YXRpYygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gICAgdmFyIGxhc3QgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihsYXN0KSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICAgICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uY3VycmVudCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25jdXJyZW50ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VTdGF0aWMgPSBtZXJnZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvci9tZXJnZScpO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlXzEubWVyZ2VTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvbWVyZ2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm1lcmdlID0gbWVyZ2VfMS5tZXJnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBmaXJzdCBzb3VyY2UgT2JzZXJ2YWJsZSB0byBlbWl0IGFuIGl0ZW1cbiAqIGZyb20gdGhlIGNvbWJpbmF0aW9uIG9mIHRoaXMgT2JzZXJ2YWJsZSBhbmQgc3VwcGxpZWQgT2JzZXJ2YWJsZXNcbiAqIEBwYXJhbSB7Li4uT2JzZXJ2YWJsZXN9IC4uLm9ic2VydmFibGVzIHNvdXJjZXMgdXNlZCB0byByYWNlIGZvciB3aGljaCBPYnNlcnZhYmxlIGVtaXRzIGZpcnN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIG91dHB1dCBvZiB0aGUgZmlyc3QgT2JzZXJ2YWJsZSB0byBlbWl0IGFuIGl0ZW0uXG4gKiBAbWV0aG9kIHJhY2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJhY2UoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8vIGlmIHRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBpdCB3YXMgbW9zdCBsaWtlbHkgY2FsbGVkIHdpdGhcbiAgICAvLyBgcGFpcihbb2JzMSwgb2JzMiwgLi4uXSlgXG4gICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5XzEuaXNBcnJheShvYnNlcnZhYmxlc1swXSkpIHtcbiAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKHJhY2VTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2VTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8vIGlmIHRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBpdCB3YXMgbW9zdCBsaWtlbHkgY2FsbGVkIHdpdGhcbiAgICAvLyBgcGFpcihbb2JzMSwgb2JzMiwgLi4uXSlgXG4gICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzKS5saWZ0KG5ldyBSYWNlT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLnJhY2VTdGF0aWMgPSByYWNlU3RhdGljO1xudmFyIFJhY2VPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFjZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBSYWNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSYWNlU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFjZU9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuUmFjZU9wZXJhdG9yID0gUmFjZU9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSYWNlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhY2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhY2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBSYWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzLnB1c2gob2JzZXJ2YWJsZSk7XG4gICAgfTtcbiAgICBSYWNlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZXMgPSB0aGlzLm9ic2VydmFibGVzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2YWJsZXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAmJiAhdGhpcy5oYXNGaXJzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlLCBvYnNlcnZhYmxlLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IG91dGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFjZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5SYWNlU3Vic2NyaWJlciA9IFJhY2VTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmFjZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmFjZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucmFjZSA9IHJhY2VfMS5yYWNlU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlOm5vLWVtcHR5ICovXG5mdW5jdGlvbiBub29wKCkgeyB9XG5leHBvcnRzLm5vb3AgPSBub29wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBub29wXzEgPSByZXF1aXJlKCcuLi91dGlsL25vb3AnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgTmV2ZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV2ZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5ldmVyT2JzZXJ2YWJsZSgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5BbiBPYnNlcnZhYmxlIHRoYXQgbmV2ZXIgZW1pdHMgYW55dGhpbmcuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9uZXZlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gICAgICogbmVpdGhlciB2YWx1ZXMgbm9yIGVycm9ycyBub3IgdGhlIGNvbXBsZXRpb24gbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZFxuICAgICAqIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9yIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcy4gUGxlYXNlIG5vdFxuICAgICAqIHRoYXQgYnkgbmV2ZXIgZW1pdHRpbmcgYSBjb21wbGV0ZSBub3RpZmljYXRpb24sIHRoaXMgT2JzZXJ2YWJsZSBrZWVwcyB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gZnJvbSBiZWluZyBkaXNwb3NlZCBhdXRvbWF0aWNhbGx5LiBTdWJzY3JpcHRpb25zIG5lZWQgdG8gYmVcbiAgICAgKiBtYW51YWxseSBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIG5ldmVyIGVtaXQgYW55dGhpbmcgZWxzZSAobm90IGV2ZW4gY29tcGxldGUpLjwvY2FwdGlvbj5cbiAgICAgKiBmdW5jdGlvbiBpbmZvKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ1dpbGwgbm90IGJlIGNhbGxlZCcpO1xuICAgICAqIH1cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5uZXZlcigpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGluZm8sIGluZm8pO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQSBcIm5ldmVyXCIgT2JzZXJ2YWJsZTogbmV2ZXIgZW1pdHMgYW55dGhpbmcuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgbmV2ZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE5ldmVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV2ZXJPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICBOZXZlck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBub29wXzEubm9vcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE5ldmVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuTmV2ZXJPYnNlcnZhYmxlID0gTmV2ZXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV2ZXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE5ldmVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9OZXZlck9ic2VydmFibGUnKTtcbmV4cG9ydHMubmV2ZXIgPSBOZXZlck9ic2VydmFibGVfMS5OZXZlck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV2ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG5ldmVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL25ldmVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5uZXZlciA9IG5ldmVyXzEubmV2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQXJyYXlPYnNlcnZhYmxlJyk7XG5leHBvcnRzLm9mID0gQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlLm9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9mXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL29mJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vZiA9IG9mXzEub2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEZyb21PYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0Zyb21PYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5mdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dCgpIHtcbiAgICB2YXIgbmV4dFNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuZXh0U291cmNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKG5leHRTb3VyY2VzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5XzEuaXNBcnJheShuZXh0U291cmNlc1swXSkpIHtcbiAgICAgICAgbmV4dFNvdXJjZXMgPSBuZXh0U291cmNlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcihuZXh0U291cmNlcykpO1xufVxuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dCA9IG9uRXJyb3JSZXN1bWVOZXh0O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljKCkge1xuICAgIHZhciBuZXh0U291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5leHRTb3VyY2VzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc291cmNlID0gbnVsbDtcbiAgICBpZiAobmV4dFNvdXJjZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXlfMS5pc0FycmF5KG5leHRTb3VyY2VzWzBdKSkge1xuICAgICAgICBuZXh0U291cmNlcyA9IG5leHRTb3VyY2VzWzBdO1xuICAgIH1cbiAgICBzb3VyY2UgPSBuZXh0U291cmNlcy5zaGlmdCgpO1xuICAgIHJldHVybiBuZXcgRnJvbU9ic2VydmFibGVfMS5Gcm9tT2JzZXJ2YWJsZShzb3VyY2UsIG51bGwpLmxpZnQobmV3IE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3IobmV4dFNvdXJjZXMpKTtcbn1cbmV4cG9ydHMub25FcnJvclJlc3VtZU5leHRTdGF0aWMgPSBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYztcbnZhciBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dE9wZXJhdG9yKG5leHRTb3VyY2VzKSB7XG4gICAgICAgIHRoaXMubmV4dFNvdXJjZXMgPSBuZXh0U291cmNlcztcbiAgICB9XG4gICAgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5leHRTb3VyY2VzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcjtcbn0oKSk7XG52YXIgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbmV4dFNvdXJjZXMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMubmV4dFNvdXJjZXMgPSBuZXh0U291cmNlcztcbiAgICB9XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgICB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb05leHRTb3VyY2UoKTtcbiAgICB9O1xuICAgIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICAgIH07XG4gICAgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gICAgfTtcbiAgICBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXIucHJvdG90eXBlLnN1YnNjcmliZVRvTmV4dFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5leHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9uRXJyb3JSZXN1bWVOZXh0U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkVycm9yUmVzdW1lTmV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb25FcnJvclJlc3VtZU5leHRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vbkVycm9yUmVzdW1lTmV4dCA9IG9uRXJyb3JSZXN1bWVOZXh0XzEub25FcnJvclJlc3VtZU5leHRTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkVycm9yUmVzdW1lTmV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbmZ1bmN0aW9uIGRpc3BhdGNoKHN0YXRlKSB7XG4gICAgdmFyIG9iaiA9IHN0YXRlLm9iaiwga2V5cyA9IHN0YXRlLmtleXMsIGxlbmd0aCA9IHN0YXRlLmxlbmd0aCwgaW5kZXggPSBzdGF0ZS5pbmRleCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgaWYgKGluZGV4ID09PSBsZW5ndGgpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICBzdWJzY3JpYmVyLm5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbn1cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgUGFpcnNPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcnNPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJzT2JzZXJ2YWJsZShvYmosIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIG9ic2VydmFibGUgc2VxdWVuY2Ugb2YgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAgICogdXNpbmcgYW4gb3B0aW9uYWwgU2NoZWR1bGVyIHRvIGVudW1lcmF0ZSB0aGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydHMgYSBqYXZhc2NyaXB0IG9iamVjdCB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgICAqIHZhciBvYmogPSB7XG4gICAgICogICBmb286IDQyLFxuICAgICAqICAgYmFyOiA1NixcbiAgICAgKiAgIGJhejogNzhcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUucGFpcnMob2JqKTtcbiAgICAgKlxuICAgICAqIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKFxuICAgICAqICAgZnVuY3Rpb24gKHgpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ05leHQ6ICVzJywgeCk7XG4gICAgICogICB9LFxuICAgICAqICAgZnVuY3Rpb24gKGVycikge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnRXJyb3I6ICVzJywgZXJyKTtcbiAgICAgKiAgIH0sXG4gICAgICogICBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdDb21wbGV0ZWQnKTtcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QgYW5kIHR1cm4gaW50byBhblxuICAgICAqIE9ic2VydmFibGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEFuIG9wdGlvbmFsIFNjaGVkdWxlciB0byBydW4gdGhlXG4gICAgICogZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxuICAgICAqIEByZXR1cm5zIHsoT2JzZXJ2YWJsZTxBcnJheTxzdHJpbmcgfCBUPj4pfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mXG4gICAgICogW2tleSwgdmFsdWVdIHBhaXJzIGZyb20gdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBQYWlyc09ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKG9iaiwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcnNPYnNlcnZhYmxlKG9iaiwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFBhaXJzT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGtleXMgPSBfYS5rZXlzLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIG9iajogdGhpcy5vYmosIGtleXM6IGtleXMsIGxlbmd0aDogbGVuZ3RoLCBpbmRleDogMCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaWR4XTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoW2tleSwgdGhpcy5vYmpba2V5XV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGFpcnNPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5QYWlyc09ic2VydmFibGUgPSBQYWlyc09ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYWlyc09ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUGFpcnNPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1BhaXJzT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5wYWlycyA9IFBhaXJzT2JzZXJ2YWJsZV8xLlBhaXJzT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcGFpcnNfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvcGFpcnMnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnBhaXJzID0gcGFpcnNfMS5wYWlycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhaXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBSYW5nZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYW5nZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNlcXVlbmNlIG9mIG51bWJlcnMgd2l0aGluIGEgc3BlY2lmaWVkXG4gICAgICogcmFuZ2UuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgYSBzZXF1ZW5jZSBvZiBudW1iZXJzIGluIGEgcmFuZ2UuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9yYW5nZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIGByYW5nZWAgb3BlcmF0b3IgZW1pdHMgYSByYW5nZSBvZiBzZXF1ZW50aWFsIGludGVnZXJzLCBpbiBvcmRlciwgd2hlcmUgeW91XG4gICAgICogc2VsZWN0IHRoZSBgc3RhcnRgIG9mIHRoZSByYW5nZSBhbmQgaXRzIGBsZW5ndGhgLiBCeSBkZWZhdWx0LCB1c2VzIG5vXG4gICAgICogU2NoZWR1bGVyIGFuZCBqdXN0IGRlbGl2ZXJzIHRoZSBub3RpZmljYXRpb25zIHN5bmNocm9ub3VzbHksIGJ1dCBtYXkgdXNlXG4gICAgICogYW4gb3B0aW9uYWwgU2NoZWR1bGVyIHRvIHJlZ3VsYXRlIHRob3NlIGRlbGl2ZXJpZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyB0aGUgbnVtYmVycyAxIHRvIDEwPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayB0aW1lcn1cbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnRlZ2VyIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50PTBdIFRoZSBudW1iZXIgb2Ygc2VxdWVudGlhbCBpbnRlZ2VycyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb25zIG9mIHRoZSBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgbnVtYmVycyB0aGF0IGVtaXRzIGEgZmluaXRlIHJhbmdlIG9mXG4gICAgICogc2VxdWVudGlhbCBpbnRlZ2Vycy5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSByYW5nZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgUmFuZ2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdGFydCwgY291bnQsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFJhbmdlT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGF0ZS5zdGFydCwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChzdGFydCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBzdGF0ZS5zdGFydCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBSYW5nZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLl9jb3VudDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFJhbmdlT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdGFydDogc3RhcnQsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCsrID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChzdGFydCsrKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSYW5nZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlJhbmdlT2JzZXJ2YWJsZSA9IFJhbmdlT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJhbmdlT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBSYW5nZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vUmFuZ2VPYnNlcnZhYmxlJyk7XG5leHBvcnRzLnJhbmdlID0gUmFuZ2VPYnNlcnZhYmxlXzEuUmFuZ2VPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByYW5nZV8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9yYW5nZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucmFuZ2UgPSByYW5nZV8xLnJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBVc2luZ09ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVc2luZ09ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXNpbmdPYnNlcnZhYmxlKHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VGYWN0b3J5ID0gcmVzb3VyY2VGYWN0b3J5O1xuICAgICAgICB0aGlzLm9ic2VydmFibGVGYWN0b3J5ID0gb2JzZXJ2YWJsZUZhY3Rvcnk7XG4gICAgfVxuICAgIFVzaW5nT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAocmVzb3VyY2VGYWN0b3J5LCBvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gbmV3IFVzaW5nT2JzZXJ2YWJsZShyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIFVzaW5nT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc291cmNlRmFjdG9yeSA9IF9hLnJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkgPSBfYS5vYnNlcnZhYmxlRmFjdG9yeTtcbiAgICAgICAgdmFyIHJlc291cmNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZUZhY3RvcnkoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXNpbmdTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHJlc291cmNlLCBvYnNlcnZhYmxlRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVXNpbmdPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Vc2luZ09ic2VydmFibGUgPSBVc2luZ09ic2VydmFibGU7XG52YXIgVXNpbmdTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVXNpbmdTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVzaW5nU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcmVzb3VyY2UsIG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVGYWN0b3J5ID0gb2JzZXJ2YWJsZUZhY3Rvcnk7XG4gICAgICAgIGRlc3RpbmF0aW9uLmFkZChyZXNvdXJjZSk7XG4gICAgICAgIHRoaXMudHJ5VXNlKCk7XG4gICAgfVxuICAgIFVzaW5nU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5VXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkuY2FsbCh0aGlzLCB0aGlzLnJlc291cmNlKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHNvdXJjZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBVc2luZ1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXNpbmdPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFVzaW5nT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Vc2luZ09ic2VydmFibGUnKTtcbmV4cG9ydHMudXNpbmcgPSBVc2luZ09ic2VydmFibGVfMS5Vc2luZ09ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHVzaW5nXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3VzaW5nJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS51c2luZyA9IHVzaW5nXzEudXNpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRXJyb3JPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXJyb3JPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVycm9yT2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBubyBpdGVtcyB0byB0aGUgT2JzZXJ2ZXIgYW5kIGltbWVkaWF0ZWx5XG4gICAgICogZW1pdHMgYW4gZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkp1c3QgZW1pdHMgJ2Vycm9yJywgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm93LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBlcnJvciBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlclxuICAgICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIGVtaXQgYW4gZXJyb3IuPC9jYXB0aW9uPlxuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLnRocm93KG5ldyBFcnJvcignb29wcyEnKSkuc3RhcnRXaXRoKDcpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbnMgbnVtYmVycyB0byB0aGUgc2VxdWVuY2UgJ2EnLCAnYicsICdjJywgYnV0IHRocm93IGFuIGVycm9yIGZvciAxMzwvY2FwdGlvbj5cbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAgICogICB4ID09PSAxMyA/XG4gICAgICogICAgIFJ4Lk9ic2VydmFibGUudGhyb3coJ1RoaXJ0ZWVucyBhcmUgYmFkJykgOlxuICAgICAqICAgICBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3IgVGhlIHBhcnRpY3VsYXIgRXJyb3IgdG8gcGFzcyB0byB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIGVycm9yIE9ic2VydmFibGU6IGVtaXRzIG9ubHkgdGhlIGVycm9yIG5vdGlmaWNhdGlvblxuICAgICAqIHVzaW5nIHRoZSBnaXZlbiBlcnJvciBhcmd1bWVudC5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSB0aHJvd1xuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRXJyb3JPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlcnJvciwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgRXJyb3JPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgZXJyb3IgPSBhcmcuZXJyb3IsIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBFcnJvck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmVycm9yO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRXJyb3JPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXJyb3JPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5FcnJvck9ic2VydmFibGUgPSBFcnJvck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXJyb3JPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Vycm9yT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5fdGhyb3cgPSBFcnJvck9ic2VydmFibGVfMS5FcnJvck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRocm93XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3Rocm93Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aHJvdyA9IHRocm93XzEuX3Rocm93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrdmFsdWUpO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgU2NoZWR1bGVyIHRvIHByb3ZpZGUgYSBub3Rpb24gb2YgdGltZSwgYnV0IHlvdVxuICAgICAqIG1heSBwYXNzIGFueSBTY2hlZHVsZXIgdG8gaXQuIElmIGBwZXJpb2RgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpLCBzdGFydGluZyBhZnRlciAzIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDMwMDAsIDEwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgb25lIG51bWJlciBhZnRlciBmaXZlIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDUwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaW50ZXJ2YWx9XG4gICAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRlfSBpbml0aWFsRGVsYXkgVGhlIGluaXRpYWwgZGVsYXkgdGltZSB0byB3YWl0IGJlZm9yZVxuICAgICAqIGVtaXR0aW5nIHRoZSBmaXJzdCB2YWx1ZSBvZiBgMGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2RdIFRoZSBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVtaXNzaW9ucyBvZiB0aGVcbiAgICAgKiBzdWJzZXF1ZW50IG51bWJlcnMuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBlcmlvZCA9IF9hLnBlcmlvZCwgZHVlVGltZSA9IF9hLmR1ZVRpbWUsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgcGVyaW9kOiBwZXJpb2QsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5UaW1lck9ic2VydmFibGUgPSBUaW1lck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVGltZXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1RpbWVyT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy50aW1lciA9IFRpbWVyT2JzZXJ2YWJsZV8xLlRpbWVyT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGltZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvdGltZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnRpbWVyID0gdGltZXJfMS50aW1lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBQcm90bygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKHppcFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLnppcFByb3RvID0gemlwUHJvdG87XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLmxpZnQobmV3IFppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwU3RhdGljID0gemlwU3RhdGljO1xudmFyIFppcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaaXBPcGVyYXRvcihwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFppcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSA/IHByb2plY3QgOiBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljSXRlcmF0b3IodmFsdWVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgWmlwQnVmZmVySXRlcmF0b3IodGhpcy5kZXN0aW5hdGlvbiwgdGhpcywgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5oYXNWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXRlcmF0b3IuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlppcFN1YnNjcmliZXIgPSBaaXBTdWJzY3JpYmVyO1xudmFyIFN0YXRpY0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FycmF5SXRlcmF0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMubGVuZ3RoID8geyB2YWx1ZTogYXJyYXlbaV0sIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID4gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID09PSB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FycmF5SXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBaaXBCdWZmZXJJdGVyYXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcEJ1ZmZlckl0ZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcEJ1ZmZlckl0ZXJhdG9yKGRlc3RpbmF0aW9uLCBwYXJlbnQsIG9ic2VydmFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5zdGlsbFVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBOT1RFOiB0aGVyZSBpcyBhY3R1YWxseSBhIG5hbWUgY29sbGlzaW9uIGhlcmUgd2l0aCBTdWJzY3JpYmVyLm5leHQgYW5kIEl0ZXJhdG9yLm5leHRcbiAgICAvLyAgICB0aGlzIGlzIGxlZ2l0IGJlY2F1c2UgYG5leHQoKWAgd2lsbCBuZXZlciBiZSBjYWxsZWQgYnkgYSBzdWJzY3JpcHRpb24gaW4gdGhpcyBjYXNlLlxuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBidWZmZXIuc2hpZnQoKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5uZXJWYWx1ZSk7XG4gICAgICAgIHRoaXMucGFyZW50LmNoZWNrSXRlcmF0b3JzKCk7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB0aGlzLm9ic2VydmFibGUsIHRoaXMsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBCdWZmZXJJdGVyYXRvcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi9vcGVyYXRvci96aXAnKTtcbmV4cG9ydHMuemlwID0gemlwXzEuemlwU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvemlwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS56aXAgPSB6aXBfMS56aXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEFwcGxpZXMgYSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBhcyBhbiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIFtBcnJheS5wcm90b3R5cGUubWFwKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcCksXG4gKiBpdCBwYXNzZXMgZWFjaCBzb3VyY2UgdmFsdWUgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRvIGdldFxuICogY29ycmVzcG9uZGluZyBvdXRwdXQgdmFsdWVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsIGtub3duIGBBcnJheS5wcm90b3R5cGUubWFwYCBmdW5jdGlvbiwgdGhpcyBvcGVyYXRvclxuICogYXBwbGllcyBhIHByb2plY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgZW1pdHMgdGhhdCBwcm9qZWN0aW9uIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2s8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrcy5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcFRvfVxuICogQHNlZSB7QGxpbmsgcGx1Y2t9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFJ9IHByb2plY3QgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKiB0byBlYWNoIGB2YWx1ZWAgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpc1xuICogdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZVxuICogc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZWZpbmUgd2hhdCBgdGhpc2AgaXMgaW4gdGhlXG4gKiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgbWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xudmFyIE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWFwT3BlcmF0b3IgPSBNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5PVEU6IFRoaXMgbG9va3MgdW5vcHRpbWl6ZWQsIGJ1dCBpdCdzIGFjdHVhbGx5IHB1cnBvc2VmdWxseSBOT1RcbiAgICAvLyB1c2luZyB0cnkvY2F0Y2ggb3B0aW1pemF0aW9ucy5cbiAgICBNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcm9vdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vLi4vU3Vic2NyaWJlcicpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWFwJyk7XG5mdW5jdGlvbiBnZXRDT1JTUmVxdWVzdCgpIHtcbiAgICBpZiAocm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHhociA9IG5ldyByb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISF0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geGhyO1xuICAgIH1cbiAgICBlbHNlIGlmICghIXJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ09SUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFhNTEh0dHBSZXF1ZXN0KCkge1xuICAgIGlmIChyb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJvZ0lkID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb2dJZHMgPSBbJ01zeG1sMi5YTUxIVFRQJywgJ01pY3Jvc29mdC5YTUxIVFRQJywgJ01zeG1sMi5YTUxIVFRQLjQuMCddO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcm9nSWQgPSBwcm9nSWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWpheEdldCh1cmwsIGhlYWRlcnMpIHtcbiAgICBpZiAoaGVhZGVycyA9PT0gdm9pZCAwKSB7IGhlYWRlcnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ0dFVCcsIHVybDogdXJsLCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4R2V0ID0gYWpheEdldDtcbjtcbmZ1bmN0aW9uIGFqYXhQb3N0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQb3N0ID0gYWpheFBvc3Q7XG47XG5mdW5jdGlvbiBhamF4RGVsZXRlKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdERUxFVEUnLCB1cmw6IHVybCwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheERlbGV0ZSA9IGFqYXhEZWxldGU7XG47XG5mdW5jdGlvbiBhamF4UHV0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQVVQnLCB1cmw6IHVybCwgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheFB1dCA9IGFqYXhQdXQ7XG47XG5mdW5jdGlvbiBhamF4R2V0SlNPTih1cmwsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnR0VUJywgdXJsOiB1cmwsIHJlc3BvbnNlVHlwZTogJ2pzb24nLCBoZWFkZXJzOiBoZWFkZXJzIH0pXG4gICAgICAgIC5saWZ0KG5ldyBtYXBfMS5NYXBPcGVyYXRvcihmdW5jdGlvbiAoeCwgaW5kZXgpIHsgcmV0dXJuIHgucmVzcG9uc2U7IH0sIG51bGwpKTtcbn1cbmV4cG9ydHMuYWpheEdldEpTT04gPSBhamF4R2V0SlNPTjtcbjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQWpheE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4T2JzZXJ2YWJsZSh1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVYSFI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcm9zc0RvbWFpbiA/IGdldENPUlNSZXF1ZXN0LmNhbGwodGhpcykgOiBnZXRYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmxPclJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnVybCA9IHVybE9yUmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdXJsT3JSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybE9yUmVxdWVzdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0W3Byb3BdID0gdXJsT3JSZXF1ZXN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH1cbiAgICBBamF4T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWpheFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5yZXF1ZXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBmb3IgYW4gQWpheCByZXF1ZXN0IHdpdGggZWl0aGVyIGEgcmVxdWVzdCBvYmplY3Qgd2l0aFxuICAgICAqIHVybCwgaGVhZGVycywgZXRjIG9yIGEgc3RyaW5nIGZvciBhIFVSTC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc291cmNlID0gUnguT2JzZXJ2YWJsZS5hamF4KCcvcHJvZHVjdHMnKTtcbiAgICAgKiBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmFqYXgoeyB1cmw6ICdwcm9kdWN0cycsIG1ldGhvZDogJ0dFVCcgfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHJlcXVlc3QgQ2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAqICAgQSBzdHJpbmcgb2YgdGhlIFVSTCB0byBtYWtlIHRoZSBBamF4IGNhbGwuXG4gICAgICogICBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAgICAgKiAgIC0gdXJsOiBVUkwgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiAgIC0gYm9keTogVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiAgIC0gbWV0aG9kOiBNZXRob2Qgb2YgdGhlIHJlcXVlc3QsIHN1Y2ggYXMgR0VULCBQT1NULCBQVVQsIFBBVENILCBERUxFVEVcbiAgICAgKiAgIC0gYXN5bmM6IFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYXN5bmNcbiAgICAgKiAgIC0gaGVhZGVyczogT3B0aW9uYWwgaGVhZGVyc1xuICAgICAqICAgLSBjcm9zc0RvbWFpbjogdHJ1ZSBpZiBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0LCBlbHNlIGZhbHNlXG4gICAgICogICAtIGNyZWF0ZVhIUjogYSBmdW5jdGlvbiB0byBvdmVycmlkZSBpZiB5b3UgbmVlZCB0byB1c2UgYW4gYWx0ZXJuYXRlXG4gICAgICogICBYTUxIdHRwUmVxdWVzdCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiAgIC0gcmVzdWx0U2VsZWN0b3I6IGEgZnVuY3Rpb24gdG8gdXNlIHRvIGFsdGVyIHRoZSBvdXRwdXQgdmFsdWUgdHlwZSBvZlxuICAgICAqICAgdGhlIE9ic2VydmFibGUuIEdldHMge0BsaW5rIEFqYXhSZXNwb25zZX0gYXMgYW4gYXJndW1lbnQuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBhamF4XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAqL1xuICAgIEFqYXhPYnNlcnZhYmxlLmNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiAodXJsT3JSZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHVybE9yUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNyZWF0ZS5nZXQgPSBhamF4R2V0O1xuICAgICAgICBjcmVhdGUucG9zdCA9IGFqYXhQb3N0O1xuICAgICAgICBjcmVhdGUuZGVsZXRlID0gYWpheERlbGV0ZTtcbiAgICAgICAgY3JlYXRlLnB1dCA9IGFqYXhQdXQ7XG4gICAgICAgIGNyZWF0ZS5nZXRKU09OID0gYWpheEdldEpTT047XG4gICAgICAgIHJldHVybiBjcmVhdGU7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gQWpheE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFqYXhPYnNlcnZhYmxlID0gQWpheE9ic2VydmFibGU7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFqYXhTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgfHwge307XG4gICAgICAgIC8vIGZvcmNlIENPUlMgaWYgcmVxdWVzdGVkXG4gICAgICAgIGlmICghcmVxdWVzdC5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSBjb250ZW50IHR5cGUgaXMgc2V0XG4gICAgICAgIGlmICghKCdDb250ZW50LVR5cGUnIGluIGhlYWRlcnMpICYmICEocm9vdF8xLnJvb3QuRm9ybURhdGEgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2Ygcm9vdF8xLnJvb3QuRm9ybURhdGEpICYmIHR5cGVvZiByZXF1ZXN0LmJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3Blcmx5IHNlcmlhbGl6ZSBib2R5XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IHRoaXMuc2VyaWFsaXplQm9keShyZXF1ZXN0LmJvZHksIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pO1xuICAgICAgICB0aGlzLnNlbmQoKTtcbiAgICB9XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB4aHIgPSBfYS54aHIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0LCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgQWpheFJlc3BvbnNlKGUsIHhociwgcmVxdWVzdCk7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzcG9uc2UpO1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0LCBfYiA9IF9hLnJlcXVlc3QsIHVzZXIgPSBfYi51c2VyLCBtZXRob2QgPSBfYi5tZXRob2QsIHVybCA9IF9iLnVybCwgYXN5bmMgPSBfYi5hc3luYywgcGFzc3dvcmQgPSBfYi5wYXNzd29yZCwgaGVhZGVycyA9IF9iLmhlYWRlcnMsIGJvZHkgPSBfYi5ib2R5O1xuICAgICAgICB2YXIgY3JlYXRlWEhSID0gcmVxdWVzdC5jcmVhdGVYSFI7XG4gICAgICAgIHZhciB4aHIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNyZWF0ZVhIUikuY2FsbChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHhociA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgICAgICAvLyBvcGVuIFhIUiBmaXJzdFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGltZW91dCBhbmQgcmVzcG9uc2VUeXBlIGNhbiBiZSBzZXQgb25jZSB0aGUgWEhSIGlzIG9wZW5cbiAgICAgICAgICAgIHhoci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgLy8gc2V0IGhlYWRlcnNcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVycyh4aHIsIGhlYWRlcnMpO1xuICAgICAgICAgICAgLy8gbm93IHNldCB1cCB0aGUgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKHhociwgcmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHJlc3VsdCA9IGJvZHkgPyB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhociwgYm9keSkgOiB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhocik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2VyaWFsaXplQm9keSA9IGZ1bmN0aW9uIChib2R5LCBjb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Gb3JtRGF0YSAmJiBib2R5IGluc3RhbmNlb2Ygcm9vdF8xLnJvb3QuRm9ybURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBjb250ZW50VHlwZS5pbmRleE9mKCc7Jyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhib2R5KS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKGVuY29kZVVSSShrZXkpICsgXCI9XCIgKyBlbmNvZGVVUkkoYm9keVtrZXldKSk7IH0pLmpvaW4oJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXRIZWFkZXJzID0gZnVuY3Rpb24gKHhociwgaGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNldHVwRXZlbnRzID0gZnVuY3Rpb24gKHhociwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gcmVxdWVzdC5wcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIGZ1bmN0aW9uIHhoclRpbWVvdXQoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0geGhyVGltZW91dCwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgcmVxdWVzdCA9IF9hLnJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheFRpbWVvdXRFcnJvcih0aGlzLCByZXF1ZXN0KSk7IC8vVE9ETzogTWFrZSBiZXR0ZXJlci5cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSB4aHJUaW1lb3V0O1xuICAgICAgICB4aHJUaW1lb3V0LnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB4aHJUaW1lb3V0LnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICB4aHJUaW1lb3V0LnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKHhoci51cGxvYWQgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyICYmIHJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc1N1YnNjcmliZXIgPSB4aHJQcm9ncmVzc18xLnByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB4aHIub25wcm9ncmVzcyA9IHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeGhyRXJyb3JfMTtcbiAgICAgICAgICAgIHhockVycm9yXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHhockVycm9yXzEsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3InLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHJFcnJvcl8xO1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHhockVycm9yXzEuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB4aHJSZWFkeVN0YXRlQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHhoclJlYWR5U3RhdGVDaGFuZ2UsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNfMSA9IHRoaXMuc3RhdHVzID09PSAxMjIzID8gMjA0IDogdGhpcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gKHRoaXMucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyAodGhpcy5yZXNwb25zZSB8fCB0aGlzLnJlc3BvbnNlVGV4dCkgOiB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNfMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9IHJlc3BvbnNlID8gMjAwIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDIwMCA8PSBzdGF0dXNfMSAmJiBzdGF0dXNfMSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3IgJyArIHN0YXR1c18xLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoclJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2Uuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2UucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkb25lID0gX2EuZG9uZSwgeGhyID0gX2EueGhyO1xuICAgICAgICBpZiAoIWRvbmUgJiYgeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICYmIHR5cGVvZiB4aHIuYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBBamF4U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQWpheFN1YnNjcmliZXIgPSBBamF4U3Vic2NyaWJlcjtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggcmVzcG9uc2UuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheFJlc3BvbnNlXG4gKi9cbnZhciBBamF4UmVzcG9uc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFqYXhSZXNwb25zZShvcmlnaW5hbEV2ZW50LCB4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSB4aHIucmVzcG9uc2VUeXBlIHx8IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBpZiAoJ3Jlc3BvbnNlJyBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JRSBkb2VzIG5vdCBzdXBwb3J0IGpzb24gYXMgcmVzcG9uc2VUeXBlLCBwYXJzZSBpdCBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gKCdyZXNwb25zZScgaW4geGhyKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFqYXhSZXNwb25zZTtcbn0oKSk7XG5leHBvcnRzLkFqYXhSZXNwb25zZSA9IEFqYXhSZXNwb25zZTtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggZXJyb3IuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheEVycm9yXG4gKi9cbnZhciBBamF4RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheEVycm9yKG1lc3NhZ2UsIHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQWpheEVycm9yID0gQWpheEVycm9yO1xuLyoqXG4gKiBAc2VlIHtAbGluayBhamF4fVxuICpcbiAqIEBjbGFzcyBBamF4VGltZW91dEVycm9yXG4gKi9cbnZhciBBamF4VGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheFRpbWVvdXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4VGltZW91dEVycm9yKHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnYWpheCB0aW1lb3V0JywgeGhyLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhUaW1lb3V0RXJyb3I7XG59KEFqYXhFcnJvcikpO1xuZXhwb3J0cy5BamF4VGltZW91dEVycm9yID0gQWpheFRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFqYXhPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFqYXhPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FqYXhPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmFqYXggPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFqYXhfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL29ic2VydmFibGUvZG9tL2FqYXgnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmFqYXggPSBhamF4XzEuYWpheDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBRdWV1ZUFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXVlQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1ZXVlQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICB9XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlci5mbHVzaCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBRdWV1ZUFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIChkZWxheSA+IDAgfHwgdGhpcy5jbG9zZWQpID9cbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZS5jYWxsKHRoaXMsIHN0YXRlLCBkZWxheSkgOlxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgICAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZsdXNoIHRoZSBzY2hlZHVsZXIgc3RhcnRpbmcgd2l0aCB0aGlzIGFjdGlvbi5cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5mbHVzaCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBRdWV1ZUFjdGlvbjtcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xuZXhwb3J0cy5RdWV1ZUFjdGlvbiA9IFF1ZXVlQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWVBY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc3luY1NjaGVkdWxlcicpO1xudmFyIFF1ZXVlU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUXVldWVTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVldWVTY2hlZHVsZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gUXVldWVTY2hlZHVsZXI7XG59KEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIpKTtcbmV4cG9ydHMuUXVldWVTY2hlZHVsZXIgPSBRdWV1ZVNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXVlU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFF1ZXVlQWN0aW9uXzEgPSByZXF1aXJlKCcuL1F1ZXVlQWN0aW9uJyk7XG52YXIgUXVldWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vUXVldWVTY2hlZHVsZXInKTtcbmV4cG9ydHMucXVldWUgPSBuZXcgUXVldWVTY2hlZHVsZXJfMS5RdWV1ZVNjaGVkdWxlcihRdWV1ZUFjdGlvbl8xLlF1ZXVlQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi9TdWJqZWN0Jyk7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL3F1ZXVlJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIG9ic2VydmVPbl8xID0gcmVxdWlyZSgnLi9vcGVyYXRvci9vYnNlcnZlT24nKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEBjbGFzcyBSZXBsYXlTdWJqZWN0PFQ+XG4gKi9cbnZhciBSZXBsYXlTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwbGF5U3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdm9pZCAwKSB7IGJ1ZmZlclNpemUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgaWYgKHdpbmRvd1RpbWUgPT09IHZvaWQgMCkgeyB3aW5kb3dUaW1lID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX2J1ZmZlclNpemUgPSBidWZmZXJTaXplIDwgMSA/IDEgOiBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLl93aW5kb3dUaW1lID0gd2luZG93VGltZSA8IDEgPyAxIDogd2luZG93VGltZTtcbiAgICB9XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5fZ2V0Tm93KCk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG5ldyBSZXBsYXlFdmVudChub3csIHZhbHVlKSk7XG4gICAgICAgIHRoaXMuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9O1xuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX2V2ZW50cyA9IHRoaXMuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzdWJzY3JpYmVyID0gbmV3IG9ic2VydmVPbl8xLk9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgc2NoZWR1bGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IF9ldmVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbiAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KF9ldmVudHNbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLl9nZXROb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zY2hlZHVsZXIgfHwgcXVldWVfMS5xdWV1ZSkubm93KCk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLl9nZXROb3coKTtcbiAgICAgICAgdmFyIF9idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgICAgICAgdmFyIF93aW5kb3dUaW1lID0gdGhpcy5fd2luZG93VGltZTtcbiAgICAgICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIHZhciBldmVudHNDb3VudCA9IF9ldmVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgc3BsaWNlQ291bnQgPSAwO1xuICAgICAgICAvLyBUcmltIGV2ZW50cyB0aGF0IGZhbGwgb3V0IG9mIHRoZSB0aW1lIHdpbmRvdy5cbiAgICAgICAgLy8gU3RhcnQgYXQgdGhlIGZyb250IG9mIHRoZSBsaXN0LiBCcmVhayBlYXJseSBvbmNlXG4gICAgICAgIC8vIHdlIGVuY291bnRlciBhbiBldmVudCB0aGF0IGZhbGxzIHdpdGhpbiB0aGUgd2luZG93LlxuICAgICAgICB3aGlsZSAoc3BsaWNlQ291bnQgPCBldmVudHNDb3VudCkge1xuICAgICAgICAgICAgaWYgKChub3cgLSBfZXZlbnRzW3NwbGljZUNvdW50XS50aW1lKSA8IF93aW5kb3dUaW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGxpY2VDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudHNDb3VudCA+IF9idWZmZXJTaXplKSB7XG4gICAgICAgICAgICBzcGxpY2VDb3VudCA9IE1hdGgubWF4KHNwbGljZUNvdW50LCBldmVudHNDb3VudCAtIF9idWZmZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaWNlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBfZXZlbnRzLnNwbGljZSgwLCBzcGxpY2VDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9ldmVudHM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwbGF5U3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuUmVwbGF5U3ViamVjdCA9IFJlcGxheVN1YmplY3Q7XG52YXIgUmVwbGF5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGxheUV2ZW50KHRpbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlcGxheUV2ZW50O1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheVN1YmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG5mdW5jdGlvbiBhc3NpZ25JbXBsKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIGsgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tdID0gc291cmNlW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLmFzc2lnbkltcGwgPSBhc3NpZ25JbXBsO1xuO1xuZnVuY3Rpb24gZ2V0QXNzaWduKHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC5PYmplY3QuYXNzaWduIHx8IGFzc2lnbkltcGw7XG59XG5leHBvcnRzLmdldEFzc2lnbiA9IGdldEFzc2lnbjtcbmV4cG9ydHMuYXNzaWduID0gZ2V0QXNzaWduKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2lnbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi8uLi9TdWJzY3JpYmVyJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9yb290Jyk7XG52YXIgUmVwbGF5U3ViamVjdF8xID0gcmVxdWlyZSgnLi4vLi4vUmVwbGF5U3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBhc3NpZ25fMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYXNzaWduJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFdlYlNvY2tldFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWJTb2NrZXRTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdlYlNvY2tldFN1YmplY3QodXJsQ29uZmlnT3JTb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmICh1cmxDb25maWdPclNvdXJjZSBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbiwgdXJsQ29uZmlnT3JTb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLldlYlNvY2tldEN0b3IgPSByb290XzEucm9vdC5XZWJTb2NrZXQ7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXQgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsQ29uZmlnT3JTb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cmwgPSB1cmxDb25maWdPclNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGNvbmZpZyBvYmplY3QgY291bGQgb3ZlcnJpZGUgaW1wb3J0YW50IG1lbWJlcnMgaGVyZS5cbiAgICAgICAgICAgICAgICBhc3NpZ25fMS5hc3NpZ24odGhpcywgdXJsQ29uZmlnT3JTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLldlYlNvY2tldEN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFdlYlNvY2tldCBjb25zdHJ1Y3RvciBjYW4gYmUgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgUmVwbGF5U3ViamVjdF8xLlJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5yZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGUuZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdXJsQ29uZmlnT3JTb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtXZWJTb2NrZXRTdWJqZWN0fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIHdlYlNvY2tldFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgV2ViU29ja2V0U3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAodXJsQ29uZmlnT3JTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRTdWJqZWN0KHVybENvbmZpZ09yU291cmNlKTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHNvY2sgPSBuZXcgV2ViU29ja2V0U3ViamVjdCh0aGlzLCB0aGlzLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgc29jay5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc29jaztcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLl9yZXNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgUmVwbGF5U3ViamVjdF8xLlJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vdXRwdXQgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGZhY3RvciB0aGlzIG91dCB0byBiZSBhIHByb3BlciBPcGVyYXRvci9TdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uIGFuZCBlbGltaW5hdGUgY2xvc3VyZXNcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5tdWx0aXBsZXggPSBmdW5jdGlvbiAoc3ViTXNnLCB1bnN1Yk1zZywgbWVzc2FnZUZpbHRlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWJNc2cpKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNlbGYuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2gobWVzc2FnZUZpbHRlcikoeCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBvYnNlcnZlci5lcnJvcihlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5jb21wbGV0ZSgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godW5zdWJNc2cpKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS5fY29ubmVjdFNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIFdlYlNvY2tldEN0b3IgPSB0aGlzLldlYlNvY2tldEN0b3I7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMuX291dHB1dDtcbiAgICAgICAgdmFyIHNvY2tldCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb2NrZXQgPSB0aGlzLnByb3RvY29sID9cbiAgICAgICAgICAgICAgICBuZXcgV2ViU29ja2V0Q3Rvcih0aGlzLnVybCwgdGhpcy5wcm90b2NvbCkgOlxuICAgICAgICAgICAgICAgIG5ldyBXZWJTb2NrZXRDdG9yKHRoaXMudXJsKTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgb3Blbk9ic2VydmVyID0gX3RoaXMub3Blbk9ic2VydmVyO1xuICAgICAgICAgICAgaWYgKG9wZW5PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9wZW5PYnNlcnZlci5uZXh0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gX3RoaXMuZGVzdGluYXRpb247XG4gICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyLmNyZWF0ZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gc29ja2V0LnJlYWR5U3RhdGUgPT09IDEgJiYgc29ja2V0LnNlbmQoeCk7IH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NpbmdPYnNlcnZlciA9IF90aGlzLmNsb3NpbmdPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdPYnNlcnZlci5uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlICYmIGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihuZXcgVHlwZUVycm9yKCdXZWJTb2NrZXRTdWJqZWN0LmVycm9yIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gb2JqZWN0IHdpdGggYW4gZXJyb3IgY29kZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGFuIG9wdGlvbmFsIHJlYXNvbjogeyBjb2RlOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nIH0nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NpbmdPYnNlcnZlciA9IF90aGlzLmNsb3NpbmdPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ09ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NpbmdPYnNlcnZlci5uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChxdWV1ZSAmJiBxdWV1ZSBpbnN0YW5jZW9mIFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChxdWV1ZS5zdWJzY3JpYmUoX3RoaXMuZGVzdGluYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGNsb3NlT2JzZXJ2ZXIgPSBfdGhpcy5jbG9zZU9ic2VydmVyO1xuICAgICAgICAgICAgaWYgKGNsb3NlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBjbG9zZU9ic2VydmVyLm5leHQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS53YXNDbGVhbikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChfdGhpcy5yZXN1bHRTZWxlY3RvcikoZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RTb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKHRoaXMuX291dHB1dC5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzb2NrZXQgPSBfdGhpcy5zb2NrZXQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX291dHB1dC5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBXZWJTb2NrZXRTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc291cmNlID0gX2Euc291cmNlLCBzb2NrZXQgPSBfYS5zb2NrZXQ7XG4gICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgUmVwbGF5U3ViamVjdF8xLlJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdlYlNvY2tldFN1YmplY3Q7XG59KFN1YmplY3RfMS5Bbm9ueW1vdXNTdWJqZWN0KSk7XG5leHBvcnRzLldlYlNvY2tldFN1YmplY3QgPSBXZWJTb2NrZXRTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViU29ja2V0U3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBXZWJTb2NrZXRTdWJqZWN0XzEgPSByZXF1aXJlKCcuL1dlYlNvY2tldFN1YmplY3QnKTtcbmV4cG9ydHMud2ViU29ja2V0ID0gV2ViU29ja2V0U3ViamVjdF8xLldlYlNvY2tldFN1YmplY3QuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViU29ja2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3ZWJTb2NrZXRfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL29ic2VydmFibGUvZG9tL3dlYlNvY2tldCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUud2ViU29ja2V0ID0gd2ViU29ja2V0XzEud2ViU29ja2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViU29ja2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgdW50aWwgYGNsb3NpbmdOb3RpZmllcmAgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LCBhbmQgZW1pdHNcbiAqIHRoYXQgYXJyYXkgb25seSB3aGVuIGFub3RoZXIgT2JzZXJ2YWJsZSBlbWl0cy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9idWZmZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyB0aGUgaW5jb21pbmcgT2JzZXJ2YWJsZSB2YWx1ZXMgdW50aWwgdGhlIGdpdmVuIGBjbG9zaW5nTm90aWZpZXJgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGl0IGVtaXRzIHRoZSBidWZmZXIgb24gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBhbmQgc3RhcnRzIGEgbmV3IGJ1ZmZlciBpbnRlcm5hbGx5LCBhd2FpdGluZyB0aGUgbmV4dCB0aW1lXG4gKiBgY2xvc2luZ05vdGlmaWVyYCBlbWl0cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgZW1pdCBhcnJheSBvZiBtb3N0IHJlY2VudCBpbnRlcnZhbCBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBidWZmZXJlZCA9IGludGVydmFsLmJ1ZmZlcihjbGlja3MpO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IGNsb3NpbmdOb3RpZmllciBBbiBPYnNlcnZhYmxlIHRoYXQgc2lnbmFscyB0aGVcbiAqIGJ1ZmZlciB0byBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VFtdPn0gQW4gT2JzZXJ2YWJsZSBvZiBidWZmZXJzLCB3aGljaCBhcmUgYXJyYXlzIG9mXG4gKiB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyKGNsb3NpbmdOb3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlck9wZXJhdG9yKGNsb3NpbmdOb3RpZmllcikpO1xufVxuZXhwb3J0cy5idWZmZXIgPSBidWZmZXI7XG52YXIgQnVmZmVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlck9wZXJhdG9yKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICB0aGlzLmNsb3NpbmdOb3RpZmllciA9IGNsb3NpbmdOb3RpZmllcjtcbiAgICB9XG4gICAgQnVmZmVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nTm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllcikpO1xuICAgIH1cbiAgICBCdWZmZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIEJ1ZmZlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYnVmZmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9idWZmZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5idWZmZXIgPSBidWZmZXJfMS5idWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyB1bnRpbCB0aGUgc2l6ZSBoaXRzIHRoZSBtYXhpbXVtXG4gKiBgYnVmZmVyU2l6ZWAgZ2l2ZW4uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LCBhbmQgZW1pdHNcbiAqIHRoYXQgYXJyYXkgb25seSB3aGVuIGl0cyBzaXplIHJlYWNoZXMgYGJ1ZmZlclNpemVgLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlckNvdW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgYSBudW1iZXIgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGBidWZmZXJTaXplYCB0aGVuXG4gKiBlbWl0cyB0aGUgYnVmZmVyIGFuZCBjbGVhcnMgaXQsIGFuZCBzdGFydHMgYSBuZXcgYnVmZmVyIGVhY2hcbiAqIGBzdGFydEJ1ZmZlckV2ZXJ5YCB2YWx1ZXMuIElmIGBzdGFydEJ1ZmZlckV2ZXJ5YCBpcyBub3QgcHJvdmlkZWQgb3IgaXNcbiAqIGBudWxsYCwgdGhlbiBuZXcgYnVmZmVycyBhcmUgc3RhcnRlZCBpbW1lZGlhdGVseSBhdCB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZVxuICogYW5kIHdoZW4gZWFjaCBidWZmZXIgY2xvc2VzIGFuZCBpcyBlbWl0dGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIGxhc3QgdHdvIGNsaWNrIGV2ZW50cyBhcyBhbiBhcnJheTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyQ291bnQoMik7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2ssIGVtaXQgdGhlIGxhc3QgdHdvIGNsaWNrIGV2ZW50cyBhcyBhbiBhcnJheTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyQ291bnQoMiwgMSk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayBwYWlyd2lzZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJTaXplIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIGJ1ZmZlciBlbWl0dGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydEJ1ZmZlckV2ZXJ5XSBJbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBhIG5ldyBidWZmZXIuXG4gKiBGb3IgZXhhbXBsZSBpZiBgc3RhcnRCdWZmZXJFdmVyeWAgaXMgYDJgLCB0aGVuIGEgbmV3IGJ1ZmZlciB3aWxsIGJlIHN0YXJ0ZWRcbiAqIG9uIGV2ZXJ5IG90aGVyIHZhbHVlIGZyb20gdGhlIHNvdXJjZS4gQSBuZXcgYnVmZmVyIGlzIHN0YXJ0ZWQgYXQgdGhlXG4gKiBiZWdpbm5pbmcgb2YgdGhlIHNvdXJjZSBieSBkZWZhdWx0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBPYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlckNvdW50XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJDb3VudChidWZmZXJTaXplLCBzdGFydEJ1ZmZlckV2ZXJ5KSB7XG4gICAgaWYgKHN0YXJ0QnVmZmVyRXZlcnkgPT09IHZvaWQgMCkgeyBzdGFydEJ1ZmZlckV2ZXJ5ID0gbnVsbDsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlckNvdW50T3BlcmF0b3IoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkpO1xufVxuZXhwb3J0cy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xudmFyIEJ1ZmZlckNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckNvdW50T3BlcmF0b3IoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgIH1cbiAgICBCdWZmZXJDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyU2l6ZSwgdGhpcy5zdGFydEJ1ZmZlckV2ZXJ5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyQ291bnRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEJ1ZmZlckNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlckNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyRXZlcnkgPSBzdGFydEJ1ZmZlckV2ZXJ5O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIEJ1ZmZlckNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCsrO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLCBidWZmZXJTaXplID0gX2EuYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSA9IF9hLnN0YXJ0QnVmZmVyRXZlcnksIGJ1ZmZlcnMgPSBfYS5idWZmZXJzO1xuICAgICAgICB2YXIgc3RhcnRPbiA9IChzdGFydEJ1ZmZlckV2ZXJ5ID09IG51bGwpID8gYnVmZmVyU2l6ZSA6IHN0YXJ0QnVmZmVyRXZlcnk7XG4gICAgICAgIGlmIChjb3VudCAlIHN0YXJ0T24gPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGJ1ZmZlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSBidWZmZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgICAgIHdoaWxlIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJDb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYnVmZmVyQ291bnRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlckNvdW50Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyQ291bnQgPSBidWZmZXJDb3VudF8xLmJ1ZmZlckNvdW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyQ291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGZvciBhIHNwZWNpZmljIHRpbWUgcGVyaW9kLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheSwgYW5kIGVtaXRzXG4gKiB0aG9zZSBhcnJheXMgcGVyaW9kaWNhbGx5IGluIHRpbWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBCdWZmZXJzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgZm9yIGEgc3BlY2lmaWMgdGltZSBkdXJhdGlvbiBgYnVmZmVyVGltZVNwYW5gLlxuICogVW5sZXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgaXMgZ2l2ZW4sIGl0IGVtaXRzIGFuZFxuICogcmVzZXRzIHRoZSBidWZmZXIgZXZlcnkgYGJ1ZmZlclRpbWVTcGFuYCBtaWxsaXNlY29uZHMuIElmXG4gKiBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgaXMgZ2l2ZW4sIHRoaXMgb3BlcmF0b3Igb3BlbnMgdGhlIGJ1ZmZlciBldmVyeVxuICogYGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyBhbmQgY2xvc2VzIChlbWl0cyBhbmQgcmVzZXRzKSB0aGVcbiAqIGJ1ZmZlciBldmVyeSBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcy4gV2hlbiB0aGUgb3B0aW9uYWwgYXJndW1lbnRcbiAqIGBtYXhCdWZmZXJTaXplYCBpcyBzcGVjaWZpZWQsIHRoZSBidWZmZXIgd2lsbCBiZSBjbG9zZWQgZWl0aGVyIGFmdGVyXG4gKiBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcyBvciB3aGVuIGl0IGNvbnRhaW5zIGBtYXhCdWZmZXJTaXplYCBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBzZWNvbmQsIGVtaXQgYW4gYXJyYXkgb2YgdGhlIHJlY2VudCBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRpbWUoMTAwMCk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgNSBzZWNvbmRzLCBlbWl0IHRoZSBjbGljayBldmVudHMgZnJvbSB0aGUgbmV4dCAyIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRpbWUoMjAwMCwgNTAwMCk7XG4gKiBidWZmZXJlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVGltZVNwYW4gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGZpbGwgZWFjaCBidWZmZXIgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckNyZWF0aW9uSW50ZXJ2YWxdIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEJ1ZmZlclNpemVdIFRoZSBtYXhpbXVtIGJ1ZmZlciBzaXplLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBzY2hlZHVsZXIgb24gd2hpY2ggdG8gc2NoZWR1bGUgdGhlXG4gKiBpbnRlcnZhbHMgdGhhdCBkZXRlcm1pbmUgYnVmZmVyIGJvdW5kYXJpZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVGltZShidWZmZXJUaW1lU3Bhbikge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IG51bGw7XG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIHZhciBtYXhCdWZmZXJTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgICBtYXhCdWZmZXJTaXplID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJUaW1lT3BlcmF0b3IoYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIG1heEJ1ZmZlclNpemUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5idWZmZXJUaW1lID0gYnVmZmVyVGltZTtcbnZhciBCdWZmZXJUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRpbWVPcGVyYXRvcihidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyVGltZVNwYW4gPSBidWZmZXJUaW1lU3BhbjtcbiAgICAgICAgdGhpcy5idWZmZXJDcmVhdGlvbkludGVydmFsID0gYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhCdWZmZXJTaXplID0gbWF4QnVmZmVyU2l6ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIEJ1ZmZlclRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlclRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyVGltZVNwYW4sIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgdGhpcy5tYXhCdWZmZXJTaXplLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRpbWVPcGVyYXRvcjtcbn0oKSk7XG52YXIgQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBCdWZmZXJUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBidWZmZXJUaW1lU3BhbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgbWF4QnVmZmVyU2l6ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5idWZmZXJUaW1lU3BhbiA9IGJ1ZmZlclRpbWVTcGFuO1xuICAgICAgICB0aGlzLmJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBidWZmZXJDcmVhdGlvbkludGVydmFsO1xuICAgICAgICB0aGlzLm1heEJ1ZmZlclNpemUgPSBtYXhCdWZmZXJTaXplO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMub3BlbkNvbnRleHQoKTtcbiAgICAgICAgdGhpcy50aW1lc3Bhbk9ubHkgPSBidWZmZXJDcmVhdGlvbkludGVydmFsID09IG51bGwgfHwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA8IDA7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzcGFuT25seSkge1xuICAgICAgICAgICAgdmFyIHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0LCBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJUaW1lU3Bhbk9ubHksIGJ1ZmZlclRpbWVTcGFuLCB0aW1lU3Bhbk9ubHlTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNsb3NlU3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIGNvbnRleHQ6IGNvbnRleHQgfTtcbiAgICAgICAgICAgIHZhciBjcmVhdGlvblN0YXRlID0geyBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIHN1YnNjcmliZXI6IHRoaXMsIHNjaGVkdWxlcjogc2NoZWR1bGVyIH07XG4gICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LmNsb3NlQWN0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoQnVmZmVyQ2xvc2UsIGJ1ZmZlclRpbWVTcGFuLCBjbG9zZVN0YXRlKSk7XG4gICAgICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJDcmVhdGlvbiwgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgY3JlYXRpb25TdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICB2YXIgZmlsbGVkQnVmZmVyQ29udGV4dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGZpbGxlZEJ1ZmZlckNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxsZWRCdWZmZXJDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm9uQnVmZmVyRnVsbChmaWxsZWRCdWZmZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0cy5sZW5ndGggPSAwO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBCdWZmZXJUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250ZXh0cyA9IF9hLmNvbnRleHRzLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAoY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLm9uQnVmZmVyRnVsbCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2xvc2VDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB2YXIgY2xvc2VBY3Rpb24gPSBjb250ZXh0LmNsb3NlQWN0aW9uO1xuICAgICAgICBjbG9zZUFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlbW92ZShjbG9zZUFjdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy50aW1lc3Bhbk9ubHkpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLm9wZW5Db250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgYnVmZmVyVGltZVNwYW4gPSB0aGlzLmJ1ZmZlclRpbWVTcGFuO1xuICAgICAgICAgICAgdmFyIHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0OiBjb250ZXh0LCBidWZmZXJUaW1lU3BhbjogYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seSwgYnVmZmVyVGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG4gICAgQnVmZmVyVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsb3NlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBzcGxpY2VJbmRleCA9IGNvbnRleHRzID8gY29udGV4dHMuaW5kZXhPZihjb250ZXh0KSA6IC0xO1xuICAgICAgICBpZiAoc3BsaWNlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29udGV4dHMuc3BsaWNlKGNvbnRleHRzLmluZGV4T2YoY29udGV4dCksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICB2YXIgcHJldkNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgIGlmIChwcmV2Q29udGV4dCkge1xuICAgICAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChwcmV2Q29udGV4dCk7XG4gICAgfVxuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IHN1YnNjcmliZXIub3BlbkNvbnRleHQoKTtcbiAgICAgICAgc3RhdGUuY29udGV4dC5jbG9zZUFjdGlvbiA9IHRoaXMuc2NoZWR1bGUoc3RhdGUsIHN0YXRlLmJ1ZmZlclRpbWVTcGFuKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNyZWF0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPSBzdGF0ZS5idWZmZXJDcmVhdGlvbkludGVydmFsLCBidWZmZXJUaW1lU3BhbiA9IHN0YXRlLmJ1ZmZlclRpbWVTcGFuLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyO1xuICAgIHZhciBjb250ZXh0ID0gc3Vic2NyaWJlci5vcGVuQ29udGV4dCgpO1xuICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoY29udGV4dC5jbG9zZUFjdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlckNsb3NlLCBidWZmZXJUaW1lU3BhbiwgeyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLCBjb250ZXh0OiBjb250ZXh0IH0pKTtcbiAgICAgICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBidWZmZXJDcmVhdGlvbkludGVydmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNsb3NlKGFyZykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIGNvbnRleHQgPSBhcmcuY29udGV4dDtcbiAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChjb250ZXh0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGJ1ZmZlclRpbWVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlclRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5idWZmZXJUaW1lID0gYnVmZmVyVGltZV8xLmJ1ZmZlclRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEJ1ZmZlcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBzdGFydGluZyBmcm9tIGFuIGVtaXNzaW9uIGZyb21cbiAqIGBvcGVuaW5nc2AgYW5kIGVuZGluZyB3aGVuIHRoZSBvdXRwdXQgb2YgYGNsb3NpbmdTZWxlY3RvcmAgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LiBTdGFydHNcbiAqIGNvbGxlY3Rpbmcgb25seSB3aGVuIGBvcGVuaW5nYCBlbWl0cywgYW5kIGNhbGxzIHRoZSBgY2xvc2luZ1NlbGVjdG9yYFxuICogZnVuY3Rpb24gdG8gZ2V0IGFuIE9ic2VydmFibGUgdGhhdCB0ZWxscyB3aGVuIHRvIGNsb3NlIHRoZSBidWZmZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyVG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBieSBvcGVuaW5nIHRoZSBidWZmZXIgdmlhIHNpZ25hbHMgZnJvbSBhblxuICogT2JzZXJ2YWJsZSBwcm92aWRlZCB0byBgb3BlbmluZ3NgLCBhbmQgY2xvc2luZyBhbmQgc2VuZGluZyB0aGUgYnVmZmVycyB3aGVuXG4gKiBhIFN1YnNjcmliYWJsZSBvciBQcm9taXNlIHJldHVybmVkIGJ5IHRoZSBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBvdGhlciBzZWNvbmQsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDUwMG1zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBvcGVuaW5ncyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyVG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtTdWJzY3JpYmFibGVPclByb21pc2U8Tz59IG9wZW5pbmdzIEEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2Ugb2Ygbm90aWZpY2F0aW9ucyB0byBzdGFydCBuZXdcbiAqIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzXG4gKiB0aGUgdmFsdWUgZW1pdHRlZCBieSB0aGUgYG9wZW5pbmdzYCBvYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgU3Vic2NyaWJhYmxlIG9yIFByb21pc2UsXG4gKiB3aGljaCwgd2hlbiBpdCBlbWl0cywgc2lnbmFscyB0aGF0IHRoZSBhc3NvY2lhdGVkIGJ1ZmZlciBzaG91bGQgYmUgZW1pdHRlZFxuICogYW5kIGNsZWFyZWQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyVG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBidWZmZXJUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlclRvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuYnVmZmVyVG9nZ2xlID0gYnVmZmVyVG9nZ2xlO1xudmFyIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9wZW5pbmdzLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvcGVuaW5ncykpO1xuICAgIH1cbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZXh0c1tpXS5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgY29udGV4dC5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBvdXRlclZhbHVlID8gdGhpcy5jbG9zZUJ1ZmZlcihvdXRlclZhbHVlKSA6IHRoaXMub3BlbkJ1ZmZlcihpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuY2xvc2VCdWZmZXIoaW5uZXJTdWIuY29udGV4dCk7XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ1NlbGVjdG9yID0gdGhpcy5jbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ05vdGlmaWVyID0gY2xvc2luZ1NlbGVjdG9yLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKGNsb3NpbmdOb3RpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuY2xvc2VCdWZmZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICBpZiAoY29udGV4dHMgJiYgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGNvbnRleHQuYnVmZmVyLCBzdWJzY3JpcHRpb24gPSBjb250ZXh0LnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgY29udGV4dHMuc3BsaWNlKGNvbnRleHRzLmluZGV4T2YoY29udGV4dCksIDEpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdWZmZXJUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2xvc2luZ05vdGlmaWVyKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7IGJ1ZmZlcjogYnVmZmVyLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiB9O1xuICAgICAgICBjb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllciwgY29udGV4dCk7XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQnVmZmVyKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlclRvZ2dsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyVG9nZ2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBidWZmZXJUb2dnbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2J1ZmZlclRvZ2dsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlclRvZ2dsZSA9IGJ1ZmZlclRvZ2dsZV8xLmJ1ZmZlclRvZ2dsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlclRvZ2dsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzLCB1c2luZyBhIGZhY3RvcnkgZnVuY3Rpb24gb2YgY2xvc2luZ1xuICogT2JzZXJ2YWJsZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gY2xvc2UsIGVtaXQsIGFuZCByZXNldCB0aGUgYnVmZmVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheS4gV2hlbiBpdFxuICogc3RhcnRzIGNvbGxlY3RpbmcgdmFsdWVzLCBpdCBjYWxscyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXRcbiAqIHRlbGxzIHdoZW4gdG8gY2xvc2UgdGhlIGJ1ZmZlciBhbmQgcmVzdGFydCBjb2xsZWN0aW5nLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlcldoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogT3BlbnMgYSBidWZmZXIgaW1tZWRpYXRlbHksIHRoZW4gY2xvc2VzIHRoZSBidWZmZXIgd2hlbiB0aGUgb2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgY2FsbGluZyBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cyBhIHZhbHVlLiBXaGVuIGl0IGNsb3Nlc1xuICogdGhlIGJ1ZmZlciwgaXQgaW1tZWRpYXRlbHkgb3BlbnMgYSBuZXcgYnVmZmVyIGFuZCByZXBlYXRzIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgYW4gYXJyYXkgb2YgdGhlIGxhc3QgY2xpY2tzIGV2ZXJ5IFsxLTVdIHJhbmRvbSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJXaGVuKCgpID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCArIE1hdGgucmFuZG9tKCkgKiA0MDAwKVxuICogKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogT2JzZXJ2YWJsZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIGJ1ZmZlciBjbG9zdXJlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBvYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlcldoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcldoZW4oY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgQnVmZmVyV2hlbk9wZXJhdG9yKGNsb3NpbmdTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5idWZmZXJXaGVuID0gYnVmZmVyV2hlbjtcbnZhciBCdWZmZXJXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlcldoZW5PcGVyYXRvcihjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIEJ1ZmZlcldoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlcldoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyV2hlbk9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQnVmZmVyV2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWZmZXJXaGVuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJXaGVuU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuQnVmZmVyKCk7XG4gICAgfVxuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIEJ1ZmZlcldoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5vcGVuQnVmZmVyKCk7XG4gICAgfTtcbiAgICBCdWZmZXJXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5CdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyV2hlblN1YnNjcmliZXIucHJvdG90eXBlLm9wZW5CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbG9zaW5nU3Vic2NyaXB0aW9uID0gdGhpcy5jbG9zaW5nU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoY2xvc2luZ1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2xvc2luZ1N1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHZhciBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY2xvc2luZ1NlbGVjdG9yKSgpO1xuICAgICAgICBpZiAoY2xvc2luZ05vdGlmaWVyID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jbG9zaW5nU3Vic2NyaXB0aW9uID0gY2xvc2luZ1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNsb3NpbmdTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IHRydWU7XG4gICAgICAgICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllcikpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyV2hlblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyV2hlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYnVmZmVyV2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYnVmZmVyV2hlbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlcldoZW4gPSBidWZmZXJXaGVuXzEuYnVmZmVyV2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlcldoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENhdGNoZXMgZXJyb3JzIG9uIHRoZSBvYnNlcnZhYmxlIHRvIGJlIGhhbmRsZWQgYnkgcmV0dXJuaW5nIGEgbmV3IG9ic2VydmFibGUgb3IgdGhyb3dpbmcgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzZWxlY3RvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXMgYXJndW1lbnRzIGBlcnJgLCB3aGljaCBpcyB0aGUgZXJyb3IsIGFuZCBgY2F1Z2h0YCwgd2hpY2hcbiAqICBpcyB0aGUgc291cmNlIG9ic2VydmFibGUsIGluIGNhc2UgeW91J2QgbGlrZSB0byBcInJldHJ5XCIgdGhhdCBvYnNlcnZhYmxlIGJ5IHJldHVybmluZyBpdCBhZ2Fpbi4gV2hhdGV2ZXIgb2JzZXJ2YWJsZVxuICogIGlzIHJldHVybmVkIGJ5IHRoZSBgc2VsZWN0b3JgIHdpbGwgYmUgdXNlZCB0byBjb250aW51ZSB0aGUgb2JzZXJ2YWJsZSBjaGFpbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIG9ic2VydmFibGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGhlIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgdGhlXG4gKiAgY2F0Y2ggYHNlbGVjdG9yYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgY2F0Y2hcbiAqIEBuYW1lIGNhdGNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfY2F0Y2goc2VsZWN0b3IpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcik7XG4gICAgdmFyIGNhdWdodCA9IHRoaXMubGlmdChvcGVyYXRvcik7XG4gICAgcmV0dXJuIChvcGVyYXRvci5jYXVnaHQgPSBjYXVnaHQpO1xufVxuZXhwb3J0cy5fY2F0Y2ggPSBfY2F0Y2g7XG52YXIgQ2F0Y2hPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIENhdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDYXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zZWxlY3RvciwgdGhpcy5jYXVnaHQpKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRjaE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQ2F0Y2hTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2VsZWN0b3IsIGNhdWdodCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYXVnaHQgPSBjYXVnaHQ7XG4gICAgfVxuICAgIC8vIE5PVEU6IG92ZXJyaWRpbmcgYGVycm9yYCBpbnN0ZWFkIG9mIGBfZXJyb3JgIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGhhdmUgdGhpcyBmbGFnIHRoaXMgc3Vic2NyaWJlciBhcyBgaXNTdG9wcGVkYC5cbiAgICBDYXRjaFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdG9yKGVyciwgdGhpcy5jYXVnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhdGNoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NhdGNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbWJpbmVMYXRlc3RfMSA9IHJlcXVpcmUoJy4vY29tYmluZUxhdGVzdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5IHdhaXRpbmdcbiAqIGZvciB0aGUgb3V0ZXIgT2JzZXJ2YWJsZSB0byBjb21wbGV0ZSwgdGhlbiBhcHBseWluZyB7QGxpbmsgY29tYmluZUxhdGVzdH0uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgYnkgYXBwbHlpbmdcbiAqIHtAbGluayBjb21iaW5lTGF0ZXN0fSB3aGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb21iaW5lQWxsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRha2VzIGFuIE9ic2VydmFibGUgb2YgT2JzZXJ2YWJsZXMsIGFuZCBjb2xsZWN0cyBhbGwgT2JzZXJ2YWJsZXMgZnJvbSBpdC5cbiAqIE9uY2UgdGhlIG91dGVyIE9ic2VydmFibGUgY29tcGxldGVzLCBpdCBzdWJzY3JpYmVzIHRvIGFsbCBjb2xsZWN0ZWRcbiAqIE9ic2VydmFibGVzIGFuZCBjb21iaW5lcyB0aGVpciB2YWx1ZXMgdXNpbmcgdGhlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogc3RyYXRlZ3ksIHN1Y2ggdGhhdDpcbiAqIC0gRXZlcnkgdGltZSBhbiBpbm5lciBPYnNlcnZhYmxlIGVtaXRzLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMuXG4gKiAtIFdoZW4gdGhlIHJldHVybmVkIG9ic2VydmFibGUgZW1pdHMsIGl0IGVtaXRzIGFsbCBvZiB0aGUgbGF0ZXN0IHZhbHVlcyBieTpcbiAqICAgLSBJZiBhIGBwcm9qZWN0YCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaXQgaXMgY2FsbGVkIHdpdGggZWFjaCByZWNlbnQgdmFsdWVcbiAqICAgICBmcm9tIGVhY2ggaW5uZXIgT2JzZXJ2YWJsZSBpbiB3aGF0ZXZlciBvcmRlciB0aGV5IGFycml2ZWQsIGFuZCB0aGUgcmVzdWx0XG4gKiAgICAgb2YgdGhlIGBwcm9qZWN0YCBmdW5jdGlvbiBpcyB3aGF0IGlzIGVtaXR0ZWQgYnkgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogICAtIElmIHRoZXJlIGlzIG5vIGBwcm9qZWN0YCBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBtb3N0IHJlY2VudFxuICogICAgIHZhbHVlcyBpcyBlbWl0dGVkIGJ5IHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgdHdvIGNsaWNrIGV2ZW50cyB0byBhIGZpbml0ZSBpbnRlcnZhbCBPYnNlcnZhYmxlLCB0aGVuIGFwcGx5IGNvbWJpbmVBbGw8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcChldiA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKE1hdGgucmFuZG9tKCkqMjAwMCkudGFrZSgzKVxuICogKS50YWtlKDIpO1xuICogdmFyIHJlc3VsdCA9IGhpZ2hlck9yZGVyLmNvbWJpbmVBbGwoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9qZWN0XSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBtYXAgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlubmVyIE9ic2VydmFibGUgaW50byBhIG5ldyByZXN1bHQuIFRha2VzIGVhY2ggb2YgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZXMgZnJvbSBlYWNoIGNvbGxlY3RlZCBpbm5lciBPYnNlcnZhYmxlIGFzIGFyZ3VtZW50cywgaW4gb3JkZXIuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCByZXN1bHRzIG9yIGFycmF5cyBvZiByZWNlbnRcbiAqIHZhbHVlcy5cbiAqIEBtZXRob2QgY29tYmluZUFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29tYmluZUFsbChwcm9qZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgY29tYmluZUxhdGVzdF8xLkNvbWJpbmVMYXRlc3RPcGVyYXRvcihwcm9qZWN0KSk7XG59XG5leHBvcnRzLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZUFsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY29tYmluZUFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29tYmluZUFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbWJpbmVBbGwgPSBjb21iaW5lQWxsXzEuY29tYmluZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbWJpbmVMYXRlc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbWJpbmVMYXRlc3QnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb21iaW5lTGF0ZXN0ID0gY29tYmluZUxhdGVzdF8xLmNvbWJpbmVMYXRlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lTGF0ZXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbmNhdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbmNhdCA9IGNvbmNhdF8xLmNvbmNhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZUFsbF8xID0gcmVxdWlyZSgnLi9tZXJnZUFsbCcpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgYnlcbiAqIGNvbmNhdGVuYXRpbmcgdGhlIGlubmVyIE9ic2VydmFibGVzIGluIG9yZGVyLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IHB1dHRpbmcgb25lXG4gKiBpbm5lciBPYnNlcnZhYmxlIGFmdGVyIHRoZSBvdGhlci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXRBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSm9pbnMgZXZlcnkgT2JzZXJ2YWJsZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgKGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUpLCBpblxuICogYSBzZXJpYWwgZmFzaGlvbi4gSXQgc3Vic2NyaWJlcyB0byBlYWNoIGlubmVyIE9ic2VydmFibGUgb25seSBhZnRlciB0aGVcbiAqIHByZXZpb3VzIGlubmVyIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZCwgYW5kIG1lcmdlcyBhbGwgb2YgdGhlaXIgdmFsdWVzIGludG9cbiAqIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlLlxuICpcbiAqIF9fV2FybmluZzpfXyBJZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgT2JzZXJ2YWJsZXMgcXVpY2tseSBhbmRcbiAqIGVuZGxlc3NseSwgYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlcyBpdCBlbWl0cyBnZW5lcmFsbHkgY29tcGxldGUgc2xvd2VyIHRoYW5cbiAqIHRoZSBzb3VyY2UgZW1pdHMsIHlvdSBjYW4gcnVuIGludG8gbWVtb3J5IGlzc3VlcyBhcyB0aGUgaW5jb21pbmcgT2JzZXJ2YWJsZXNcbiAqIGNvbGxlY3QgaW4gYW4gdW5ib3VuZGVkIGJ1ZmZlci5cbiAqXG4gKiBOb3RlOiBgY29uY2F0QWxsYCBpcyBlcXVpdmFsZW50IHRvIGBtZXJnZUFsbGAgd2l0aCBjb25jdXJyZW5jeSBwYXJhbWV0ZXIgc2V0XG4gKiB0byBgMWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHRpY2sgZXZlcnkgc2Vjb25kIGZyb20gMCB0byAzLCB3aXRoIG5vIGNvbmN1cnJlbmN5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIuY29uY2F0QWxsKCk7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAocmVzdWx0cyBhcmUgbm90IGNvbmN1cnJlbnQpXG4gKiAvLyBGb3IgZXZlcnkgY2xpY2sgb24gdGhlIFwiZG9jdW1lbnRcIiBpdCB3aWxsIGVtaXQgdmFsdWVzIDAgdG8gMyBzcGFjZWRcbiAqIC8vIG9uIGEgMTAwMG1zIGludGVydmFsXG4gKiAvLyBvbmUgY2xpY2sgPSAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzXG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgZW1pdHRpbmcgdmFsdWVzIGZyb20gYWxsIHRoZSBpbm5lclxuICogT2JzZXJ2YWJsZXMgY29uY2F0ZW5hdGVkLlxuICogQG1ldGhvZCBjb25jYXRBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBtZXJnZUFsbF8xLk1lcmdlQWxsT3BlcmF0b3IoMSkpO1xufVxuZXhwb3J0cy5jb25jYXRBbGwgPSBjb25jYXRBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdEFsbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29uY2F0QWxsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0QWxsID0gY29uY2F0QWxsXzEuY29uY2F0QWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0QWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIG1lcmdlQWxsfS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZU1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIE9ic2VydmFibGUsIGFuZCB0aGVuIG1lcmdpbmcgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGFuZFxuICogZW1pdHRpbmcgdGhlIHJlc3VsdHMgb2YgdGhpcyBtZXJnZXIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIGVhY2ggbGV0dGVyIHRvIGFuIE9ic2VydmFibGUgdGlja2luZyBldmVyeSAxIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKTtcbiAqIHZhciByZXN1bHQgPSBsZXR0ZXJzLm1lcmdlTWFwKHggPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS5tYXAoaSA9PiB4K2kpXG4gKiApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyBhMFxuICogLy8gYjBcbiAqIC8vIGMwXG4gKiAvLyBhMVxuICogLy8gYjFcbiAqIC8vIGMxXG4gKiAvLyBjb250aW51ZXMgdG8gbGlzdCBhLGIsYyB3aXRoIHJlc3BlY3RpdmUgYXNjZW5kaW5nIGludGVnZXJzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZX0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgbWVyZ2VNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VNYXAgPSBtZXJnZU1hcDtcbnZhciBNZXJnZU1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZU1hcE9wZXJhdG9yID0gTWVyZ2VNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9ub3RpZnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlTWFwU3Vic2NyaWJlciA9IE1lcmdlTWFwU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1lcmdlTWFwXzEgPSByZXF1aXJlKCcuL21lcmdlTWFwJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgaW4gYSBzZXJpYWxpemVkIGZhc2hpb24gd2FpdGluZyBmb3IgZWFjaCBvbmUgdG8gY29tcGxldGUgYmVmb3JlXG4gKiBtZXJnaW5nIHRoZSBuZXh0LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBjb25jYXRBbGx9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBFYWNoIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzXG4gKiBjb25jYXRlbmF0ZWQgd2l0aCB0aGUgcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gaWYgc291cmNlIHZhbHVlcyBhcnJpdmUgZW5kbGVzc2x5IGFuZCBmYXN0ZXIgdGhhbiB0aGVpclxuICogY29ycmVzcG9uZGluZyBpbm5lciBPYnNlcnZhYmxlcyBjYW4gY29tcGxldGUsIGl0IHdpbGwgcmVzdWx0IGluIG1lbW9yeSBpc3N1ZXNcbiAqIGFzIGlubmVyIE9ic2VydmFibGVzIGFtYXNzIGluIGFuIHVuYm91bmRlZCBidWZmZXIgd2FpdGluZyBmb3IgdGhlaXIgdHVybiB0b1xuICogYmUgc3Vic2NyaWJlZCB0by5cbiAqXG4gKiBOb3RlOiBgY29uY2F0TWFwYCBpcyBlcXVpdmFsZW50IHRvIGBtZXJnZU1hcGAgd2l0aCBjb25jdXJyZW5jeSBwYXJhbWV0ZXIgc2V0XG4gKiB0byBgMWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHRpY2sgZXZlcnkgc2Vjb25kIGZyb20gMCB0byAzLCB3aXRoIG5vIGNvbmN1cnJlbmN5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuY29uY2F0TWFwKGV2ID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChyZXN1bHRzIGFyZSBub3QgY29uY3VycmVudClcbiAqIC8vIEZvciBldmVyeSBjbGljayBvbiB0aGUgXCJkb2N1bWVudFwiIGl0IHdpbGwgZW1pdCB2YWx1ZXMgMCB0byAzIHNwYWNlZFxuICogLy8gb24gYSAxMDAwbXMgaW50ZXJ2YWxcbiAqIC8vIG9uZSBjbGljayA9IDEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGV9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gb2JzZXJ2YWJsZSBvZiB2YWx1ZXMgbWVyZ2VkIGZyb20gdGhlIHByb2plY3RlZFxuICogT2JzZXJ2YWJsZXMgYXMgdGhleSB3ZXJlIHN1YnNjcmliZWQgdG8sIG9uZSBhdCBhIHRpbWUuIE9wdGlvbmFsbHksIHRoZXNlXG4gKiB2YWx1ZXMgbWF5IGhhdmUgYmVlbiBwcm9qZWN0ZWQgZnJvbSBhIHBhc3NlZCBgcHJvamVjdFJlc3VsdGAgYXJndW1lbnQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIHZhbHVlcyBmcm9tIGVhY2ggcHJvamVjdGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlIHNlcXVlbnRpYWxseS5cbiAqIEBtZXRob2QgY29uY2F0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBtZXJnZU1hcF8xLk1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIDEpKTtcbn1cbmV4cG9ydHMuY29uY2F0TWFwID0gY29uY2F0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb25jYXRNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NvbmNhdE1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNvbmNhdE1hcCA9IGNvbmNhdE1hcF8xLmNvbmNhdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBtdWx0aXBsZVxuICogdGltZXMgaW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIG1lcmdlTWFwfSwgYnV0IG1hcHMgZWFjaCB2YWx1ZSBhbHdheXNcbiAqIHRvIHRoZSBzYW1lIGlubmVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VNYXBUby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBnaXZlbiBPYnNlcnZhYmxlIGBpbm5lck9ic2VydmFibGVgIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSBzb3VyY2UgdmFsdWUsIGFuZCB0aGVuIG1lcmdlcyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgaW50byBvbmVcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCB3aGljaCBpcyB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Rm9yIGVhY2ggY2xpY2sgZXZlbnQsIHN0YXJ0IGFuIGludGVydmFsIE9ic2VydmFibGUgdGlja2luZyBldmVyeSAxIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLm1lcmdlTWFwVG8oUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgKGFuZCBvcHRpb25hbGx5IHRyYW5zZm9ybWVkIHRocm91Z2ggYHJlc3VsdFNlbGVjdG9yYCkgZXZlcnlcbiAqIHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlTWFwVG9PcGVyYXRvcihpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlTWFwVG8gPSBtZXJnZU1hcFRvO1xuLy8gVE9ETzogRmlndXJlIG91dCBjb3JyZWN0IHNpZ25hdHVyZSBoZXJlOiBhbiBPcGVyYXRvcjxPYnNlcnZhYmxlPFQ+LCBSPlxuLy8gICAgICAgbmVlZHMgdG8gaW1wbGVtZW50IGNhbGwob2JzZXJ2ZXI6IFN1YnNjcmliZXI8Uj4pOiBTdWJzY3JpYmVyPE9ic2VydmFibGU8VD4+XG52YXIgTWVyZ2VNYXBUb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFRvT3BlcmF0b3IoaXNoLCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgdGhpcy5pc2ggPSBpc2g7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VNYXBUb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlTWFwVG9TdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLmlzaCwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBUb09wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VNYXBUb09wZXJhdG9yID0gTWVyZ2VNYXBUb09wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZU1hcFRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBpc2gsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXNoID0gaXNoO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTZWxlY3RvciA9IHRoaXMucmVzdWx0U2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICB2YXIgaXNoID0gdGhpcy5pc2g7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgIHRoaXMuX2lubmVyU3ViKGlzaCwgZGVzdGluYXRpb24sIHJlc3VsdFNlbGVjdG9yLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCBkZXN0aW5hdGlvbiwgcmVzdWx0U2VsZWN0b3IsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGlzaCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTZWxlY3RSZXN1bHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBUb1N1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZU1hcFRvU3Vic2NyaWJlciA9IE1lcmdlTWFwVG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXBUby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZU1hcFRvXzEgPSByZXF1aXJlKCcuL21lcmdlTWFwVG8nKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgc2FtZSBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBtdWx0aXBsZVxuICogdGltZXMgaW4gYSBzZXJpYWxpemVkIGZhc2hpb24gb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGNvbmNhdE1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWVcbiAqIGFsd2F5cyB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NvbmNhdE1hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIGdpdmVuIE9ic2VydmFibGUgYGlubmVyT2JzZXJ2YWJsZWAgcmVnYXJkbGVzc1xuICogb2YgdGhlIHNvdXJjZSB2YWx1ZSwgYW5kIHRoZW4gZmxhdHRlbnMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBFYWNoIG5ldyBgaW5uZXJPYnNlcnZhYmxlYFxuICogaW5zdGFuY2UgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgY29uY2F0ZW5hdGVkIHdpdGggdGhlIHByZXZpb3VzXG4gKiBgaW5uZXJPYnNlcnZhYmxlYCBpbnN0YW5jZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gaWYgc291cmNlIHZhbHVlcyBhcnJpdmUgZW5kbGVzc2x5IGFuZCBmYXN0ZXIgdGhhbiB0aGVpclxuICogY29ycmVzcG9uZGluZyBpbm5lciBPYnNlcnZhYmxlcyBjYW4gY29tcGxldGUsIGl0IHdpbGwgcmVzdWx0IGluIG1lbW9yeSBpc3N1ZXNcbiAqIGFzIGlubmVyIE9ic2VydmFibGVzIGFtYXNzIGluIGFuIHVuYm91bmRlZCBidWZmZXIgd2FpdGluZyBmb3IgdGhlaXIgdHVybiB0b1xuICogYmUgc3Vic2NyaWJlZCB0by5cbiAqXG4gKiBOb3RlOiBgY29uY2F0TWFwVG9gIGlzIGVxdWl2YWxlbnQgdG8gYG1lcmdlTWFwVG9gIHdpdGggY29uY3VycmVuY3kgcGFyYW1ldGVyXG4gKiBzZXQgdG8gYDFgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCB0aWNrIGV2ZXJ5IHNlY29uZCBmcm9tIDAgdG8gMywgd2l0aCBubyBjb25jdXJyZW5jeTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmNvbmNhdE1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChyZXN1bHRzIGFyZSBub3QgY29uY3VycmVudClcbiAqIC8vIEZvciBldmVyeSBjbGljayBvbiB0aGUgXCJkb2N1bWVudFwiIGl0IHdpbGwgZW1pdCB2YWx1ZXMgMCB0byAzIHNwYWNlZFxuICogLy8gb24gYSAxMDAwbXMgaW50ZXJ2YWxcbiAqIC8vIG9uZSBjbGljayA9IDEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgb2YgdmFsdWVzIG1lcmdlZCB0b2dldGhlciBieSBqb2luaW5nIHRoZVxuICogcGFzc2VkIG9ic2VydmFibGUgd2l0aCBpdHNlbGYsIG9uZSBhZnRlciB0aGUgb3RoZXIsIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWRcbiAqIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBtZXRob2QgY29uY2F0TWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdE1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBtZXJnZU1hcFRvXzEuTWVyZ2VNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IsIDEpKTtcbn1cbmV4cG9ydHMuY29uY2F0TWFwVG8gPSBjb25jYXRNYXBUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcFRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb25jYXRNYXBUb18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY29uY2F0TWFwVG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb25jYXRNYXBUbyA9IGNvbmNhdE1hcFRvXzEuY29uY2F0TWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRNYXBUby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQ291bnRzIHRoZSBudW1iZXIgb2YgZW1pc3Npb25zIG9uIHRoZSBzb3VyY2UgYW5kIGVtaXRzIHRoYXQgbnVtYmVyIHdoZW4gdGhlXG4gKiBzb3VyY2UgY29tcGxldGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UZWxscyBob3cgbWFueSB2YWx1ZXMgd2VyZSBlbWl0dGVkLCB3aGVuIHRoZSBzb3VyY2VcbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb3VudC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgY291bnRgIHRyYW5zZm9ybXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHZhbHVlcyBpbnRvIGFuIE9ic2VydmFibGUgdGhhdFxuICogZW1pdHMgYSBzaW5nbGUgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRlcm1pbmF0ZXMgd2l0aCBhbiBlcnJvciwgYGNvdW50YFxuICogd2lsbCBwYXNzIHRoaXMgZXJyb3Igbm90aWZpY2F0aW9uIGFsb25nIHdpdGhvdXQgZW1pdHRpbmcgYW4gdmFsdWUgZmlyc3QuIElmXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgZG9lcyBub3QgdGVybWluYXRlIGF0IGFsbCwgYGNvdW50YCB3aWxsIG5laXRoZXIgZW1pdFxuICogYSB2YWx1ZSBub3IgdGVybWluYXRlLiBUaGlzIG9wZXJhdG9yIHRha2VzIGFuIG9wdGlvbmFsIGBwcmVkaWNhdGVgIGZ1bmN0aW9uXG4gKiBhcyBhcmd1bWVudCwgaW4gd2hpY2ggY2FzZSB0aGUgb3V0cHV0IGVtaXNzaW9uIHdpbGwgcmVwcmVzZW50IHRoZSBudW1iZXIgb2ZcbiAqIHNvdXJjZSB2YWx1ZXMgdGhhdCBtYXRjaGVkIGB0cnVlYCB3aXRoIHRoZSBgcHJlZGljYXRlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudHMgaG93IG1hbnkgc2Vjb25kcyBoYXZlIHBhc3NlZCBiZWZvcmUgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbmVkPC9jYXB0aW9uPlxuICogdmFyIHNlY29uZHMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBzZWNvbmRzQmVmb3JlQ2xpY2sgPSBzZWNvbmRzLnRha2VVbnRpbChjbGlja3MpO1xuICogdmFyIHJlc3VsdCA9IHNlY29uZHNCZWZvcmVDbGljay5jb3VudCgpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudHMgaG93IG1hbnkgb2RkIG51bWJlcnMgYXJlIHRoZXJlIGJldHdlZW4gMSBhbmQgNzwvY2FwdGlvbj5cbiAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCA3KTtcbiAqIHZhciByZXN1bHQgPSBudW1iZXJzLmNvdW50KGkgPT4gaSAlIDIgPT09IDEpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gNFxuICpcbiAqIEBzZWUge0BsaW5rIG1heH1cbiAqIEBzZWUge0BsaW5rIG1pbn1cbiAqIEBzZWUge0BsaW5rIHJlZHVjZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpOiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IFtwcmVkaWNhdGVdIEFcbiAqIGJvb2xlYW4gZnVuY3Rpb24gdG8gc2VsZWN0IHdoYXQgdmFsdWVzIGFyZSB0byBiZSBjb3VudGVkLiBJdCBpcyBwcm92aWRlZCB3aXRoXG4gKiBhcmd1bWVudHMgb2Y6XG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIC0gYGluZGV4YDogdGhlICh6ZXJvLWJhc2VkKSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogLSBgc291cmNlYDogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2Ygb25lIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGNvdW50IGFzXG4gKiBkZXNjcmliZWQgYWJvdmUuXG4gKiBAbWV0aG9kIGNvdW50XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb3VudChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBDb3VudE9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpcykpO1xufVxuZXhwb3J0cy5jb3VudCA9IGNvdW50O1xudmFyIENvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvdW50T3BlcmF0b3IocHJlZGljYXRlLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJlZGljYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCsrLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmNvdW50KTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBjb3VudF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvY291bnQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb3VudCA9IGNvdW50XzEuY291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQ29udmVydHMgYW4gT2JzZXJ2YWJsZSBvZiB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzIGludG8gdGhlIGVtaXNzaW9uc1xuICogdGhhdCB0aGV5IHJlcHJlc2VudC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VW53cmFwcyB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzIGFzIGFjdHVhbCBgbmV4dGAsXG4gKiBgZXJyb3JgIGFuZCBgY29tcGxldGVgIGVtaXNzaW9ucy4gVGhlIG9wcG9zaXRlIG9mIHtAbGluayBtYXRlcmlhbGl6ZX0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVtYXRlcmlhbGl6ZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVtYXRlcmlhbGl6ZWAgaXMgYXNzdW1lZCB0byBvcGVyYXRlIGFuIE9ic2VydmFibGUgdGhhdCBvbmx5IGVtaXRzXG4gKiB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzIGFzIGBuZXh0YCBlbWlzc2lvbnMsIGFuZCBkb2VzIG5vdCBlbWl0IGFueVxuICogYGVycm9yYC4gU3VjaCBPYnNlcnZhYmxlIGlzIHRoZSBvdXRwdXQgb2YgYSBgbWF0ZXJpYWxpemVgIG9wZXJhdGlvbi4gVGhvc2VcbiAqIG5vdGlmaWNhdGlvbnMgYXJlIHRoZW4gdW53cmFwcGVkIHVzaW5nIHRoZSBtZXRhZGF0YSB0aGV5IGNvbnRhaW4sIGFuZCBlbWl0dGVkXG4gKiBhcyBgbmV4dGAsIGBlcnJvcmAsIGFuZCBgY29tcGxldGVgIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBVc2UgdGhpcyBvcGVyYXRvciBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBtYXRlcmlhbGl6ZX0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBhbiBPYnNlcnZhYmxlIG9mIE5vdGlmaWNhdGlvbnMgdG8gYW4gYWN0dWFsIE9ic2VydmFibGU8L2NhcHRpb24+XG4gKiB2YXIgbm90aWZBID0gbmV3IFJ4Lk5vdGlmaWNhdGlvbignTicsICdBJyk7XG4gKiB2YXIgbm90aWZCID0gbmV3IFJ4Lk5vdGlmaWNhdGlvbignTicsICdCJyk7XG4gKiB2YXIgbm90aWZFID0gbmV3IFJ4Lk5vdGlmaWNhdGlvbignRScsIHZvaWQgMCxcbiAqICAgbmV3IFR5cGVFcnJvcigneC50b1VwcGVyQ2FzZSBpcyBub3QgYSBmdW5jdGlvbicpXG4gKiApO1xuICogdmFyIG1hdGVyaWFsaXplZCA9IFJ4Lk9ic2VydmFibGUub2Yobm90aWZBLCBub3RpZkIsIG5vdGlmRSk7XG4gKiB2YXIgdXBwZXJDYXNlID0gbWF0ZXJpYWxpemVkLmRlbWF0ZXJpYWxpemUoKTtcbiAqIHVwcGVyQ2FzZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gQVxuICogLy8gQlxuICogLy8gVHlwZUVycm9yOiB4LnRvVXBwZXJDYXNlIGlzIG5vdCBhIGZ1bmN0aW9uXG4gKlxuICogQHNlZSB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICogQHNlZSB7QGxpbmsgbWF0ZXJpYWxpemV9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGFuZCBub3RpZmljYXRpb25zXG4gKiBlbWJlZGRlZCBpbiBOb3RpZmljYXRpb24gb2JqZWN0cyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgZGVtYXRlcmlhbGl6ZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVtYXRlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZU1hdGVyaWFsaXplT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLmRlbWF0ZXJpYWxpemUgPSBkZW1hdGVyaWFsaXplO1xudmFyIERlTWF0ZXJpYWxpemVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVNYXRlcmlhbGl6ZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBEZU1hdGVyaWFsaXplT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZU1hdGVyaWFsaXplU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVNYXRlcmlhbGl6ZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVNYXRlcmlhbGl6ZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZU1hdGVyaWFsaXplU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZU1hdGVyaWFsaXplU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgfVxuICAgIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZS5vYnNlcnZlKHRoaXMuZGVzdGluYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVtYXRlcmlhbGl6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVtYXRlcmlhbGl6ZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVtYXRlcmlhbGl6ZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlbWF0ZXJpYWxpemUgPSBkZW1hdGVyaWFsaXplXzEuZGVtYXRlcmlhbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbWF0ZXJpYWxpemUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgYnV0IHRoZSB0aW1lIHNwYW4gb2ZcbiAqIGVtaXNzaW9uIHNpbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzIHByZXZpb3VzXG4gKiBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgc3Bhd25zIGEgZHVyYXRpb24gT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZVxuICogYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uLiBUaGUgdmFsdWUgaXMgZW1pdHRlZCBvbmx5IHdoZW4gdGhlIGR1cmF0aW9uXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLCBhbmQgaWYgbm8gb3RoZXIgdmFsdWUgd2FzIGVtaXR0ZWQgb25cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBzaW5jZSB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSB3YXMgc3Bhd25lZC4gSWYgYSBuZXdcbiAqIHZhbHVlIGFwcGVhcnMgYmVmb3JlIHRoZSBkdXJhdGlvbiBPYnNlcnZhYmxlIGVtaXRzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbFxuICogYmUgZHJvcHBlZCBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogTGlrZSB7QGxpbmsgZGVib3VuY2VUaW1lfSwgdGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGFuZCBhbHNvIGFcbiAqIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3QgbmVjZXNzYXJpbHkgb2NjdXIgYXQgdGhlXG4gKiBzYW1lIHRpbWUgYXMgdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2UoKCkgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0fVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IE9ic2VydmFibGV8UHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHRpbWVvdXRcbiAqIGR1cmF0aW9uIGZvciBlYWNoIHNvdXJjZSB2YWx1ZSwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBkdXJhdGlvblNlbGVjdG9yYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXIgdG9vIGZyZXF1ZW50bHkuXG4gKiBAbWV0aG9kIGRlYm91bmNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVib3VuY2VPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XG52YXIgRGVib3VuY2VPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgfVxuICAgIERlYm91bmNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlYm91bmNlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kdXJhdGlvblNlbGVjdG9yLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeU5leHQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGR1cmF0aW9uKTtcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLmR1cmF0aW9uU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VTdWJzY3JpYmVyLnByb3RvdHlwZS5lbWl0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVib3VuY2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlYm91bmNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVib3VuY2UgPSBkZWJvdW5jZV8xLmRlYm91bmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHRpbWUgc3BhblxuICogaGFzIHBhc3NlZCB3aXRob3V0IGFub3RoZXIgc291cmNlIGVtaXNzaW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlbGF5fSwgYnV0IHBhc3NlcyBvbmx5IHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSBlYWNoIGJ1cnN0IG9mIGVtaXNzaW9ucy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWJvdW5jZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlYm91bmNlVGltZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzXG4gKiBwcmV2aW91cyBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhhdCBvbmx5IHdoZW4gYGR1ZVRpbWVgIGVub3VnaCB0aW1lIGhhcyBwYXNzZWRcbiAqIHdpdGhvdXQgYW55IG90aGVyIHZhbHVlIGFwcGVhcmluZyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgbmV3IHZhbHVlXG4gKiBhcHBlYXJzIGJlZm9yZSBgZHVlVGltZWAgc2lsZW5jZSBvY2N1cnMsIHRoZSBwcmV2aW91cyB2YWx1ZSB3aWxsIGJlIGRyb3BwZWRcbiAqIGFuZCB3aWxsIG5vdCBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIGlzIGEgcmF0ZS1saW1pdGluZyBvcGVyYXRvciwgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIGZvciBtb3JlIHRoYW4gb25lXG4gKiB2YWx1ZSB0byBiZSBlbWl0dGVkIGluIGFueSB0aW1lIHdpbmRvdyBvZiBkdXJhdGlvbiBgZHVlVGltZWAsIGJ1dCBpdCBpcyBhbHNvXG4gKiBhIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZSBhc1xuICogdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBPcHRpb25hbGx5IHRha2VzIGEge0BsaW5rIFNjaGVkdWxlcn0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdWVUaW1lIFRoZSB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWVcbiAqIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgZm9yIHRoZSB3aW5kb3cgb2ZcbiAqIHRpbWUgcmVxdWlyZWQgdG8gd2FpdCBmb3IgZW1pc3Npb24gc2lsZW5jZSBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50XG4gKiBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWVvdXQgZm9yIGVhY2ggdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGBkdWVUaW1lYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXJcbiAqIHRvbyBmcmVxdWVudGx5LlxuICogQG1ldGhvZCBkZWJvdW5jZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlVGltZShkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWU7XG52YXIgRGVib3VuY2VUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVlVGltZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlYm91bmNlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1ZVRpbWUsIHRoaXMpKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWROZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmRlYm91bmNlZE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJEZWJvdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVib3VuY2VkU3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShkZWJvdW5jZWRTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgZGVib3VuY2VkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVyLmRlYm91bmNlZE5leHQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVib3VuY2VUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWJvdW5jZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWVfMS5kZWJvdW5jZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRW1pdHMgYSBnaXZlbiB2YWx1ZSBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzIHdpdGhvdXQgZW1pdHRpbmcgYW55XG4gKiBgbmV4dGAgdmFsdWUsIG90aGVyd2lzZSBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHR1cm5zIG91dCB0byBiZSBlbXB0eSwgdGhlblxuICogdGhpcyBvcGVyYXRvciB3aWxsIGVtaXQgYSBkZWZhdWx0IHZhbHVlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmF1bHRJZkVtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWZhdWx0SWZFbXB0eWAgZW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvciBhXG4gKiBzcGVjaWZpZWQgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgaXMgZW1wdHkgKGNvbXBsZXRlcyB3aXRob3V0XG4gKiBoYXZpbmcgZW1pdHRlZCBhbnkgYG5leHRgIHZhbHVlKS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZiBubyBjbGlja3MgaGFwcGVuIGluIDUgc2Vjb25kcywgdGhlbiBlbWl0IFwibm8gY2xpY2tzXCI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc0JlZm9yZUZpdmUgPSBjbGlja3MudGFrZVVudGlsKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwMCkpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrc0JlZm9yZUZpdmUuZGVmYXVsdElmRW1wdHkoJ25vIGNsaWNrcycpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBlbXB0eX1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKlxuICogQHBhcmFtIHthbnl9IFtkZWZhdWx0VmFsdWU9bnVsbF0gVGhlIGRlZmF1bHQgdmFsdWUgdXNlZCBpZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGlzIGVtcHR5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGVpdGhlciB0aGUgc3BlY2lmaWVkXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgbm8gaXRlbXMsIG9yIHRoZSB2YWx1ZXMgZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBkZWZhdWx0SWZFbXB0eVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdElmRW1wdHkoZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRWYWx1ZSA9IG51bGw7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yKGRlZmF1bHRWYWx1ZSkpO1xufVxuZXhwb3J0cy5kZWZhdWx0SWZFbXB0eSA9IGRlZmF1bHRJZkVtcHR5O1xudmFyIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLmlzRW1wdHkgPSB0cnVlO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRJZkVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWZhdWx0SWZFbXB0eV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVmYXVsdElmRW1wdHknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWZhdWx0SWZFbXB0eSA9IGRlZmF1bHRJZkVtcHR5XzEuZGVmYXVsdElmRW1wdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0SWZFbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lb3V0IG9yXG4gKiB1bnRpbCBhIGdpdmVuIERhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRpbWUgc2hpZnRzIGVhY2ggaXRlbSBieSBzb21lIHNwZWNpZmllZCBhbW91bnQgb2ZcbiAqIG1pbGxpc2Vjb25kcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWxheS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBJZiB0aGUgZGVsYXkgYXJndW1lbnQgaXMgYSBOdW1iZXIsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGF0IGFtb3VudCBvZiB0aW1lIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMuIFRoZSByZWxhdGl2ZVxuICogdGltZSBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQuXG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgRGF0ZSwgdGhpcyBvcGVyYXRvciB0aW1lIHNoaWZ0cyB0aGUgc3RhcnQgb2YgdGhlXG4gKiBPYnNlcnZhYmxlIGV4ZWN1dGlvbiB1bnRpbCB0aGUgZ2l2ZW4gZGF0ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgZWFjaCBjbGljayBieSBvbmUgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KDEwMDApOyAvLyBlYWNoIGNsaWNrIGVtaXR0ZWQgYWZ0ZXIgMSBzZWNvbmRcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGFsbCBjbGlja3MgdW50aWwgYSBmdXR1cmUgZGF0ZSBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkYXRlID0gbmV3IERhdGUoJ01hcmNoIDE1LCAyMDUwIDEyOjAwOjAwJyk7IC8vIGluIHRoZSBmdXR1cmVcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KGRhdGUpOyAvLyBjbGljayBlbWl0dGVkIG9ubHkgYWZ0ZXIgdGhhdCBkYXRlXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGVsYXkgVGhlIGRlbGF5IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAoYSBgbnVtYmVyYCkgb3JcbiAqIGEgYERhdGVgIHVudGlsIHdoaWNoIHRoZSBlbWlzc2lvbiBvZiB0aGUgc291cmNlIGl0ZW1zIGlzIGRlbGF5ZWQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIFNjaGVkdWxlciB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lLXNoaWZ0IGZvciBlYWNoIGl0ZW0uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIHRpbWVvdXQgb3IgRGF0ZS5cbiAqIEBtZXRob2QgZGVsYXlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlbGF5KGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHZhciBhYnNvbHV0ZURlbGF5ID0gaXNEYXRlXzEuaXNEYXRlKGRlbGF5KTtcbiAgICB2YXIgZGVsYXlGb3IgPSBhYnNvbHV0ZURlbGF5ID8gKCtkZWxheSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkZWxheSk7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVsYXlPcGVyYXRvcihkZWxheUZvciwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XG52YXIgRGVsYXlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXlPcGVyYXRvcihkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIERlbGF5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWxheVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWxheSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVsYXlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVsYXlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbGF5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvcmVkID0gZmFsc2U7XG4gICAgfVxuICAgIERlbGF5U3Vic2NyaWJlci5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgc291cmNlID0gc3RhdGUuc291cmNlO1xuICAgICAgICB2YXIgcXVldWUgPSBzb3VyY2UucXVldWU7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSBzdGF0ZS5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHN0YXRlLmRlc3RpbmF0aW9uO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiAocXVldWVbMF0udGltZSAtIHNjaGVkdWxlci5ub3coKSkgPD0gMCkge1xuICAgICAgICAgICAgcXVldWUuc2hpZnQoKS5ub3RpZmljYXRpb24ub2JzZXJ2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBkZWxheV8xID0gTWF0aC5tYXgoMCwgcXVldWVbMF0udGltZSAtIHNjaGVkdWxlci5ub3coKSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlLCBkZWxheV8xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fc2NoZWR1bGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKERlbGF5U3Vic2NyaWJlci5kaXNwYXRjaCwgdGhpcy5kZWxheSwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLCBkZXN0aW5hdGlvbjogdGhpcy5kZXN0aW5hdGlvbiwgc2NoZWR1bGVyOiBzY2hlZHVsZXJcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZU5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgRGVsYXlNZXNzYWdlKHNjaGVkdWxlci5ub3coKSArIHRoaXMuZGVsYXksIG5vdGlmaWNhdGlvbik7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xudmFyIERlbGF5TWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXlNZXNzYWdlKHRpbWUsIG5vdGlmaWNhdGlvbikge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIERlbGF5TWVzc2FnZTtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVsYXlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlbGF5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVsYXkgPSBkZWxheV8xLmRlbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRGVsYXlzIHRoZSBlbWlzc2lvbiBvZiBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBhIGdpdmVuIHRpbWUgc3BhblxuICogZGV0ZXJtaW5lZCBieSB0aGUgZW1pc3Npb25zIG9mIGFub3RoZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCB0aGUgdGltZSBzcGFuIG9mIHRoZVxuICogZGVsYXkgZHVyYXRpb24gaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlbGF5V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVsYXlXaGVuYCB0aW1lIHNoaWZ0cyBlYWNoIGVtaXR0ZWQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYVxuICogdGltZSBzcGFuIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLiBXaGVuIHRoZSBzb3VyY2UgZW1pdHMgYSB2YWx1ZSxcbiAqIHRoZSBgZGVsYXlEdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgc291cmNlIHZhbHVlIGFzXG4gKiBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm4gYW4gT2JzZXJ2YWJsZSwgY2FsbGVkIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS5cbiAqIFRoZSBzb3VyY2UgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgb25seSB3aGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcy5cbiAqXG4gKiBPcHRpb25hbGx5LCBgZGVsYXlXaGVuYCB0YWtlcyBhIHNlY29uZCBhcmd1bWVudCwgYHN1YnNjcmlwdGlvbkRlbGF5YCwgd2hpY2hcbiAqIGlzIGFuIE9ic2VydmFibGUuIFdoZW4gYHN1YnNjcmlwdGlvbkRlbGF5YCBlbWl0cyBpdHMgZmlyc3QgdmFsdWUgb3JcbiAqIGNvbXBsZXRlcywgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQgdG8gYW5kIHN0YXJ0cyBiZWhhdmluZyBsaWtlXG4gKiBkZXNjcmliZWQgaW4gdGhlIHByZXZpb3VzIHBhcmFncmFwaC4gSWYgYHN1YnNjcmlwdGlvbkRlbGF5YCBpcyBub3QgcHJvdmlkZWQsXG4gKiBgZGVsYXlXaGVuYCB3aWxsIHN1YnNjcmliZSB0byB0aGUgc291cmNlIE9ic2VydmFibGUgYXMgc29vbiBhcyB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgZWFjaCBjbGljayBieSBhIHJhbmRvbSBhbW91bnQgb2YgdGltZSwgYmV0d2VlbiAwIGFuZCA1IHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGRlbGF5ZWRDbGlja3MgPSBjbGlja3MuZGVsYXlXaGVuKGV2ZW50ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoTWF0aC5yYW5kb20oKSAqIDUwMDApXG4gKiApO1xuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogT2JzZXJ2YWJsZX0gZGVsYXlEdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdFxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGljaFxuICogaXMgdGhlbiB1c2VkIHRvIGRlbGF5IHRoZSBlbWlzc2lvbiBvZiB0aGF0IGl0ZW0gb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB1bnRpbCB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24gZW1pdHMgYSB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gc3Vic2NyaXB0aW9uRGVsYXkgQW4gT2JzZXJ2YWJsZSB0aGF0IHRyaWdnZXJzIHRoZVxuICogc3Vic2NyaXB0aW9uIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmNlIGl0IGVtaXRzIGFueSB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IGFuIGFtb3VudCBvZiB0aW1lIHNwZWNpZmllZCBieSB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBieVxuICogYGRlbGF5RHVyYXRpb25TZWxlY3RvcmAuXG4gKiBAbWV0aG9kIGRlbGF5V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVsYXlXaGVuKGRlbGF5RHVyYXRpb25TZWxlY3Rvciwgc3Vic2NyaXB0aW9uRGVsYXkpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uRGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUodGhpcywgc3Vic2NyaXB0aW9uRGVsYXkpXG4gICAgICAgICAgICAubGlmdChuZXcgRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlbGF5V2hlbk9wZXJhdG9yKGRlbGF5RHVyYXRpb25TZWxlY3RvcikpO1xufVxuZXhwb3J0cy5kZWxheVdoZW4gPSBkZWxheVdoZW47XG52YXIgRGVsYXlXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5V2hlbk9wZXJhdG9yKGRlbGF5RHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3RvciA9IGRlbGF5RHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgRGVsYXlXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWxheVdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWxheVdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVsYXlXaGVuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWxheVdoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkZWxheUR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3RvciA9IGRlbGF5RHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChvdXRlclZhbHVlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5yZW1vdmVTdWJzY3JpcHRpb24oaW5uZXJTdWIpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cnlDb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkZWxheU5vdGlmaWVyID0gdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRlbGF5Tm90aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURlbGF5KGRlbGF5Tm90aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5yZW1vdmVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSWR4ID0gdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25JZHggIT09IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzW3N1YnNjcmlwdGlvbklkeF07XG4gICAgICAgICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKHN1YnNjcmlwdGlvbklkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVsYXlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVsYXkgPSBmdW5jdGlvbiAoZGVsYXlOb3RpZmllciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdGlmaWVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkZWxheU5vdGlmaWVyLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuYWRkKG5vdGlmaWVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5wdXNoKG5vdGlmaWVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgICBEZWxheVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS50cnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVkICYmIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWxheVdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZShzb3VyY2UsIHN1YnNjcmlwdGlvbkRlbGF5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25EZWxheSA9IHN1YnNjcmlwdGlvbkRlbGF5O1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkRlbGF5LnN1YnNjcmliZShuZXcgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uRGVsYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyKHBhcmVudCwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc291cmNlU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvU291cmNlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnBhcmVudC5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Tb3VyY2UoKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2VTdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHRoaXMucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5V2hlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVsYXlXaGVuXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWxheVdoZW4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheVdoZW4gPSBkZWxheVdoZW5fMS5kZWxheVdoZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheVdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG5mdW5jdGlvbiBtaW5pbWFsU2V0SW1wbCgpIHtcbiAgICAvLyBUSElTIElTIE5PVCBhIGZ1bGwgaW1wbCBvZiBTZXQsIHRoaXMgaXMganVzdCB0aGUgbWluaW11bVxuICAgIC8vIGJpdHMgb2YgZnVuY3Rpb25hbGl0eSB3ZSBuZWVkIGZvciB0aGlzIGxpYnJhcnkuXG4gICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbmltYWxTZXQoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBNaW5pbWFsU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNaW5pbWFsU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWluaW1hbFNldC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBNaW5pbWFsU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWluaW1hbFNldDtcbiAgICB9KCkpO1xufVxuZXhwb3J0cy5taW5pbWFsU2V0SW1wbCA9IG1pbmltYWxTZXRJbXBsO1xuZXhwb3J0cy5TZXQgPSByb290XzEucm9vdC5TZXQgfHwgbWluaW1hbFNldEltcGwoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBTZXRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvU2V0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gcHJldmlvdXMgaXRlbXMuXG4gKiBJZiBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgcHJvamVjdCBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBvYnNlcnZhYmxlIGludG8gYSBuZXcgdmFsdWUgdGhhdCBpdCB3aWxsXG4gKiBjaGVjayBmb3IgZXF1YWxpdHkgd2l0aCBwcmV2aW91c2x5IHByb2plY3RlZCB2YWx1ZXMuIElmIGEga2V5U2VsZWN0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIHVzZSBlYWNoIHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2Ugb2JzZXJ2YWJsZSBkaXJlY3RseSB3aXRoIGFuIGVxdWFsaXR5IGNoZWNrIGFnYWluc3QgcHJldmlvdXMgdmFsdWVzLlxuICogSW4gSmF2YVNjcmlwdCBydW50aW1lcyB0aGF0IHN1cHBvcnQgYFNldGAsIHRoaXMgb3BlcmF0b3Igd2lsbCB1c2UgYSBgU2V0YCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZSBjaGVja2luZy5cbiAqIEluIG90aGVyIHJ1bnRpbWVzLCB0aGlzIG9wZXJhdG9yIHdpbGwgdXNlIGEgbWluaW1hbCBpbXBsZW1lbnRhdGlvbiBvZiBgU2V0YCB0aGF0IHJlbGllcyBvbiBhbiBgQXJyYXlgIGFuZCBgaW5kZXhPZmAgdW5kZXIgdGhlXG4gKiBob29kLCBzbyBwZXJmb3JtYW5jZSB3aWxsIGRlZ3JhZGUgYXMgbW9yZSB2YWx1ZXMgYXJlIGNoZWNrZWQgZm9yIGRpc3RpbmN0aW9uLiBFdmVuIGluIG5ld2VyIGJyb3dzZXJzLCBhIGxvbmctcnVubmluZyBgZGlzdGluY3RgXG4gKiB1c2UgbWlnaHQgcmVzdWx0IGluIG1lbW9yeSBsZWFrcy4gVG8gaGVscCBhbGxldmlhdGUgdGhpcyBpbiBzb21lIHNjZW5hcmlvcywgYW4gb3B0aW9uYWwgYGZsdXNoZXNgIHBhcmFtZXRlciBpcyBhbHNvIHByb3ZpZGVkIHNvXG4gKiB0aGF0IHRoZSBpbnRlcm5hbCBgU2V0YCBjYW4gYmUgXCJmbHVzaGVkXCIsIGJhc2ljYWxseSBjbGVhcmluZyBpdCBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBba2V5U2VsZWN0b3JdIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNlbGVjdCB3aGljaCB2YWx1ZSB5b3Ugd2FudCB0byBjaGVjayBhcyBkaXN0aW5jdC5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gW2ZsdXNoZXNdIG9wdGlvbmFsIE9ic2VydmFibGUgZm9yIGZsdXNoaW5nIHRoZSBpbnRlcm5hbCBIYXNoU2V0IG9mIHRoZSBvcGVyYXRvci5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcy5cbiAqIEBtZXRob2QgZGlzdGluY3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0KGtleVNlbGVjdG9yLCBmbHVzaGVzKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGlzdGluY3RPcGVyYXRvcihrZXlTZWxlY3RvciwgZmx1c2hlcykpO1xufVxuZXhwb3J0cy5kaXN0aW5jdCA9IGRpc3RpbmN0O1xudmFyIERpc3RpbmN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0T3BlcmF0b3Ioa2V5U2VsZWN0b3IsIGZsdXNoZXMpIHtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmZsdXNoZXMgPSBmbHVzaGVzO1xuICAgIH1cbiAgICBEaXN0aW5jdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGlzdGluY3RTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMua2V5U2VsZWN0b3IsIHRoaXMuZmx1c2hlcykpO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEaXN0aW5jdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXN0aW5jdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBrZXlTZWxlY3RvciwgZmx1c2hlcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgU2V0XzEuU2V0KCk7XG4gICAgICAgIGlmIChmbHVzaGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGZsdXNoZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuY2xlYXIoKTtcbiAgICB9O1xuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIERpc3RpbmN0U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZUtleVNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplTmV4dCh2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLl91c2VLZXlTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5hbGl6ZU5leHQoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFN1YnNjcmliZXIucHJvdG90eXBlLl9maW5hbGl6ZU5leHQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGlmICghdmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWRkKGtleSk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuRGlzdGluY3RTdWJzY3JpYmVyID0gRGlzdGluY3RTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRpc3RpbmN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kaXN0aW5jdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRpc3RpbmN0ID0gZGlzdGluY3RfMS5kaXN0aW5jdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGFuIGVxdWFsaXR5IGNoZWNrIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBvcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsQ2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yKGNvbXBhcmUsIGtleVNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWQ7XG52YXIgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcihjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgfVxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb21wYXJlLCB0aGlzLmtleVNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfTtcbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlTZWxlY3RvciA9IHRoaXMua2V5U2VsZWN0b3I7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGtleVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBrZXkgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMua2V5U2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzS2V5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY29tcGFyZSkodGhpcy5rZXksIGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQm9vbGVhbihyZXN1bHQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbENoYW5nZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWRfMS5kaXN0aW5jdFVudGlsQ2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxDaGFuZ2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSByZXF1aXJlKCcuL2Rpc3RpbmN0VW50aWxDaGFuZ2VkJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSB0aGUgcHJldmlvdXMgaXRlbSxcbiAqIHVzaW5nIGEgcHJvcGVydHkgYWNjZXNzZWQgYnkgdXNpbmcgdGhlIGtleSBwcm92aWRlZCB0byBjaGVjayBpZiB0aGUgdHdvIGl0ZW1zIGFyZSBkaXN0aW5jdC5cbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0cmluZyBrZXkgZm9yIG9iamVjdCBwcm9wZXJ0eSBsb29rdXAgb24gZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcmVdIG9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24gY2FsbGVkIHRvIHRlc3QgaWYgYW4gaXRlbSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMgYmFzZWQgb24gdGhlIGtleSBzcGVjaWZpZWQuXG4gKiBAbWV0aG9kIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZChrZXksIGNvbXBhcmUpIHtcbiAgICByZXR1cm4gZGlzdGluY3RVbnRpbENoYW5nZWRfMS5kaXN0aW5jdFVudGlsQ2hhbmdlZC5jYWxsKHRoaXMsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSh4W2tleV0sIHlba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhba2V5XSA9PT0geVtrZXldO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkID0gZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgZW1pc3Npb24gb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgcmV0dXJuXG4gKiBhbiBPYnNlcnZhYmxlIHRoYXQgaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkludGVyY2VwdHMgZWFjaCBlbWlzc2lvbiBvbiB0aGUgc291cmNlIGFuZCBydW5zIGFcbiAqIGZ1bmN0aW9uLCBidXQgcmV0dXJucyBhbiBvdXRwdXQgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhIG1pcnJvcmVkIE9ic2VydmFibGUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgbW9kaWZpZWQgc28gdGhhdFxuICogdGhlIHByb3ZpZGVkIE9ic2VydmVyIGlzIGNhbGxlZCB0byBwZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IHZhbHVlLFxuICogZXJyb3IsIGFuZCBjb21wbGV0aW9uIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZS4gQW55IGVycm9ycyB0aGF0IGFyZSB0aHJvd24gaW5cbiAqIHRoZSBhZm9yZW1lbnRpb25lZCBPYnNlcnZlciBvciBoYW5kbGVycyBhcmUgc2FmZWx5IHNlbnQgZG93biB0aGUgZXJyb3IgcGF0aFxuICogb2YgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgeW91ciBPYnNlcnZhYmxlcyBmb3IgdGhlIGNvcnJlY3QgdmFsdWVzXG4gKiBvciBwZXJmb3JtaW5nIG90aGVyIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBOb3RlOiB0aGlzIGlzIGRpZmZlcmVudCB0byBhIGBzdWJzY3JpYmVgIG9uIHRoZSBPYnNlcnZhYmxlLiBJZiB0aGUgT2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgYGRvYCBpcyBub3Qgc3Vic2NyaWJlZCwgdGhlIHNpZGUgZWZmZWN0cyBzcGVjaWZpZWQgYnkgdGhlXG4gKiBPYnNlcnZlciB3aWxsIG5ldmVyIGhhcHBlbi4gYGRvYCB0aGVyZWZvcmUgc2ltcGx5IHNwaWVzIG9uIGV4aXN0aW5nXG4gKiBleGVjdXRpb24sIGl0IGRvZXMgbm90IHRyaWdnZXIgYW4gZXhlY3V0aW9uIHRvIGhhcHBlbiBsaWtlIGBzdWJzY3JpYmVgIGRvZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2ssIHdoaWxlIGFsc28gbG9nZ2luZyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrc1xuICogICAuZG8oZXYgPT4gY29uc29sZS5sb2coZXYpKVxuICogICAubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKiBAc2VlIHtAbGluayBzdWJzY3JpYmV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbn0gW25leHRPck9ic2VydmVyXSBBIG5vcm1hbCBPYnNlcnZlciBvYmplY3Qgb3IgYVxuICogY2FsbGJhY2sgZm9yIGBuZXh0YC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgZm9yIGVycm9ycyBpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBsZXRlXSBDYWxsYmFjayBmb3IgdGhlIGNvbXBsZXRpb24gb2YgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UsIGJ1dCBydW5zIHRoZVxuICogc3BlY2lmaWVkIE9ic2VydmVyIG9yIGNhbGxiYWNrKHMpIGZvciBlYWNoIGl0ZW0uXG4gKiBAbWV0aG9kIGRvXG4gKiBAbmFtZSBkb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2RvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpKTtcbn1cbmV4cG9ydHMuX2RvID0gX2RvO1xudmFyIERvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB0aGlzLm5leHRPck9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBEb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRG9TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dE9yT2JzZXJ2ZXIsIHRoaXMuZXJyb3IsIHRoaXMuY29tcGxldGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBEb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoc2FmZVN1YnNjcmliZXIpO1xuICAgICAgICB0aGlzLnNhZmVTdWJzY3JpYmVyID0gc2FmZVN1YnNjcmliZXI7XG4gICAgfVxuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZG8gPSBkb18xLl9kbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fZG8gPSBkb18xLl9kbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5IGRyb3BwaW5nXG4gKiBpbm5lciBPYnNlcnZhYmxlcyB3aGlsZSB0aGUgcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBoYXMgbm90IHlldCBjb21wbGV0ZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgYnkgZHJvcHBpbmcgdGhlXG4gKiBuZXh0IGlubmVyIE9ic2VydmFibGVzIHdoaWxlIHRoZSBjdXJyZW50IGlubmVyIGlzIHN0aWxsIGV4ZWN1dGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leGhhdXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBleGhhdXN0YCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGF0XG4gKiBpbm5lciBPYnNlcnZhYmxlLiBTbyBmYXIsIGl0IGJlaGF2ZXMgbGlrZSB7QGxpbmsgbWVyZ2VBbGx9LiBIb3dldmVyLFxuICogYGV4aGF1c3RgIGlnbm9yZXMgZXZlcnkgbmV3IGlubmVyIE9ic2VydmFibGUgaWYgdGhlIHByZXZpb3VzIE9ic2VydmFibGUgaGFzXG4gKiBub3QgeWV0IGNvbXBsZXRlZC4gT25jZSB0aGF0IG9uZSBjb21wbGV0ZXMsIGl0IHdpbGwgYWNjZXB0IGFuZCBmbGF0dGVuIHRoZVxuICogbmV4dCBpbm5lciBPYnNlcnZhYmxlIGFuZCByZXBlYXQgdGhpcyBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJ1biBhIGZpbml0ZSB0aW1lciBmb3IgZWFjaCBjbGljaywgb25seSBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgYWN0aXZlIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciByZXN1bHQgPSBoaWdoZXJPcmRlci5leGhhdXN0KCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgdGFrZXMgYSBzb3VyY2Ugb2YgT2JzZXJ2YWJsZXNcbiAqIGFuZCBwcm9wYWdhdGVzIHRoZSBmaXJzdCBvYnNlcnZhYmxlIGV4Y2x1c2l2ZWx5IHVudGlsIGl0IGNvbXBsZXRlcyBiZWZvcmVcbiAqIHN1YnNjcmliaW5nIHRvIHRoZSBuZXh0LlxuICogQG1ldGhvZCBleGhhdXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0KCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaEZpcnN0T3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLmV4aGF1c3QgPSBleGhhdXN0O1xudmFyIFN3aXRjaEZpcnN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0T3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFN3aXRjaEZpcnN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hGaXJzdFN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hGaXJzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hGaXJzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoRmlyc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4aGF1c3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGV4aGF1c3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2V4aGF1c3QnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5leGhhdXN0ID0gZXhoYXVzdF8xLmV4aGF1c3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGhhdXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgb25seSBpZiB0aGUgcHJldmlvdXMgcHJvamVjdGVkIE9ic2VydmFibGUgaGFzIGNvbXBsZXRlZC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgZXhoYXVzdH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZXhoYXVzdE1hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBiYXNlZCBvbiBhcHBseWluZyBhIGZ1bmN0aW9uIHRoYXQgeW91XG4gKiBzdXBwbHkgdG8gZWFjaCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB3aGVyZSB0aGF0IGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIChzby1jYWxsZWQgXCJpbm5lclwiKSBPYnNlcnZhYmxlLiBXaGVuIGl0IHByb2plY3RzIGEgc291cmNlIHZhbHVlIHRvXG4gKiBhbiBPYnNlcnZhYmxlLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5XG4gKiB0aGF0IHByb2plY3RlZCBPYnNlcnZhYmxlLiBIb3dldmVyLCBgZXhoYXVzdE1hcGAgaWdub3JlcyBldmVyeSBuZXcgcHJvamVjdGVkXG4gKiBPYnNlcnZhYmxlIGlmIHRoZSBwcmV2aW91cyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZSBoYXMgbm90IHlldCBjb21wbGV0ZWQuIE9uY2VcbiAqIHRoYXQgb25lIGNvbXBsZXRlcywgaXQgd2lsbCBhY2NlcHQgYW5kIGZsYXR0ZW4gdGhlIG5leHQgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIGFuZCByZXBlYXQgdGhpcyBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJ1biBhIGZpbml0ZSB0aW1lciBmb3IgZWFjaCBjbGljaywgb25seSBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgYWN0aXZlIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZXhoYXVzdE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlfSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgY29udGFpbmluZyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZXNcbiAqIG9mIGVhY2ggaXRlbSBvZiB0aGUgc291cmNlLCBpZ25vcmluZyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZXMgdGhhdCBzdGFydCBiZWZvcmVcbiAqIHRoZWlyIHByZWNlZGluZyBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQuXG4gKiBAbWV0aG9kIGV4aGF1c3RNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGV4aGF1c3RNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmV4aGF1c3RNYXAgPSBleGhhdXN0TWFwO1xudmFyIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5U2VsZWN0UmVzdWx0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTZWxlY3RSZXN1bHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGhhdXN0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBleGhhdXN0TWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9leGhhdXN0TWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZXhoYXVzdE1hcCA9IGV4aGF1c3RNYXBfMS5leGhhdXN0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmVjdXJzaXZlbHkgcHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW5cbiAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBzaW1pbGFyIHRvIHtAbGluayBtZXJnZU1hcH0sIGJ1dCBhcHBsaWVzIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiB0byBldmVyeSBzb3VyY2UgdmFsdWUgYXMgd2VsbCBhcyBldmVyeSBvdXRwdXQgdmFsdWUuXG4gKiBJdCdzIHJlY3Vyc2l2ZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leHBhbmQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLiAqRXhwYW5kKiB3aWxsIHJlLWVtaXQgb24gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBldmVyeSBzb3VyY2UgdmFsdWUuIFRoZW4sIGVhY2ggb3V0cHV0IHZhbHVlIGlzIGdpdmVuIHRvIHRoZVxuICogYHByb2plY3RgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gaW5uZXIgT2JzZXJ2YWJsZSB0byBiZSBtZXJnZWQgb24gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhvc2Ugb3V0cHV0IHZhbHVlcyByZXN1bHRpbmcgZnJvbSB0aGUgcHJvamVjdGlvbiBhcmUgYWxzb1xuICogZ2l2ZW4gdG8gdGhlIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBwcm9kdWNlIG5ldyBvdXRwdXQgdmFsdWVzLiBUaGlzIGlzIGhvd1xuICogKmV4cGFuZCogYmVoYXZlcyByZWN1cnNpdmVseS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdGFydCBlbWl0dGluZyB0aGUgcG93ZXJzIG9mIHR3byBvbiBldmVyeSBjbGljaywgYXQgbW9zdCAxMCBvZiB0aGVtPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3dlcnNPZlR3byA9IGNsaWNrc1xuICogICAubWFwVG8oMSlcbiAqICAgLmV4cGFuZCh4ID0+IFJ4Lk9ic2VydmFibGUub2YoMiAqIHgpLmRlbGF5KDEwMDApKVxuICogICAudGFrZSgxMCk7XG4gKiBwb3dlcnNPZlR3by5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZX0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2Ugb3IgdGhlIG91dHB1dCBPYnNlcnZhYmxlLFxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIFNjaGVkdWxlciB0byB1c2UgZm9yIHN1YnNjcmliaW5nIHRvXG4gKiBlYWNoIHByb2plY3RlZCBpbm5lciBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzb3VyY2UgdmFsdWVzIGFuZCBhbHNvXG4gKiByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHByb2plY3Rpb24gZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIG9uIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUgYW5kIGFuZCBtZXJnaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBPYnNlcnZhYmxlcyBvYnRhaW5lZFxuICogZnJvbSB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICogQG1ldGhvZCBleHBhbmRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZChwcm9qZWN0LCBjb25jdXJyZW50LCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gdW5kZWZpbmVkOyB9XG4gICAgY29uY3VycmVudCA9IChjb25jdXJyZW50IHx8IDApIDwgMSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IGNvbmN1cnJlbnQ7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRXhwYW5kT3BlcmF0b3IocHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmV4cGFuZCA9IGV4cGFuZDtcbnZhciBFeHBhbmRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5kT3BlcmF0b3IocHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBFeHBhbmRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEV4cGFuZFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLmNvbmN1cnJlbnQsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwYW5kT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5FeHBhbmRPcGVyYXRvciA9IEV4cGFuZE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBFeHBhbmRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwYW5kU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHBhbmRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCBjb25jdXJyZW50LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgRXhwYW5kU3Vic2NyaWJlci5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlciwgcmVzdWx0ID0gYXJnLnJlc3VsdCwgdmFsdWUgPSBhcmcudmFsdWUsIGluZGV4ID0gYXJnLmluZGV4O1xuICAgICAgICBzdWJzY3JpYmVyLnN1YnNjcmliZVRvUHJvamVjdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMucHJvamVjdCkodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1Byb2plY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCByZXN1bHQ6IHJlc3VsdCwgdmFsdWU6IHZhbHVlLCBpbmRleDogaW5kZXggfTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShFeHBhbmRTdWJzY3JpYmVyLmRpc3BhdGNoLCAwLCBzdGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4cGFuZFN1YnNjcmliZXIucHJvdG90eXBlLnN1YnNjcmliZVRvUHJvamVjdGlvbiA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBFeHBhbmRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkICYmIHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4cGFuZFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5fbmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIEV4cGFuZFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV4cGFuZFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5FeHBhbmRTdWJzY3JpYmVyID0gRXhwYW5kU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZXhwYW5kXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9leHBhbmQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5leHBhbmQgPSBleHBhbmRfMS5leHBhbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBhbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gZWxlbWVudCB3YXMgcXVlcmllZCBhdCBhIGNlcnRhaW4gaW5kZXggb2YgYW5cbiAqIE9ic2VydmFibGUsIGJ1dCBubyBzdWNoIGluZGV4IG9yIHBvc2l0aW9uIGV4aXN0cyBpbiB0aGF0IHNlcXVlbmNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGVsZW1lbnRBdH1cbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqXG4gKiBAY2xhc3MgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JcbiAqL1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnYXJndW1lbnQgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG4vKipcbiAqIEVtaXRzIHRoZSBzaW5nbGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBgaW5kZXhgIGluIGEgc2VxdWVuY2Ugb2YgZW1pc3Npb25zXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgb25seSB0aGUgaS10aCB2YWx1ZSwgdGhlbiBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZWxlbWVudEF0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBlbGVtZW50QXRgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWRcbiAqIGBpbmRleGAgaW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBvciBhIGRlZmF1bHQgdmFsdWUgaWYgdGhhdCBgaW5kZXhgIGlzIG91dFxuICogb2YgcmFuZ2UgYW5kIHRoZSBgZGVmYXVsdGAgYXJndW1lbnQgaXMgcHJvdmlkZWQuIElmIHRoZSBgZGVmYXVsdGAgYXJndW1lbnQgaXNcbiAqIG5vdCBnaXZlbiBhbmQgdGhlIGBpbmRleGAgaXMgb3V0IG9mIHJhbmdlLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgd2lsbCBlbWl0IGFuXG4gKiBgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JgIGVycm9yLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSB0aGUgdGhpcmQgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5lbGVtZW50QXQoMik7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW46XG4gKiAvLyBjbGljayAxID0gbm90aGluZ1xuICogLy8gY2xpY2sgMiA9IG5vdGhpbmdcbiAqIC8vIGNsaWNrIDMgPSBNb3VzZUV2ZW50IG9iamVjdCBsb2dnZWQgdG8gY29uc29sZVxuICpcbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgbGFzdH1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKiBAc2VlIHtAbGluayBzaW5nbGV9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEB0aHJvd3Mge0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yfSBXaGVuIHVzaW5nIGBlbGVtZW50QXQoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgIG9yIHRoZVxuICogT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkIGJlZm9yZSBlbWl0dGluZyB0aGUgaS10aCBgbmV4dGAgbm90aWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlIGVtaXNzaW9uIHRoYXQgaGFzXG4gKiBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHtUfSBbZGVmYXVsdFZhbHVlXSBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBmb3IgbWlzc2luZyBpbmRpY2VzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgc2luZ2xlIGl0ZW0sIGlmIGl0IGlzIGZvdW5kLlxuICogT3RoZXJ3aXNlLCB3aWxsIGVtaXQgdGhlIGRlZmF1bHQgdmFsdWUgaWYgZ2l2ZW4uIElmIG5vdCwgdGhlbiBlbWl0cyBhbiBlcnJvci5cbiAqIEBtZXRob2QgZWxlbWVudEF0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBlbGVtZW50QXQoaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEVsZW1lbnRBdE9wZXJhdG9yKGluZGV4LCBkZWZhdWx0VmFsdWUpKTtcbn1cbmV4cG9ydHMuZWxlbWVudEF0ID0gZWxlbWVudEF0O1xudmFyIEVsZW1lbnRBdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50QXRPcGVyYXRvcihpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVsZW1lbnRBdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRWxlbWVudEF0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmluZGV4LCB0aGlzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRWxlbWVudEF0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRBdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudEF0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIEVsZW1lbnRBdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgtLSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHgpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50QXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudEF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBlbGVtZW50QXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2VsZW1lbnRBdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmVsZW1lbnRBdCA9IGVsZW1lbnRBdF8xLmVsZW1lbnRBdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRBdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBGaWx0ZXIgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgb25seSBlbWl0dGluZyB0aG9zZSB0aGF0XG4gKiBzYXRpc2Z5IGEgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5maWx0ZXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyKSxcbiAqIGl0IG9ubHkgZW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgaWYgaXQgcGFzc2VzIGEgY3JpdGVyaW9uIGZ1bmN0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbHRlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsLWtub3duIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2QsIHRoaXMgb3BlcmF0b3JcbiAqIHRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcGFzc2VzIHRoZW0gdGhyb3VnaCBhIGBwcmVkaWNhdGVgXG4gKiBmdW5jdGlvbiBhbmQgb25seSBlbWl0cyB0aG9zZSB2YWx1ZXMgdGhhdCB5aWVsZGVkIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgY2xpY2sgZXZlbnRzIHdob3NlIHRhcmdldCB3YXMgYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gY2xpY2tzLmZpbHRlcihldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogY2xpY2tzT25EaXZzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBpZ25vcmVFbGVtZW50c31cbiAqIEBzZWUge0BsaW5rIHBhcnRpdGlvbn1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkLCBpZiBgZmFsc2VgIHRoZSB2YWx1ZSBpcyBub3QgcGFzc2VkIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlXG4gKiBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXJcbiAqIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmVcbiAqIGFsbG93ZWQgYnkgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBmaWx0ZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xudmFyIEZpbHRlck9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIEZpbHRlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmlsdGVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaWx0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIH1cbiAgICAvLyB0aGUgdHJ5IGNhdGNoIGJsb2NrIGJlbG93IGlzIGxlZnQgc3BlY2lmaWNhbGx5IGZvclxuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgcGVyZiByZWFzb25zLiBhIHRyeUNhdGNoZXIgaXMgbm90IG5lY2Vzc2FyeSBoZXJlLlxuICAgIEZpbHRlclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZS5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpbHRlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZpbHRlcl8xLmZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHdpbGwgY2FsbCBhIHNwZWNpZmllZCBmdW5jdGlvbiB3aGVuXG4gKiB0aGUgc291cmNlIHRlcm1pbmF0ZXMgb24gY29tcGxldGUgb3IgZXJyb3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBzb3VyY2UgdGVybWluYXRlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UsIGJ1dCB3aWxsIGNhbGwgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvbiB0ZXJtaW5hdGlvbi5cbiAqIEBtZXRob2QgZmluYWxseVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spKTtcbn1cbmV4cG9ydHMuX2ZpbmFsbHkgPSBfZmluYWxseTtcbnZhciBGaW5hbGx5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIEZpbmFsbHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbmFsbHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2FsbGJhY2spKTtcbiAgICB9O1xuICAgIHJldHVybiBGaW5hbGx5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbmFsbHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oY2FsbGJhY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbmFsbHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluYWxseS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZmluYWxseV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmluYWxseScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpbmFsbHkgPSBmaW5hbGx5XzEuX2ZpbmFsbHk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2ZpbmFsbHkgPSBmaW5hbGx5XzEuX2ZpbmFsbHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5hbGx5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEVtaXRzIG9ubHkgdGhlIGZpcnN0IHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWVldHMgc29tZVxuICogY29uZGl0aW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GaW5kcyB0aGUgZmlyc3QgdmFsdWUgdGhhdCBwYXNzZXMgc29tZSB0ZXN0IGFuZCBlbWl0c1xuICogdGhhdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maW5kLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBmaW5kYCBzZWFyY2hlcyBmb3IgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyB0aGVcbiAqIHNwZWNpZmllZCBjb25kaXRpb24gZW1ib2RpZWQgYnkgdGhlIGBwcmVkaWNhdGVgLCBhbmQgcmV0dXJucyB0aGUgZmlyc3RcbiAqIG9jY3VycmVuY2UgaW4gdGhlIHNvdXJjZS4gVW5saWtlIHtAbGluayBmaXJzdH0sIHRoZSBgcHJlZGljYXRlYCBpcyByZXF1aXJlZFxuICogaW4gYGZpbmRgLCBhbmQgZG9lcyBub3QgZW1pdCBhbiBlcnJvciBpZiBhIHZhbGlkIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5GaW5kIGFuZCBlbWl0IHRoZSBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpbmQoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZmlsdGVyfVxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayBmaW5kSW5kZXh9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gdG8gdGVzdCBmb3IgY29uZGl0aW9uIG1hdGNoaW5nLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlXG4gKiBjb25kaXRpb24uXG4gKiBAbWV0aG9kIGZpbmRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEZpbmRWYWx1ZU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpcywgZmFsc2UsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG52YXIgRmluZFZhbHVlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbmRWYWx1ZU9wZXJhdG9yKHByZWRpY2F0ZSwgc291cmNlLCB5aWVsZEluZGV4LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy55aWVsZEluZGV4ID0geWllbGRJbmRleDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmluZFZhbHVlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluZFZhbHVlU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuc291cmNlLCB0aGlzLnlpZWxkSW5kZXgsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbmRWYWx1ZU9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuRmluZFZhbHVlT3BlcmF0b3IgPSBGaW5kVmFsdWVPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmluZFZhbHVlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbmRWYWx1ZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmluZFZhbHVlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCBzb3VyY2UsIHlpZWxkSW5kZXgsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMueWllbGRJbmRleCA9IHlpZWxkSW5kZXg7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBGaW5kVmFsdWVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEZpbmRWYWx1ZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByZWRpY2F0ZSA9IF9hLnByZWRpY2F0ZSwgdGhpc0FyZyA9IF9hLnRoaXNBcmc7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGUuY2FsbCh0aGlzQXJnIHx8IHRoaXMsIHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodGhpcy55aWVsZEluZGV4ID8gaW5kZXggOiB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaW5kVmFsdWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodGhpcy55aWVsZEluZGV4ID8gLTEgOiB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbmRWYWx1ZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLkZpbmRWYWx1ZVN1YnNjcmliZXIgPSBGaW5kVmFsdWVTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZmluZF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmluZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpbmQgPSBmaW5kXzEuZmluZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmluZF8xID0gcmVxdWlyZSgnLi9maW5kJyk7XG4vKipcbiAqIEVtaXRzIG9ubHkgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0XG4gKiBtZWV0cyBzb21lIGNvbmRpdGlvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBmaW5kfSwgYnV0IGVtaXRzIHRoZSBpbmRleCBvZiB0aGVcbiAqIGZvdW5kIHZhbHVlLCBub3QgdGhlIHZhbHVlIGl0c2VsZi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maW5kSW5kZXgucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGZpbmRJbmRleGAgc2VhcmNoZXMgZm9yIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uIGVtYm9kaWVkIGJ5IHRoZSBgcHJlZGljYXRlYCwgYW5kIHJldHVybnMgdGhlXG4gKiAoemVyby1iYXNlZCkgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2UgaW4gdGhlIHNvdXJjZS4gVW5saWtlXG4gKiB7QGxpbmsgZmlyc3R9LCB0aGUgYHByZWRpY2F0ZWAgaXMgcmVxdWlyZWQgaW4gYGZpbmRJbmRleGAsIGFuZCBkb2VzIG5vdCBlbWl0XG4gKiBhbiBlcnJvciBpZiBhIHZhbGlkIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBpbmRleCBvZiBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpbmRJbmRleChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaW5kfVxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gdG8gdGVzdCBmb3IgY29uZGl0aW9uIG1hdGNoaW5nLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdFxuICogbWF0Y2hlcyB0aGUgY29uZGl0aW9uLlxuICogQG1ldGhvZCBmaW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgZmluZF8xLkZpbmRWYWx1ZU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpcywgdHJ1ZSwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kSW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpbmRJbmRleF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmluZEluZGV4Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmluZEluZGV4ID0gZmluZEluZGV4XzEuZmluZEluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZEluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIE9ic2VydmFibGUgb3IgYSBzZXF1ZW5jZSB3YXMgcXVlcmllZCBidXQgaGFzIG5vXG4gKiBlbGVtZW50cy5cbiAqXG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKiBAc2VlIHtAbGluayBzaW5nbGV9XG4gKlxuICogQGNsYXNzIEVtcHR5RXJyb3JcbiAqL1xudmFyIEVtcHR5RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5RXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnbm8gZWxlbWVudHMgaW4gc2VxdWVuY2UnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnRW1wdHlFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gRW1wdHlFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuRW1wdHlFcnJvciA9IEVtcHR5RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbXB0eUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvRW1wdHlFcnJvcicpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCB2YWx1ZSAob3IgdGhlIGZpcnN0IHZhbHVlIHRoYXQgbWVldHMgc29tZSBjb25kaXRpb24pXG4gKiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUuIE9yIGVtaXRzIG9ubHkgdGhlIGZpcnN0XG4gKiB2YWx1ZSB0aGF0IHBhc3NlcyBzb21lIHRlc3QuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmlyc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCBgZmlyc3RgIGVtaXRzIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCB0aGVuIGNvbXBsZXRlcy4gSWYgY2FsbGVkIHdpdGggYSBgcHJlZGljYXRlYCBmdW5jdGlvbiwgYGZpcnN0YFxuICogZW1pdHMgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSBzb3VyY2UgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uLiBJdFxuICogbWF5IGFsc28gdGFrZSBhIGByZXN1bHRTZWxlY3RvcmAgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgb3V0cHV0IHZhbHVlIGZyb21cbiAqIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIGEgYGRlZmF1bHRWYWx1ZWAgdG8gZW1pdCBpbiBjYXNlIHRoZSBzb3VyY2UgY29tcGxldGVzXG4gKiBiZWZvcmUgaXQgaXMgYWJsZSB0byBlbWl0IGEgdmFsaWQgdmFsdWUuIFRocm93cyBhbiBlcnJvciBpZiBgZGVmYXVsdFZhbHVlYFxuICogd2FzIG5vdCBwcm92aWRlZCBhbmQgYSBtYXRjaGluZyBlbGVtZW50IGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiB0aGUgRE9NPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZmlyc3QoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiBhIERJVjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpcnN0KGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqIEBzZWUge0BsaW5rIGZpbmR9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBbcHJlZGljYXRlXVxuICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtIHRvIHRlc3QgZm9yIGNvbmRpdGlvbiBtYXRjaGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBbcmVzdWx0U2VsZWN0b3JdIEEgZnVuY3Rpb24gdG9cbiAqIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzXG4gKiBmdW5jdGlvbiBhcmU6XG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IHdhcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UuXG4gKiAtIGBpbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Un0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgZW1pdHRlZCBpbiBjYXNlIG5vIHZhbGlkIHZhbHVlXG4gKiB3YXMgZm91bmQgb24gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VHxSPn0gYW4gT2JzZXJ2YWJsZSBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlXG4gKiBjb25kaXRpb24uXG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaXJzdChwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaXJzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgdGhpcykpO1xufVxuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xudmFyIEZpcnN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcnN0T3BlcmF0b3IocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBGaXJzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpcnN0U3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuZGVmYXVsdFZhbHVlLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpcnN0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaXJzdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaXJzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlyc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VtaXR0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJlZGljYXRlKHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpcnN0U3Vic2NyaWJlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXRGaW5hbCh2YWx1ZSk7XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdEZpbmFsKHJlc3VsdCk7XG4gICAgfTtcbiAgICBGaXJzdFN1YnNjcmliZXIucHJvdG90eXBlLl9lbWl0RmluYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlyc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQgJiYgdHlwZW9mIHRoaXMuZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpcnN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmaXJzdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmlyc3QnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5maXJzdCA9IGZpcnN0XzEuZmlyc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBNYXBQb2x5ZmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwUG9seWZpbGwoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgfVxuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcFBvbHlmaWxsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBNYXBQb2x5ZmlsbC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuX3ZhbHVlc1tpXSwgdGhpcy5fa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNYXBQb2x5ZmlsbDtcbn0oKSk7XG5leHBvcnRzLk1hcFBvbHlmaWxsID0gTWFwUG9seWZpbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBQb2x5ZmlsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBNYXBQb2x5ZmlsbF8xID0gcmVxdWlyZSgnLi9NYXBQb2x5ZmlsbCcpO1xuZXhwb3J0cy5NYXAgPSByb290XzEucm9vdC5NYXAgfHwgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hcFBvbHlmaWxsXzEuTWFwUG9seWZpbGw7IH0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRmFzdE1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFzdE1hcCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB9XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmFzdE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNba2V5XTtcbiAgICB9O1xuICAgIEZhc3RNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleSkgJiYgdmFsdWVzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHZhbHVlc1trZXldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGYXN0TWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBGYXN0TWFwO1xufSgpKTtcbmV4cG9ydHMuRmFzdE1hcCA9IEZhc3RNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYXN0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBNYXBfMSA9IHJlcXVpcmUoJy4uL3V0aWwvTWFwJyk7XG52YXIgRmFzdE1hcF8xID0gcmVxdWlyZSgnLi4vdXRpbC9GYXN0TWFwJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogR3JvdXBzIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IGFuIE9ic2VydmFibGUgYWNjb3JkaW5nIHRvIGEgc3BlY2lmaWVkIGNyaXRlcmlvbixcbiAqIGFuZCBlbWl0cyB0aGVzZSBncm91cGVkIGl0ZW1zIGFzIGBHcm91cGVkT2JzZXJ2YWJsZXNgLCBvbmVcbiAqIHtAbGluayBHcm91cGVkT2JzZXJ2YWJsZX0gcGVyIGdyb3VwLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZ3JvdXBCeS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogS30ga2V5U2VsZWN0b3IgYSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSBrZXlcbiAqIGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogUn0gW2VsZW1lbnRTZWxlY3Rvcl0gYSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZVxuICogcmV0dXJuIGVsZW1lbnQgZm9yIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZ3JvdXBlZDogR3JvdXBlZE9ic2VydmFibGU8SyxSPik6IE9ic2VydmFibGU8YW55Pn0gW2R1cmF0aW9uU2VsZWN0b3JdXG4gKiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRvIGRldGVybWluZSBob3cgbG9uZyBlYWNoIGdyb3VwIHNob3VsZFxuICogZXhpc3QuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEdyb3VwZWRPYnNlcnZhYmxlPEssUj4+fSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAqIEdyb3VwZWRPYnNlcnZhYmxlcywgZWFjaCBvZiB3aGljaCBjb3JyZXNwb25kcyB0byBhIHVuaXF1ZSBrZXkgdmFsdWUgYW5kIGVhY2hcbiAqIG9mIHdoaWNoIGVtaXRzIHRob3NlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgc2hhcmUgdGhhdCBrZXlcbiAqIHZhbHVlLlxuICogQG1ldGhvZCBncm91cEJ5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBncm91cEJ5KGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IsIHN1YmplY3RTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG52YXIgR3JvdXBCeU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcm91cEJ5T3BlcmF0b3Ioa2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvciwgc3ViamVjdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5lbGVtZW50U2VsZWN0b3IgPSBlbGVtZW50U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlbGVjdG9yID0gc3ViamVjdFNlbGVjdG9yO1xuICAgIH1cbiAgICBHcm91cEJ5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBHcm91cEJ5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmtleVNlbGVjdG9yLCB0aGlzLmVsZW1lbnRTZWxlY3RvciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yLCB0aGlzLnN1YmplY3RTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwQnlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEdyb3VwQnlTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvdXBCeVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvdXBCeVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IsIHN1YmplY3RTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5lbGVtZW50U2VsZWN0b3IgPSBlbGVtZW50U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlbGVjdG9yID0gc3ViamVjdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmtleVNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ3JvdXAodmFsdWUsIGtleSk7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX2dyb3VwID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgICAgICAgZ3JvdXBzID0gdGhpcy5ncm91cHMgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IG5ldyBGYXN0TWFwXzEuRmFzdE1hcCgpIDogbmV3IE1hcF8xLk1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwcy5nZXQoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICBncm91cCA9IHRoaXMuc3ViamVjdFNlbGVjdG9yID8gdGhpcy5zdWJqZWN0U2VsZWN0b3IoKSA6IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgZ3JvdXBzLnNldChrZXksIGdyb3VwKTtcbiAgICAgICAgICAgIHZhciBncm91cGVkT2JzZXJ2YWJsZSA9IG5ldyBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChncm91cGVkT2JzZXJ2YWJsZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvblNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvblNlbGVjdG9yKG5ldyBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGR1cmF0aW9uLnN1YnNjcmliZShuZXcgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIoa2V5LCBncm91cCwgdGhpcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdyb3VwLmNsb3NlZCkge1xuICAgICAgICAgICAgZ3JvdXAubmV4dChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXAsIGtleSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBncm91cC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzLmRlbGV0ZShrZXkpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkICYmICF0aGlzLmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwQnlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBHcm91cER1cmF0aW9uU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHBhcmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgaWYgKCFncm91cC5jbG9zZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlR3JvdXAodGhpcy5rZXkpO1xuICAgIH07XG4gICAgR3JvdXBEdXJhdGlvblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICAgICAgaWYgKCFncm91cC5jbG9zZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlR3JvdXAodGhpcy5rZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLyoqXG4gKiBBbiBPYnNlcnZhYmxlIHJlcHJlc2VudGluZyB2YWx1ZXMgYmVsb25naW5nIHRvIHRoZSBzYW1lIGdyb3VwIHJlcHJlc2VudGVkIGJ5XG4gKiBhIGNvbW1vbiBrZXkuIFRoZSB2YWx1ZXMgZW1pdHRlZCBieSBhIEdyb3VwZWRPYnNlcnZhYmxlIGNvbWUgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgY29tbW9uIGtleSBpcyBhdmFpbGFibGUgYXMgdGhlIGZpZWxkIGBrZXlgIG9uIGFcbiAqIEdyb3VwZWRPYnNlcnZhYmxlIGluc3RhbmNlLlxuICpcbiAqIEBjbGFzcyBHcm91cGVkT2JzZXJ2YWJsZTxLLCBUPlxuICovXG52YXIgR3JvdXBlZE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91cGVkT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwU3ViamVjdCwgcmVmQ291bnRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmdyb3VwU3ViamVjdCA9IGdyb3VwU3ViamVjdDtcbiAgICAgICAgdGhpcy5yZWZDb3VudFN1YnNjcmlwdGlvbiA9IHJlZkNvdW50U3Vic2NyaXB0aW9uO1xuICAgIH1cbiAgICBHcm91cGVkT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlZkNvdW50U3Vic2NyaXB0aW9uID0gX2EucmVmQ291bnRTdWJzY3JpcHRpb24sIGdyb3VwU3ViamVjdCA9IF9hLmdyb3VwU3ViamVjdDtcbiAgICAgICAgaWYgKHJlZkNvdW50U3Vic2NyaXB0aW9uICYmICFyZWZDb3VudFN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQobmV3IElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24ocmVmQ291bnRTdWJzY3JpcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKGdyb3VwU3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIEdyb3VwZWRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Hcm91cGVkT2JzZXJ2YWJsZSA9IEdyb3VwZWRPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uKHBhcmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudC5jb3VudCsrO1xuICAgIH1cbiAgICBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudC5jbG9zZWQgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwYXJlbnQuY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY291bnQgPT09IDAgJiYgcGFyZW50LmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBCeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZ3JvdXBCeV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZ3JvdXBCeScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmdyb3VwQnkgPSBncm91cEJ5XzEuZ3JvdXBCeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwQnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgbm9vcF8xID0gcmVxdWlyZSgnLi4vdXRpbC9ub29wJyk7XG4vKipcbiAqIElnbm9yZXMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBvbmx5IHBhc3NlcyBjYWxscyBvZiBgY29tcGxldGVgIG9yIGBlcnJvcmAuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9pZ25vcmVFbGVtZW50cy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBlbXB0eSBPYnNlcnZhYmxlIHRoYXQgb25seSBjYWxscyBgY29tcGxldGVgXG4gKiBvciBgZXJyb3JgLCBiYXNlZCBvbiB3aGljaCBvbmUgaXMgY2FsbGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgaWdub3JlRWxlbWVudHNcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGlnbm9yZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IElnbm9yZUVsZW1lbnRzT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHM7XG47XG52YXIgSWdub3JlRWxlbWVudHNPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWdub3JlRWxlbWVudHNPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgSWdub3JlRWxlbWVudHNPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSWdub3JlRWxlbWVudHNPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHVudXNlZCkge1xuICAgICAgICBub29wXzEubm9vcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIElnbm9yZUVsZW1lbnRzU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZUVsZW1lbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpZ25vcmVFbGVtZW50c18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvaWdub3JlRWxlbWVudHMnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5pZ25vcmVFbGVtZW50cyA9IGlnbm9yZUVsZW1lbnRzXzEuaWdub3JlRWxlbWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmVFbGVtZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGlzIGVtcHR5IGl0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRydWUsIG90aGVyd2lzZSBpdCBlbWl0cyBmYWxzZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lzRW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgQm9vbGVhbi5cbiAqIEBtZXRob2QgaXNFbXB0eVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBJc0VtcHR5T3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xudmFyIElzRW1wdHlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXNFbXB0eU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBJc0VtcHR5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgSXNFbXB0eVN1YnNjcmliZXIob2JzZXJ2ZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBJc0VtcHR5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJc0VtcHR5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElzRW1wdHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElzRW1wdHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgSXNFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChpc0VtcHR5KTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIElzRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKGZhbHNlKTtcbiAgICB9O1xuICAgIElzRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUodHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gSXNFbXB0eVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0VtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBpc0VtcHR5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9pc0VtcHR5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuaXNFbXB0eSA9IGlzRW1wdHlfMS5pc0VtcHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNFbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIElnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgYSBkdXJhdGlvbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZSwgdGhlblxuICogZW1pdHMgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIHJlcGVhdHMgdGhpc1xuICogcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBhdWRpdFRpbWV9LCBidXQgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2F1ZGl0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBhdWRpdGAgaXMgc2ltaWxhciB0byBgdGhyb3R0bGVgLCBidXQgZW1pdHMgdGhlIGxhc3QgdmFsdWUgZnJvbSB0aGUgc2lsZW5jZWRcbiAqIHRpbWUgd2luZG93LCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCB2YWx1ZS4gYGF1ZGl0YCBlbWl0cyB0aGUgbW9zdCByZWNlbnQgdmFsdWVcbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBhcyBzb29uIGFzIGl0cyBpbnRlcm5hbFxuICogdGltZXIgYmVjb21lcyBkaXNhYmxlZCwgYW5kIGlnbm9yZXMgc291cmNlIHZhbHVlcyB3aGlsZSB0aGUgdGltZXIgaXMgZW5hYmxlZC5cbiAqIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2UgdmFsdWUgYXJyaXZlcyxcbiAqIHRoZSB0aW1lciBpcyBlbmFibGVkIGJ5IGNhbGxpbmcgdGhlIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbiB3aXRoIHRoZVxuICogc291cmNlIHZhbHVlLCB3aGljaCByZXR1cm5zIHRoZSBcImR1cmF0aW9uXCIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgZHVyYXRpb25cbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSBvciBjb21wbGV0ZXMsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCwgdGhlbiB0aGUgbW9zdFxuICogcmVjZW50IHNvdXJjZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYW5kIHRoaXMgcHJvY2Vzc1xuICogcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuYXVkaXQoZXYgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICogQHNlZSB7QGxpbmsgc2FtcGxlfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IE9ic2VydmFibGV8UHJvbWlzZX0gZHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uXG4gKiB0aGF0IHJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGZvciBjb21wdXRpbmcgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24sIHJldHVybmVkIGFzIGFuIE9ic2VydmFibGUgb3IgYSBQcm9taXNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHJhdGUtbGltaXRpbmcgb2ZcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgYXVkaXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGF1ZGl0KGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBBdWRpdE9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuYXVkaXQgPSBhdWRpdDtcbnZhciBBdWRpdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdWRpdE9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgQXVkaXRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEF1ZGl0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXVkaXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXVkaXRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1ZGl0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TZWxlY3RvciA9IGR1cmF0aW9uU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuZHVyYXRpb25TZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGl0U3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJUaHJvdHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgdmFsdWUgPSBfYS52YWx1ZSwgaGFzVmFsdWUgPSBfYS5oYXNWYWx1ZSwgdGhyb3R0bGVkID0gX2EudGhyb3R0bGVkO1xuICAgICAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGl0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaHJvdHRsZSgpO1xuICAgIH07XG4gICAgQXVkaXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRocm90dGxlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXVkaXRTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1ZGl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBhdWRpdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYXVkaXQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5hdWRpdCA9IGF1ZGl0XzEuYXVkaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIElnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gZW1pdHMgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbiBpdCBzZWVzIGEgc291cmNlIHZhbHVlcywgaXQgaWdub3JlcyB0aGF0IHBsdXNcbiAqIHRoZSBuZXh0IG9uZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBpdCBlbWl0cyB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlIGZyb20gdGhlIHNvdXJjZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9hdWRpdFRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0VGltZWAgaXMgc2ltaWxhciB0byBgdGhyb3R0bGVUaW1lYCwgYnV0IGVtaXRzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlXG4gKiBzaWxlbmNlZCB0aW1lIHdpbmRvdywgaW5zdGVhZCBvZiB0aGUgZmlyc3QgdmFsdWUuIGBhdWRpdFRpbWVgIGVtaXRzIHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXNcbiAqIGl0cyBpbnRlcm5hbCB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZVxuICogdGltZXIgaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiBzb3VyY2UgdmFsdWUgYXJyaXZlcywgdGhlIHRpbWVyIGlzIGVuYWJsZWQuIEFmdGVyIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzIChvclxuICogdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBoYXMgcGFzc2VkLFxuICogdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0IHJlY2VudCBzb3VyY2UgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzIHJlcGVhdHMgZm9yIHRoZSBuZXh0IHNvdXJjZSB2YWx1ZS5cbiAqIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgU2NoZWR1bGVyfSBmb3IgbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuYXVkaXRUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyB0aGUgbW9zdCByZWNlbnQgc291cmNlXG4gKiB2YWx1ZSwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5XG4gKiBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHJhdGUtbGltaXRpbmcgYmVoYXZpb3IuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgcmF0ZS1saW1pdGluZyBvZlxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBhdWRpdFRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGF1ZGl0VGltZShkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBBdWRpdFRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmF1ZGl0VGltZSA9IGF1ZGl0VGltZTtcbnZhciBBdWRpdFRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXVkaXRUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBBdWRpdFRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEF1ZGl0VGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvbiwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpdFRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEF1ZGl0VGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpdFRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1ZGl0VGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIEF1ZGl0VGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy50aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1cmF0aW9uLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1ZGl0VGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyVGhyb3R0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHZhbHVlID0gX2EudmFsdWUsIGhhc1ZhbHVlID0gX2EuaGFzVmFsdWUsIHRocm90dGxlZCA9IF9hLnRocm90dGxlZDtcbiAgICAgICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXVkaXRUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChzdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlci5jbGVhclRocm90dGxlKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpdFRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGF1ZGl0VGltZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvYXVkaXRUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYXVkaXRUaW1lID0gYXVkaXRUaW1lXzEuYXVkaXRUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXVkaXRUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4uL3V0aWwvRW1wdHlFcnJvcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGxhc3QgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEl0IG9wdGlvbmFsbHkgdGFrZXMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYXMgYSBwYXJhbWV0ZXIsIGluIHdoaWNoIGNhc2UsIHJhdGhlciB0aGFuIGVtaXR0aW5nXG4gKiB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9sYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIHRoZSBjb25kaXRpb24gYW55IHNvdXJjZSBlbWl0dGVkIGl0ZW0gaGFzIHRvIHNhdGlzZnkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgbGFzdCBpdGVtIHNhdGlzZnlpbmcgdGhlIGdpdmVuIGNvbmRpdGlvblxuICogZnJvbSB0aGUgc291cmNlLCBvciBhbiBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uIGlmIG5vIHN1Y2ggaXRlbXMgYXJlIGVtaXR0ZWQuXG4gKiBAdGhyb3dzIC0gVGhyb3dzIGlmIG5vIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIHByZWRpY2F0ZSBhcmUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGxhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGxhc3QocHJlZGljYXRlLCByZXN1bHRTZWxlY3RvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTGFzdE9wZXJhdG9yKHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgdGhpcykpO1xufVxuZXhwb3J0cy5sYXN0ID0gbGFzdDtcbnZhciBMYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIExhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBMYXN0U3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuZGVmYXVsdFZhbHVlLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIExhc3RPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIExhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGFzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGFzdFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgcmVzdWx0U2VsZWN0b3IsIGRlZmF1bHRWYWx1ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKHRoaXMucHJlZGljYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcmVkaWNhdGUodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIGluZGV4LCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIExhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBsYXN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9sYXN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubGFzdCA9IGxhc3RfMS5sYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQHBhcmFtIGZ1bmNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAbWV0aG9kIGxldFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbGV0UHJvdG8oZnVuYykge1xuICAgIHJldHVybiBmdW5jKHRoaXMpO1xufVxuZXhwb3J0cy5sZXRQcm90byA9IGxldFByb3RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBsZXRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2xldCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmxldCA9IGxldF8xLmxldFByb3RvO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmxldEJpbmQgPSBsZXRfMS5sZXRQcm90bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hldGhlciBvciBub3QgZXZlcnkgaXRlbSBvZiB0aGUgc291cmNlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSBhIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyBpZiBhbiBpdGVtIG1lZXRzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gb3B0aW9uYWwgb2JqZWN0IHRvIHVzZSBmb3IgYHRoaXNgIGluIHRoZSBjYWxsYmFja1xuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSBvZiBib29sZWFucyB0aGF0IGRldGVybWluZXMgaWYgYWxsIGl0ZW1zIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtZWV0IHRoZSBjb25kaXRpb24gc3BlY2lmaWVkLlxuICogQG1ldGhvZCBldmVyeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRXZlcnlPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcsIHRoaXMpKTtcbn1cbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbnZhciBFdmVyeU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVyeU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgRXZlcnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBFdmVyeVN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlcnlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEV2ZXJ5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZXJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVyeVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuICAgIH1cbiAgICBFdmVyeVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZXJ5VmFsdWVNYXRjaCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoZXZlcnlWYWx1ZU1hdGNoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRXZlcnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZS5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuaW5kZXgrKywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZXJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKHRydWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZXJ5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZXJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBldmVyeV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZXZlcnknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5ldmVyeSA9IGV2ZXJ5XzEuZXZlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAgPSBtYXBfMS5tYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEVtaXRzIHRoZSBnaXZlbiBjb25zdGFudCB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgZXZlcnkgdGltZSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2Uge0BsaW5rIG1hcH0sIGJ1dCBpdCBtYXBzIGV2ZXJ5IHNvdXJjZSB2YWx1ZSB0b1xuICogdGhlIHNhbWUgb3V0cHV0IHZhbHVlIGV2ZXJ5IHRpbWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogVGFrZXMgYSBjb25zdGFudCBgdmFsdWVgIGFzIGFyZ3VtZW50LCBhbmQgZW1pdHMgdGhhdCB3aGVuZXZlciB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuIEluIG90aGVyIHdvcmRzLCBpZ25vcmVzIHRoZSBhY3R1YWwgc291cmNlIHZhbHVlLFxuICogYW5kIHNpbXBseSB1c2VzIHRoZSBlbWlzc2lvbiBtb21lbnQgdG8ga25vdyB3aGVuIHRvIGVtaXQgdGhlIGdpdmVuIGB2YWx1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSBzdHJpbmcgJ0hpJzwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZ3JlZXRpbmdzID0gY2xpY2tzLm1hcFRvKCdIaScpO1xuICogZ3JlZXRpbmdzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBtYXAgZWFjaCBzb3VyY2UgdmFsdWUgdG8uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGdpdmVuIGB2YWx1ZWAgZXZlcnkgdGltZVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIHNvbWV0aGluZy5cbiAqIEBtZXRob2QgbWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcFRvKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWFwVG9PcGVyYXRvcih2YWx1ZSkpO1xufVxuZXhwb3J0cy5tYXBUbyA9IG1hcFRvO1xudmFyIE1hcFRvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcFRvT3BlcmF0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBNYXBUb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwVG9TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBUb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwVG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFRvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwVG9TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1hcFRvXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXBUbycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1hcFRvID0gbWFwVG9fMS5tYXBUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYWxsIG9mIHRoZSBub3RpZmljYXRpb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIGBuZXh0YFxuICogZW1pc3Npb25zIG1hcmtlZCB3aXRoIHRoZWlyIG9yaWdpbmFsIHR5cGVzIHdpdGhpbiB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICogb2JqZWN0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V3JhcHMgYG5leHRgLCBgZXJyb3JgIGFuZCBgY29tcGxldGVgIGVtaXNzaW9ucyBpblxuICoge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cywgZW1pdHRlZCBhcyBgbmV4dGAgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWF0ZXJpYWxpemUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1hdGVyaWFsaXplYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIGBuZXh0YCBub3RpZmljYXRpb24gZm9yIGVhY2hcbiAqIGBuZXh0YCwgYGVycm9yYCwgb3IgYGNvbXBsZXRlYCBlbWlzc2lvbiBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuIFdoZW4gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBgY29tcGxldGVgLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgd2lsbCBlbWl0IGBuZXh0YCBhc1xuICogYSBOb3RpZmljYXRpb24gb2YgdHlwZSBcImNvbXBsZXRlXCIsIGFuZCB0aGVuIGl0IHdpbGwgZW1pdCBgY29tcGxldGVgIGFzIHdlbGwuXG4gKiBXaGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBgZXJyb3JgLCB0aGUgb3V0cHV0IHdpbGwgZW1pdCBgbmV4dGAgYXMgYVxuICogTm90aWZpY2F0aW9uIG9mIHR5cGUgXCJlcnJvclwiLCBhbmQgdGhlbiBgY29tcGxldGVgLlxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBwcm9kdWNpbmcgbWV0YWRhdGEgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0b1xuICogYmUgY29uc3VtZWQgYXMgYG5leHRgIGVtaXNzaW9ucy4gVXNlIGl0IGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqIHtAbGluayBkZW1hdGVyaWFsaXplfS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGEgZmF1bHR5IE9ic2VydmFibGUgdG8gYW4gT2JzZXJ2YWJsZSBvZiBOb3RpZmljYXRpb25zPC9jYXB0aW9uPlxuICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAxMywgJ2QnKTtcbiAqIHZhciB1cHBlckNhc2UgPSBsZXR0ZXJzLm1hcCh4ID0+IHgudG9VcHBlckNhc2UoKSk7XG4gKiB2YXIgbWF0ZXJpYWxpemVkID0gdXBwZXJDYXNlLm1hdGVyaWFsaXplKCk7XG4gKiBtYXRlcmlhbGl6ZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIC0gTm90aWZpY2F0aW9uIHtraW5kOiBcIk5cIiwgdmFsdWU6IFwiQVwiLCBlcnJvcjogdW5kZWZpbmVkLCBoYXNWYWx1ZTogdHJ1ZX1cbiAqIC8vIC0gTm90aWZpY2F0aW9uIHtraW5kOiBcIk5cIiwgdmFsdWU6IFwiQlwiLCBlcnJvcjogdW5kZWZpbmVkLCBoYXNWYWx1ZTogdHJ1ZX1cbiAqIC8vIC0gTm90aWZpY2F0aW9uIHtraW5kOiBcIkVcIiwgdmFsdWU6IHVuZGVmaW5lZCwgZXJyb3I6IFR5cGVFcnJvcjpcbiAqIC8vICAgeC50b1VwcGVyQ2FzZSBpcyBub3QgYSBmdW5jdGlvbiBhdCBNYXBTdWJzY3JpYmVyLmxldHRlcnMubWFwLnhcbiAqIC8vICAgW2FzIHByb2plY3RdIChodHRwOi8vMeKApiwgaGFzVmFsdWU6IGZhbHNlfVxuICpcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIGRlbWF0ZXJpYWxpemV9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxOb3RpZmljYXRpb248VD4+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAqIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMgdGhhdCB3cmFwIHRoZSBvcmlnaW5hbCBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHdpdGggbWV0YWRhdGEuXG4gKiBAbWV0aG9kIG1hdGVyaWFsaXplXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNYXRlcmlhbGl6ZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5tYXRlcmlhbGl6ZSA9IG1hdGVyaWFsaXplO1xudmFyIE1hdGVyaWFsaXplT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsaXplT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIE1hdGVyaWFsaXplT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXRlcmlhbGl6ZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdGVyaWFsaXplT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNYXRlcmlhbGl6ZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXRlcmlhbGl6ZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxpemVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgTWF0ZXJpYWxpemVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIE1hdGVyaWFsaXplU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIE1hdGVyaWFsaXplU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXRlcmlhbGl6ZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRlcmlhbGl6ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWF0ZXJpYWxpemVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hdGVyaWFsaXplJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWF0ZXJpYWxpemUgPSBtYXRlcmlhbGl6ZV8xLm1hdGVyaWFsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0ZXJpYWxpemUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQXBwbGllcyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiBvdmVyIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIHJldHVybnMgdGhlXG4gKiBhY2N1bXVsYXRlZCByZXN1bHQgd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcywgZ2l2ZW4gYW4gb3B0aW9uYWwgc2VlZCB2YWx1ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29tYmluZXMgdG9nZXRoZXIgYWxsIHZhbHVlcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UsXG4gKiB1c2luZyBhbiBhY2N1bXVsYXRvciBmdW5jdGlvbiB0aGF0IGtub3dzIGhvdyB0byBqb2luIGEgbmV3IHNvdXJjZSB2YWx1ZSBpbnRvXG4gKiB0aGUgYWNjdW11bGF0aW9uIGZyb20gdGhlIHBhc3QuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmVkdWNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIExpa2VcbiAqIFtBcnJheS5wcm90b3R5cGUucmVkdWNlKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSksXG4gKiBgcmVkdWNlYCBhcHBsaWVzIGFuIGBhY2N1bXVsYXRvcmAgZnVuY3Rpb24gYWdhaW5zdCBhbiBhY2N1bXVsYXRpb24gYW5kIGVhY2hcbiAqIHZhbHVlIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSAoZnJvbSB0aGUgcGFzdCkgdG8gcmVkdWNlIGl0IHRvIGEgc2luZ2xlXG4gKiB2YWx1ZSwgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIE5vdGUgdGhhdCBgcmVkdWNlYCB3aWxsIG9ubHkgZW1pdFxuICogb25lIHZhbHVlLCBvbmx5IHdoZW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcy4gSXQgaXMgZXF1aXZhbGVudCB0b1xuICogYXBwbHlpbmcgb3BlcmF0b3Ige0BsaW5rIHNjYW59IGZvbGxvd2VkIGJ5IG9wZXJhdG9yIHtAbGluayBsYXN0fS5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBhcHBsaWVzIGEgc3BlY2lmaWVkIGBhY2N1bXVsYXRvcmAgZnVuY3Rpb24gdG8gZWFjaFxuICogaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBgc2VlZGAgdmFsdWUgaXMgc3BlY2lmaWVkLCB0aGVuXG4gKiB0aGF0IHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGFjY3VtdWxhdG9yLiBJZiBubyBzZWVkXG4gKiB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBzb3VyY2UgaXMgdXNlZCBhcyB0aGUgc2VlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudCB0aGUgbnVtYmVyIG9mIGNsaWNrIGV2ZW50cyB0aGF0IGhhcHBlbmVkIGluIDUgc2Vjb25kczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3NJbkZpdmVTZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpXG4gKiAgIC50YWtlVW50aWwoUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDAwKSk7XG4gKiB2YXIgb25lcyA9IGNsaWNrc0luRml2ZVNlY29uZHMubWFwVG8oMSk7XG4gKiB2YXIgc2VlZCA9IDA7XG4gKiB2YXIgY291bnQgPSBvbmVzLnJlZHVjZSgoYWNjLCBvbmUpID0+IGFjYyArIG9uZSwgc2VlZCk7XG4gKiBjb3VudC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY291bnR9XG4gKiBAc2VlIHtAbGluayBleHBhbmR9XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzY2FufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYWNjOiBSLCB2YWx1ZTogVCk6IFJ9IGFjY3VtdWxhdG9yIFRoZSBhY2N1bXVsYXRvciBmdW5jdGlvblxuICogY2FsbGVkIG9uIGVhY2ggc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtSfSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0aW9uIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gb2JzZXJ2YWJsZSBvZiB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgc2luZ2xlIHZhbHVlIHRoYXQgaXMgdGhlXG4gKiByZXN1bHQgb2YgYWNjdW11bGF0aW5nIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHJlZHVjZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGFjY3VtdWxhdG9yLCBzZWVkKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZTtcbiAgICAvLyBwcm92aWRpbmcgYSBzZWVkIG9mIGB1bmRlZmluZWRgICpzaG91bGQqIGJlIHZhbGlkIGFuZCB0cmlnZ2VyXG4gICAgLy8gaGFzU2VlZCEgc28gZG9uJ3QgdXNlIGBzZWVkICE9PSB1bmRlZmluZWRgIGNoZWNrcyFcbiAgICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGhhdmUgdG8gY2hlY2sgaXQgaGVyZSBhdCB0aGUgb3JpZ2luYWwgY2FsbCBzaXRlXG4gICAgLy8gb3RoZXJ3aXNlIGluc2lkZSBPcGVyYXRvci9TdWJzY3JpYmVyIHdlIHdvbid0IGtub3cgaWYgYHVuZGVmaW5lZGBcbiAgICAvLyBtZWFucyB0aGV5IGRpZG4ndCBwcm92aWRlIGFueXRoaW5nIG9yIGlmIHRoZXkgbGl0ZXJhbGx5IHByb3ZpZGVkIGB1bmRlZmluZWRgXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICBoYXNTZWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVkdWNlT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQpKTtcbn1cbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xudmFyIFJlZHVjZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWR1Y2VPcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgaGFzU2VlZCkge1xuICAgICAgICBpZiAoaGFzU2VlZCA9PT0gdm9pZCAwKSB7IGhhc1NlZWQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuaGFzU2VlZCA9IGhhc1NlZWQ7XG4gICAgfVxuICAgIFJlZHVjZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmVkdWNlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFjY3VtdWxhdG9yLCB0aGlzLnNlZWQsIHRoaXMuaGFzU2VlZCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZHVjZU9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuUmVkdWNlT3BlcmF0b3IgPSBSZWR1Y2VPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUmVkdWNlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZHVjZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuaGFzU2VlZCA9IGhhc1NlZWQ7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2MgPSBzZWVkO1xuICAgIH1cbiAgICBSZWR1Y2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSB8fCAodGhpcy5oYXNWYWx1ZSA9IHRoaXMuaGFzU2VlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVJlZHVjZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjYyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZHVjZVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlSZWR1Y2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYWNjdW11bGF0b3IodGhpcy5hY2MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2MgPSByZXN1bHQ7XG4gICAgfTtcbiAgICBSZWR1Y2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlIHx8IHRoaXMuaGFzU2VlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuYWNjKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuUmVkdWNlU3Vic2NyaWJlciA9IFJlZHVjZVN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVkdWNlXzEgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuLyoqXG4gKiBUaGUgTWF4IG9wZXJhdG9yIG9wZXJhdGVzIG9uIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBudW1iZXJzIChvciBpdGVtcyB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgYXMgbnVtYmVycyksXG4gKiBhbmQgd2hlbiBzb3VyY2UgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgaXQgZW1pdHMgYSBzaW5nbGUgaXRlbTogdGhlIGl0ZW0gd2l0aCB0aGUgbGFyZ2VzdCBudW1iZXIuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tYXgucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwgY29tcGFyZXIgZnVuY3Rpb24gdGhhdCBpdCB3aWxsIHVzZSBpbnN0ZWFkIG9mIGl0cyBkZWZhdWx0IHRvIGNvbXBhcmUgdGhlIHZhbHVlIG9mIHR3b1xuICogaXRlbXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbSB3aXRoIHRoZSBsYXJnZXN0IG51bWJlci5cbiAqIEBtZXRob2QgbWF4XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXgoY29tcGFyZXIpIHtcbiAgICB2YXIgbWF4ID0gKHR5cGVvZiBjb21wYXJlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgPyBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gY29tcGFyZXIoeCwgeSkgPiAwID8geCA6IHk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCA+IHkgPyB4IDogeTsgfTtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyByZWR1Y2VfMS5SZWR1Y2VPcGVyYXRvcihtYXgpKTtcbn1cbmV4cG9ydHMubWF4ID0gbWF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtYXhfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21heCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1heCA9IG1heF8xLm1heDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2UgPSBtZXJnZV8xLm1lcmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tZXJnZUFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlQWxsID0gbWVyZ2VBbGxfMS5tZXJnZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtZXJnZU1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWVyZ2VNYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tZXJnZU1hcCA9IG1lcmdlTWFwXzEubWVyZ2VNYXA7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdE1hcCA9IG1lcmdlTWFwXzEubWVyZ2VNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VNYXBUb18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWVyZ2VNYXBUbycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZsYXRNYXBUbyA9IG1lcmdlTWFwVG9fMS5tZXJnZU1hcFRvO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlTWFwVG8gPSBtZXJnZU1hcFRvXzEubWVyZ2VNYXBUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwVG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAcGFyYW0gcHJvamVjdFxuICogQHBhcmFtIHNlZWRcbiAqIEBwYXJhbSBjb25jdXJyZW50XG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fFdlYlNvY2tldFN1YmplY3Q8VD58T2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgbWVyZ2VTY2FuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZVNjYW4ocHJvamVjdCwgc2VlZCwgY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlU2Nhbk9wZXJhdG9yKHByb2plY3QsIHNlZWQsIGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VTY2FuID0gbWVyZ2VTY2FuO1xudmFyIE1lcmdlU2Nhbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZVNjYW5PcGVyYXRvcihwcm9qZWN0LCBzZWVkLCBjb25jdXJyZW50KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlU2Nhbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VTY2FuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMuc2VlZCwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VTY2FuT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZVNjYW5PcGVyYXRvciA9IE1lcmdlU2Nhbk9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZVNjYW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VTY2FuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZVNjYW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCBhY2MsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmFjYyA9IGFjYztcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHZhciBpc2ggPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMucHJvamVjdCkodGhpcy5hY2MsIHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgICAgICBpZiAoaXNoID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5uZXJTdWIoaXNoLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChpc2gsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGlzaCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBNZXJnZVNjYW5TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuYWNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLmFjYyA9IGlubmVyVmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgTWVyZ2VTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmFjYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZVNjYW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VTY2FuU3Vic2NyaWJlciA9IE1lcmdlU2NhblN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVNjYW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlU2Nhbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWVyZ2VTY2FuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VTY2FuID0gbWVyZ2VTY2FuXzEubWVyZ2VTY2FuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VTY2FuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJlZHVjZV8xID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbi8qKlxuICogVGhlIE1pbiBvcGVyYXRvciBvcGVyYXRlcyBvbiBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbnVtYmVycyAob3IgaXRlbXMgdGhhdCBjYW4gYmUgZXZhbHVhdGVkIGFzIG51bWJlcnMpLFxuICogYW5kIHdoZW4gc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzIGl0IGVtaXRzIGEgc2luZ2xlIGl0ZW06IHRoZSBpdGVtIHdpdGggdGhlIHNtYWxsZXN0IG51bWJlci5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21pbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCBjb21wYXJlciBmdW5jdGlvbiB0aGF0IGl0IHdpbGwgdXNlIGluc3RlYWQgb2YgaXRzIGRlZmF1bHQgdG8gY29tcGFyZSB0aGUgdmFsdWUgb2YgdHdvIGl0ZW1zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW0gd2l0aCB0aGUgc21hbGxlc3QgbnVtYmVyLlxuICogQG1ldGhvZCBtaW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1pbihjb21wYXJlcikge1xuICAgIHZhciBtaW4gPSAodHlwZW9mIGNvbXBhcmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICA/IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiBjb21wYXJlcih4LCB5KSA8IDAgPyB4IDogeTsgfVxuICAgICAgICA6IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4IDwgeSA/IHggOiB5OyB9O1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IHJlZHVjZV8xLlJlZHVjZU9wZXJhdG9yKG1pbikpO1xufVxuZXhwb3J0cy5taW4gPSBtaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1pbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWluJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWluID0gbWluXzEubWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogQGNsYXNzIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHN1YmplY3RGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XG4gICAgfVxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1YmplY3QoKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmdldFN1YmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5fc3ViamVjdDtcbiAgICAgICAgaWYgKCFzdWJqZWN0IHx8IHN1YmplY3QuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gdGhpcy5zdWJqZWN0RmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0O1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmFkZCh0aGlzLnNvdXJjZVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUobmV3IENvbm5lY3RhYmxlU3Vic2NyaWJlcih0aGlzLmdldFN1YmplY3QoKSwgdGhpcykpKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVmQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJlZkNvdW50T3BlcmF0b3IodGhpcykpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xuZXhwb3J0cy5jb25uZWN0YWJsZU9ic2VydmFibGVEZXNjcmlwdG9yID0ge1xuICAgIG9wZXJhdG9yOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgX3JlZkNvdW50OiB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIF9zdWJzY3JpYmU6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSB9LFxuICAgIGdldFN1YmplY3Q6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCB9LFxuICAgIGNvbm5lY3Q6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCB9LFxuICAgIHJlZkNvdW50OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50IH1cbn07XG52YXIgQ29ubmVjdGFibGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29ubmVjdGFibGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29ubmVjdGFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBpZiAoY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RhYmxlU3Vic2NyaWJlcjtcbn0oU3ViamVjdF8xLlN1YmplY3RTdWJzY3JpYmVyKSk7XG52YXIgUmVmQ291bnRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRPcGVyYXRvcihjb25uZWN0YWJsZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIFJlZkNvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCsrO1xuICAgICAgICB2YXIgcmVmQ291bnRlciA9IG5ldyBSZWZDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgY29ubmVjdGFibGUpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShyZWZDb3VudGVyKTtcbiAgICAgICAgaWYgKCFyZWZDb3VudGVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmVmQ291bnRlci5jb25uZWN0aW9uID0gY29ubmVjdGFibGUuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gUmVmQ291bnRPcGVyYXRvcjtcbn0oKSk7XG52YXIgUmVmQ291bnRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmQ291bnRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29ubmVjdGFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIFJlZkNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBpZiAoIWNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVmQ291bnQgPSBjb25uZWN0YWJsZS5fcmVmQ291bnQ7XG4gICAgICAgIGlmIChyZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCA9IHJlZkNvdW50IC0gMTtcbiAgICAgICAgaWYgKHJlZkNvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLy9cbiAgICAgICAgLy8gQ29tcGFyZSB0aGUgbG9jYWwgUmVmQ291bnRTdWJzY3JpYmVyJ3MgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gdG8gdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIG9uIHRoZSBzaGFyZWQgQ29ubmVjdGFibGVPYnNlcnZhYmxlLiBJbiBjYXNlc1xuICAgICAgICAvLyB3aGVyZSB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHNvdXJjZSBzeW5jaHJvbm91c2x5IGVtaXRzIHZhbHVlcywgYW5kXG4gICAgICAgIC8vIHRoZSBSZWZDb3VudFN1YnNjcmliZXIncyBkb3duc3RyZWFtIE9ic2VydmVycyBzeW5jaHJvbm91c2x5IHVuc3Vic2NyaWJlLFxuICAgICAgICAvLyBleGVjdXRpb24gY29udGludWVzIHRvIGhlcmUgYmVmb3JlIHRoZSBSZWZDb3VudE9wZXJhdG9yIGhhcyBhIGNoYW5jZSB0b1xuICAgICAgICAvLyBzdXBwbHkgdGhlIFJlZkNvdW50U3Vic2NyaWJlciB3aXRoIHRoZSBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24uXG4gICAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gT2JzZXJ2YWJsZS5yYW5nZSgwLCAxMClcbiAgICAgICAgLy8gICAucHVibGlzaCgpXG4gICAgICAgIC8vICAgLnJlZkNvdW50KClcbiAgICAgICAgLy8gICAudGFrZSg1KVxuICAgICAgICAvLyAgIC5zdWJzY3JpYmUoKTtcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGFjY291bnQgZm9yIHRoaXMgY2FzZSwgUmVmQ291bnRTdWJzY3JpYmVyIHNob3VsZCBvbmx5IGRpc3Bvc2VcbiAgICAgICAgLy8gdGhlIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSdzIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBpZiB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gZXhpc3RzLCAqYW5kKiBlaXRoZXI6XG4gICAgICAgIC8vICAgYS4gUmVmQ291bnRTdWJzY3JpYmVyIGRvZXNuJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gICAgICBTdWJzY3JpcHRpb24geWV0LCBvcixcbiAgICAgICAgLy8gICBiLiBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiByZWZlcmVuY2UgaXMgaWRlbnRpY2FsXG4gICAgICAgIC8vICAgICAgdG8gdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvblxuICAgICAgICAvLy9cbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgICAgIHZhciBzaGFyZWRDb25uZWN0aW9uID0gY29ubmVjdGFibGUuX2Nvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGlmIChzaGFyZWRDb25uZWN0aW9uICYmICghY29ubmVjdGlvbiB8fCBzaGFyZWRDb25uZWN0aW9uID09PSBjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgc2hhcmVkQ29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVmQ291bnRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29ubmVjdGFibGVPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUnKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBpbnZva2luZyBhIHNwZWNpZmllZCBzZWxlY3RvciBvbiBpdGVtc1xuICogZW1pdHRlZCBieSBhIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbXVsdGljYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3ViamVjdH0gRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIHN1YmplY3QgdGhyb3VnaFxuICogd2hpY2ggdGhlIHNvdXJjZSBzZXF1ZW5jZSdzIGVsZW1lbnRzIHdpbGwgYmUgbXVsdGljYXN0IHRvIHRoZSBzZWxlY3RvciBmdW5jdGlvblxuICogb3IgU3ViamVjdCB0byBwdXNoIHNvdXJjZSBlbGVtZW50cyBpbnRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc3RyZWFtXG4gKiBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzdHJlYW0uXG4gKiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlXG4gKiB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gZm9yd2FyZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3JcbiAqIG9uIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IGEgYENvbm5lY3RhYmxlT2JzZXJ2YWJsZWAgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvXG4gKiB0aGUgdW5kZXJseWluZyBzdHJlYW0uXG4gKiBAbWV0aG9kIG11bHRpY2FzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbXVsdGljYXN0KHN1YmplY3RPclN1YmplY3RGYWN0b3J5LCBzZWxlY3Rvcikge1xuICAgIHZhciBzdWJqZWN0RmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHN1YmplY3RPclN1YmplY3RGYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN1YmplY3RGYWN0b3J5ID0gc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdWJqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIHN1YmplY3RGYWN0b3J5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE11bHRpY2FzdE9wZXJhdG9yKHN1YmplY3RGYWN0b3J5LCBzZWxlY3RvcikpO1xuICAgIH1cbiAgICB2YXIgY29ubmVjdGFibGUgPSBPYmplY3QuY3JlYXRlKHRoaXMsIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xLmNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IpO1xuICAgIGNvbm5lY3RhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgY29ubmVjdGFibGUuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICByZXR1cm4gY29ubmVjdGFibGU7XG59XG5leHBvcnRzLm11bHRpY2FzdCA9IG11bHRpY2FzdDtcbnZhciBNdWx0aWNhc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGljYXN0T3BlcmF0b3Ioc3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBNdWx0aWNhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZWxlY3RvcihzdWJqZWN0KS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoc291cmNlLnN1YnNjcmliZShzdWJqZWN0KSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGljYXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NdWx0aWNhc3RPcGVyYXRvciA9IE11bHRpY2FzdE9wZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGljYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL211bHRpY2FzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm11bHRpY2FzdCA9IG11bHRpY2FzdF8xLm11bHRpY2FzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpY2FzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb2JzZXJ2ZU9uXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9vYnNlcnZlT24nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5vYnNlcnZlT24gPSBvYnNlcnZlT25fMS5vYnNlcnZlT247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlT24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9uRXJyb3JSZXN1bWVOZXh0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9vbkVycm9yUmVzdW1lTmV4dCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm9uRXJyb3JSZXN1bWVOZXh0ID0gb25FcnJvclJlc3VtZU5leHRfMS5vbkVycm9yUmVzdW1lTmV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRXJyb3JSZXN1bWVOZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBHcm91cHMgcGFpcnMgb2YgY29uc2VjdXRpdmUgZW1pc3Npb25zIHRvZ2V0aGVyIGFuZCBlbWl0cyB0aGVtIGFzIGFuIGFycmF5IG9mXG4gKiB0d28gdmFsdWVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBwcmV2aW91cyB2YWx1ZSB0b2dldGhlciBhc1xuICogYW4gYXJyYXksIGFuZCBlbWl0cyB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhaXJ3aXNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRoZSBOdGggZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHRvIGVtaXQgYW4gYXJyYXkgWyhOLTEpdGgsIE50aF0gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudCB2YWx1ZSwgYXMgYVxuICogcGFpci4gRm9yIHRoaXMgcmVhc29uLCBgcGFpcndpc2VgIGVtaXRzIG9uIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnRcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG5vdCBvbiB0aGUgZmlyc3QgZW1pc3Npb24sIGJlY2F1c2VcbiAqIHRoZXJlIGlzIG5vIHByZXZpb3VzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayAoc3RhcnRpbmcgZnJvbSB0aGUgc2Vjb25kKSwgZW1pdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgdG8gdGhlIHByZXZpb3VzIGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYWlycyA9IGNsaWNrcy5wYWlyd2lzZSgpO1xuICogdmFyIGRpc3RhbmNlID0gcGFpcnMubWFwKHBhaXIgPT4ge1xuICogICB2YXIgeDAgPSBwYWlyWzBdLmNsaWVudFg7XG4gKiAgIHZhciB5MCA9IHBhaXJbMF0uY2xpZW50WTtcbiAqICAgdmFyIHgxID0gcGFpclsxXS5jbGllbnRYO1xuICogICB2YXIgeTEgPSBwYWlyWzFdLmNsaWVudFk7XG4gKiAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDAgLSB4MSwgMikgKyBNYXRoLnBvdyh5MCAtIHkxLCAyKSk7XG4gKiB9KTtcbiAqIGRpc3RhbmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEFycmF5PFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiBwYWlycyAoYXMgYXJyYXlzKSBvZlxuICogY29uc2VjdXRpdmUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBwYWlyd2lzZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGFpcndpc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUGFpcndpc2VPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMucGFpcndpc2UgPSBwYWlyd2lzZTtcbnZhciBQYWlyd2lzZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBQYWlyd2lzZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUGFpcndpc2VTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUGFpcndpc2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcndpc2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUHJldiA9IGZhbHNlO1xuICAgIH1cbiAgICBQYWlyd2lzZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChbdGhpcy5wcmV2LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlyd2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcGFpcndpc2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3BhaXJ3aXNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucGFpcndpc2UgPSBwYWlyd2lzZV8xLnBhaXJ3aXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFpcndpc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBub3QocHJlZCwgdGhpc0FyZykge1xuICAgIGZ1bmN0aW9uIG5vdFByZWQoKSB7XG4gICAgICAgIHJldHVybiAhKG5vdFByZWQucHJlZC5hcHBseShub3RQcmVkLnRoaXNBcmcsIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBub3RQcmVkLnByZWQgPSBwcmVkO1xuICAgIG5vdFByZWQudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgcmV0dXJuIG5vdFByZWQ7XG59XG5leHBvcnRzLm5vdCA9IG5vdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBub3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvbm90Jyk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuLyoqXG4gKiBTcGxpdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGludG8gdHdvLCBvbmUgd2l0aCB2YWx1ZXMgdGhhdCBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIGFub3RoZXIgd2l0aCB2YWx1ZXMgdGhhdCBkb24ndCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZmlsdGVyfSwgYnV0IHJldHVybnMgdHdvIE9ic2VydmFibGVzOlxuICogb25lIGxpa2UgdGhlIG91dHB1dCBvZiB7QGxpbmsgZmlsdGVyfSwgYW5kIHRoZSBvdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRpZCBub3RcbiAqIHBhc3MgdGhlIGNvbmRpdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wYXJ0aXRpb24ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHBhcnRpdGlvbmAgb3V0cHV0cyBhbiBhcnJheSB3aXRoIHR3byBPYnNlcnZhYmxlcyB0aGF0IHBhcnRpdGlvbiB0aGUgdmFsdWVzXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aHJvdWdoIHRoZSBnaXZlbiBgcHJlZGljYXRlYCBmdW5jdGlvbi4gVGhlIGZpcnN0XG4gKiBPYnNlcnZhYmxlIGluIHRoYXQgYXJyYXkgZW1pdHMgc291cmNlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIHByZWRpY2F0ZSBhcmd1bWVudFxuICogcmV0dXJucyB0cnVlLiBUaGUgc2Vjb25kIE9ic2VydmFibGUgZW1pdHMgc291cmNlIHZhbHVlcyBmb3Igd2hpY2ggdGhlXG4gKiBwcmVkaWNhdGUgcmV0dXJucyBmYWxzZS4gVGhlIGZpcnN0IGJlaGF2ZXMgbGlrZSB7QGxpbmsgZmlsdGVyfSBhbmQgdGhlIHNlY29uZFxuICogYmVoYXZlcyBsaWtlIHtAbGluayBmaWx0ZXJ9IHdpdGggdGhlIHByZWRpY2F0ZSBuZWdhdGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlBhcnRpdGlvbiBjbGljayBldmVudHMgaW50byB0aG9zZSBvbiBESVYgZWxlbWVudHMgYW5kIHRob3NlIGVsc2V3aGVyZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcGFydHMgPSBjbGlja3MucGFydGl0aW9uKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gcGFydHNbMF07XG4gKiB2YXIgY2xpY2tzRWxzZXdoZXJlID0gcGFydHNbMV07XG4gKiBjbGlja3NPbkRpdnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0RJViBjbGlja2VkOiAnLCB4KSk7XG4gKiBjbGlja3NFbHNld2hlcmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ090aGVyIGNsaWNrZWQ6ICcsIHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBmaXJzdCBPYnNlcnZhYmxlIGluIHRoZSByZXR1cm5lZCBhcnJheSwgaWZcbiAqIGBmYWxzZWAgdGhlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNlY29uZCBPYnNlcnZhYmxlIGluIHRoZSBhcnJheS4gVGhlXG4gKiBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlIGVtaXNzaW9uIHRoYXQgaGFzXG4gKiBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7W09ic2VydmFibGU8VD4sIE9ic2VydmFibGU8VD5dfSBBbiBhcnJheSB3aXRoIHR3byBPYnNlcnZhYmxlczogb25lXG4gKiB3aXRoIHZhbHVlcyB0aGF0IHBhc3NlZCB0aGUgcHJlZGljYXRlLCBhbmQgYW5vdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRpZCBub3RcbiAqIHBhc3MgdGhlIHByZWRpY2F0ZS5cbiAqIEBtZXRob2QgcGFydGl0aW9uXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwYXJ0aXRpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZmlsdGVyXzEuZmlsdGVyLmNhbGwodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnKSxcbiAgICAgICAgZmlsdGVyXzEuZmlsdGVyLmNhbGwodGhpcywgbm90XzEubm90KHByZWRpY2F0ZSwgdGhpc0FyZykpXG4gICAgXTtcbn1cbmV4cG9ydHMucGFydGl0aW9uID0gcGFydGl0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGl0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwYXJ0aXRpb25fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3BhcnRpdGlvbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnBhcnRpdGlvbiA9IHBhcnRpdGlvbl8xLnBhcnRpdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4vbWFwJyk7XG4vKipcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgKGFuIG9iamVjdCkgdG8gaXRzIHNwZWNpZmllZCBuZXN0ZWQgcHJvcGVydHkuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2Uge0BsaW5rIG1hcH0sIGJ1dCBtZWFudCBvbmx5IGZvciBwaWNraW5nIG9uZSBvZlxuICogdGhlIG5lc3RlZCBwcm9wZXJ0aWVzIG9mIGV2ZXJ5IGVtaXR0ZWQgb2JqZWN0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BsdWNrLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEdpdmVuIGEgbGlzdCBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgYSBwYXRoIHRvIGFuIG9iamVjdCBwcm9wZXJ0eSwgcmV0cmlldmVzXG4gKiB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5IGZyb20gYWxsIHZhbHVlcyBpbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBJZiBhIHByb3BlcnR5IGNhbid0IGJlIHJlc29sdmVkLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAqIHRoYXQgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSB0YWdOYW1lIG9mIHRoZSBjbGlja2VkIHRhcmdldCBlbGVtZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0YWdOYW1lcyA9IGNsaWNrcy5wbHVjaygndGFyZ2V0JywgJ3RhZ05hbWUnKTtcbiAqIHRhZ05hbWVzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKlxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHByb3BlcnRpZXMgVGhlIG5lc3RlZCBwcm9wZXJ0aWVzIHRvIHBsdWNrIGZyb20gZWFjaCBzb3VyY2VcbiAqIHZhbHVlIChhbiBvYmplY3QpLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gUmV0dXJucyBhIG5ldyBPYnNlcnZhYmxlIG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZVxuICogc291cmNlIHZhbHVlcy5cbiAqIEBtZXRob2QgcGx1Y2tcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHBsdWNrKCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcHJvcGVydGllc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaXN0IG9mIHByb3BlcnRpZXMgY2Fubm90IGJlIGVtcHR5LicpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwXzEubWFwLmNhbGwodGhpcywgcGx1Y2tlcihwcm9wZXJ0aWVzLCBsZW5ndGgpKTtcbn1cbmV4cG9ydHMucGx1Y2sgPSBwbHVjaztcbmZ1bmN0aW9uIHBsdWNrZXIocHJvcHMsIGxlbmd0aCkge1xuICAgIHZhciBtYXBwZXIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgY3VycmVudFByb3AgPSB4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGN1cnJlbnRQcm9wW3Byb3BzW2ldXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvcDtcbiAgICB9O1xuICAgIHJldHVybiBtYXBwZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcGx1Y2tfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3BsdWNrJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucGx1Y2sgPSBwbHVja18xLnBsdWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Y2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgQ29ubmVjdGFibGVPYnNlcnZhYmxlLCB3aGljaCBpcyBhIHZhcmlldHkgb2YgT2JzZXJ2YWJsZSB0aGF0IHdhaXRzIHVudGlsIGl0cyBjb25uZWN0IG1ldGhvZCBpcyBjYWxsZWRcbiAqIGJlZm9yZSBpdCBiZWdpbnMgZW1pdHRpbmcgaXRlbXMgdG8gdGhvc2UgT2JzZXJ2ZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHRvIGl0LlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcHVibGlzaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsXG4gKiB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICogU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIGEgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHRoYXQgdXBvbiBjb25uZWN0aW9uIGNhdXNlcyB0aGUgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBpdGVtcyB0byBpdHMgT2JzZXJ2ZXJzLlxuICogQG1ldGhvZCBwdWJsaXNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7IH0sIHNlbGVjdG9yKSA6XG4gICAgICAgIG11bHRpY2FzdF8xLm11bHRpY2FzdC5jYWxsKHRoaXMsIG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpKTtcbn1cbmV4cG9ydHMucHVibGlzaCA9IHB1Ymxpc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBwdWJsaXNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wdWJsaXNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaCA9IHB1Ymxpc2hfMS5wdWJsaXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4vU3ViamVjdCcpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbi8qKlxuICogQGNsYXNzIEJlaGF2aW9yU3ViamVjdDxUPlxuICovXG52YXIgQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmVoYXZpb3JTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJlaGF2aW9yU3ViamVjdChfdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uICYmICFzdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy50aHJvd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlID0gdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEJlaGF2aW9yU3ViamVjdDtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuQmVoYXZpb3JTdWJqZWN0ID0gQmVoYXZpb3JTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmVoYXZpb3JTdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEJlaGF2aW9yU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vQmVoYXZpb3JTdWJqZWN0Jyk7XG52YXIgbXVsdGljYXN0XzEgPSByZXF1aXJlKCcuL211bHRpY2FzdCcpO1xuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaEJlaGF2aW9yXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoQmVoYXZpb3IodmFsdWUpIHtcbiAgICByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgbmV3IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdCh2YWx1ZSkpO1xufVxuZXhwb3J0cy5wdWJsaXNoQmVoYXZpb3IgPSBwdWJsaXNoQmVoYXZpb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoQmVoYXZpb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHB1Ymxpc2hCZWhhdmlvcl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaEJlaGF2aW9yID0gcHVibGlzaEJlaGF2aW9yXzEucHVibGlzaEJlaGF2aW9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaEJlaGF2aW9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFJlcGxheVN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1JlcGxheVN1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIEBwYXJhbSBidWZmZXJTaXplXG4gKiBAcGFyYW0gd2luZG93VGltZVxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7Q29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBwdWJsaXNoUmVwbGF5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVwbGF5KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikge1xuICAgIGlmIChidWZmZXJTaXplID09PSB2b2lkIDApIHsgYnVmZmVyU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIGlmICh3aW5kb3dUaW1lID09PSB2b2lkIDApIHsgd2luZG93VGltZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgUmVwbGF5U3ViamVjdF8xLlJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnB1Ymxpc2hSZXBsYXkgPSBwdWJsaXNoUmVwbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaFJlcGxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcHVibGlzaFJlcGxheV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcHVibGlzaFJlcGxheScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnB1Ymxpc2hSZXBsYXkgPSBwdWJsaXNoUmVwbGF5XzEucHVibGlzaFJlcGxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hSZXBsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXN5bmNTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9Bc3luY1N1YmplY3QnKTtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG4vKipcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaExhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hMYXN0KCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCkpO1xufVxuZXhwb3J0cy5wdWJsaXNoTGFzdCA9IHB1Ymxpc2hMYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaExhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHB1Ymxpc2hMYXN0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9wdWJsaXNoTGFzdCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnB1Ymxpc2hMYXN0ID0gcHVibGlzaExhc3RfMS5wdWJsaXNoTGFzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hMYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByYWNlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9yYWNlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmFjZSA9IHJhY2VfMS5yYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmVkdWNlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9yZWR1Y2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5yZWR1Y2UgPSByZWR1Y2VfMS5yZWR1Y2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCByZXBlYXRzIHRoZSBzdHJlYW0gb2YgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgbW9zdCBjb3VudCB0aW1lcyxcbiAqIG9uIGEgcGFydGljdWxhciBTY2hlZHVsZXIuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXBlYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIHRoZSBTY2hlZHVsZXIgdG8gZW1pdCB0aGUgaXRlbXMgb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpdGVtcyBhcmUgcmVwZWF0ZWQsIGEgY291bnQgb2YgMCB3aWxsIHlpZWxkXG4gKiBhbiBlbXB0eSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IHJlcGVhdHMgdGhlIHN0cmVhbSBvZiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhdCBtb3N0XG4gKiBjb3VudCB0aW1lcy5cbiAqIEBtZXRob2QgcmVwZWF0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHZvaWQgMCkgeyBjb3VudCA9IC0xOyB9XG4gICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZXBlYXRPcGVyYXRvcigtMSwgdGhpcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVwZWF0T3BlcmF0b3IoY291bnQgLSAxLCB0aGlzKSk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQ7XG52YXIgUmVwZWF0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGVhdE9wZXJhdG9yKGNvdW50LCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmVwZWF0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXBlYXRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY291bnQsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwZWF0T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZXBlYXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZWF0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBlYXRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb3VudCwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmVwZWF0U3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIHNvdXJjZSA9IF9hLnNvdXJjZSwgY291bnQgPSBfYS5jb3VudDtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJlcGVhdF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmVwZWF0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVwZWF0ID0gcmVwZWF0XzEucmVwZWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgc291cmNlIG9ic2VydmFibGUgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGEgYGNvbXBsZXRlYC5cbiAqIEEgYGNvbXBsZXRlYCB3aWxsIGNhdXNlIHRoZSBlbWlzc2lvbiBvZiB0aGUgVGhyb3dhYmxlIHRoYXQgY2F1c2UgdGhlIGNvbXBsZXRlIHRvIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb21cbiAqIG5vdGlmaWNhdGlvbkhhbmRsZXIuIElmIHRoYXQgT2JzZXJ2YWJsZSBjYWxscyBvbkNvbXBsZXRlIG9yIGBjb21wbGV0ZWAgdGhlbiByZXRyeSB3aWxsIGNhbGwgYGNvbXBsZXRlYCBvciBgZXJyb3JgXG4gKiBvbiB0aGUgY2hpbGQgc3Vic2NyaXB0aW9uLiBPdGhlcndpc2UsIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSwgb24gYSBwYXJ0aWN1bGFyXG4gKiBTY2hlZHVsZXIuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXBlYXRXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7bm90aWZpY2F0aW9uSGFuZGxlcn0gcmVjZWl2ZXMgYW4gT2JzZXJ2YWJsZSBvZiBub3RpZmljYXRpb25zIHdpdGggd2hpY2ggYSB1c2VyIGNhbiBgY29tcGxldGVgIG9yIGBlcnJvcmAsXG4gKiBhYm9ydGluZyB0aGUgcmV0cnkuXG4gKiBAcGFyYW0ge3NjaGVkdWxlcn0gdGhlIFNjaGVkdWxlciBvbiB3aGljaCB0byBzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG1vZGlmaWVkIHdpdGggcmV0cnkgbG9naWMuXG4gKiBAbWV0aG9kIHJlcGVhdFdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJlcGVhdFdoZW4obm90aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZXBlYXRXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHRoaXMpKTtcbn1cbmV4cG9ydHMucmVwZWF0V2hlbiA9IHJlcGVhdFdoZW47XG52YXIgUmVwZWF0V2hlbk9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXBlYXRXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXBlYXRXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXBlYXRXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyLCB0aGlzLnNvdXJjZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcGVhdFdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJlcGVhdFdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZWF0V2hlblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZWF0V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXBlYXRXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBub3RpZmljYXRpb25zID0gdGhpcy5ub3RpZmljYXRpb25zO1xuICAgICAgICAgICAgdmFyIHJldHJpZXMgPSB0aGlzLnJldHJpZXM7XG4gICAgICAgICAgICB2YXIgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmICghcmV0cmllcykge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgICAgICByZXRyaWVzID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLm5vdGlmaWVyKShub3RpZmljYXRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0cmllcyA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcztcbiAgICAgICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgICAgICBub3RpZmljYXRpb25zLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbm90aWZpY2F0aW9ucyA9IF9hLm5vdGlmaWNhdGlvbnMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAobm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIH07XG4gICAgUmVwZWF0V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbm90aWZpY2F0aW9ucyA9IF9hLm5vdGlmaWNhdGlvbnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwZWF0V2hlblN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0V2hlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgcmVwZWF0V2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmVwZWF0V2hlbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnJlcGVhdFdoZW4gPSByZXBlYXRXaGVuXzEucmVwZWF0V2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGVhdFdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXN1YnNjcmliaW5nIHRvIGl0IGlmIGl0IGNhbGxzIGBlcnJvcmAgYW5kIHRoZVxuICogcHJlZGljYXRlIHJldHVybnMgdHJ1ZSBmb3IgdGhhdCBzcGVjaWZpYyBleGNlcHRpb24gYW5kIHJldHJ5IGNvdW50LlxuICogSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGZvciBhIG1heGltdW0gb2ZcbiAqIGNvdW50IHJlc3Vic2NyaXB0aW9ucyAoZ2l2ZW4gYXMgYSBudW1iZXIgcGFyYW1ldGVyKSByYXRoZXIgdGhhbiBwcm9wYWdhdGluZyB0aGUgYGVycm9yYCBjYWxsLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQW55IGFuZCBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSwgZXZlbiB0aG9zZSBlbWl0dGVkXG4gKiBkdXJpbmcgZmFpbGVkIHN1YnNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCBpZiBhbiBPYnNlcnZhYmxlIGZhaWxzIGF0IGZpcnN0IGJ1dCBlbWl0cyBbMSwgMl0gdGhlbiBzdWNjZWVkcyB0aGUgc2Vjb25kXG4gKiB0aW1lIGFuZCBlbWl0czogWzEsIDIsIDMsIDQsIDVdIHRoZW4gdGhlIGNvbXBsZXRlIHN0cmVhbSBvZiBlbWlzc2lvbnMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIHdvdWxkIGJlOiBbMSwgMiwgMSwgMiwgMywgNCwgNSwgYGNvbXBsZXRlYF0uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIGJlZm9yZSBmYWlsaW5nLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG1vZGlmaWVkIHdpdGggdGhlIHJldHJ5IGxvZ2ljLlxuICogQG1ldGhvZCByZXRyeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcmV0cnkoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHZvaWQgMCkgeyBjb3VudCA9IC0xOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmV0cnlPcGVyYXRvcihjb3VudCwgdGhpcykpO1xufVxuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xudmFyIFJldHJ5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHJ5T3BlcmF0b3IoY291bnQsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmV0cnlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY291bnQsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJldHJ5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvdW50LCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBzb3VyY2UgPSBfYS5zb3VyY2UsIGNvdW50ID0gX2EuY291bnQ7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJldHJ5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByZXRyeV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmV0cnknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5yZXRyeSA9IHJldHJ5XzEucmV0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLlxuICogQW4gYGVycm9yYCB3aWxsIGNhdXNlIHRoZSBlbWlzc2lvbiBvZiB0aGUgVGhyb3dhYmxlIHRoYXQgY2F1c2UgdGhlIGVycm9yIHRvIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb21cbiAqIG5vdGlmaWNhdGlvbkhhbmRsZXIuIElmIHRoYXQgT2JzZXJ2YWJsZSBjYWxscyBvbkNvbXBsZXRlIG9yIGBlcnJvcmAgdGhlbiByZXRyeSB3aWxsIGNhbGwgYGNvbXBsZXRlYCBvciBgZXJyb3JgXG4gKiBvbiB0aGUgY2hpbGQgc3Vic2NyaXB0aW9uLiBPdGhlcndpc2UsIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSwgb24gYSBwYXJ0aWN1bGFyXG4gKiBTY2hlZHVsZXIuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXRyeVdoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtub3RpZmljYXRpb25IYW5kbGVyfSByZWNlaXZlcyBhbiBPYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgd2l0aCB3aGljaCBhIHVzZXIgY2FuIGBjb21wbGV0ZWAgb3IgYGVycm9yYCxcbiAqIGFib3J0aW5nIHRoZSByZXRyeS5cbiAqIEBwYXJhbSB7c2NoZWR1bGVyfSB0aGUgU2NoZWR1bGVyIG9uIHdoaWNoIHRvIHN1YnNjcmliZSB0byB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSB0aGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCByZXRyeSBsb2dpYy5cbiAqIEBtZXRob2QgcmV0cnlXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXRyeVdoZW4obm90aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZXRyeVdoZW5PcGVyYXRvcihub3RpZmllciwgdGhpcykpO1xufVxuZXhwb3J0cy5yZXRyeVdoZW4gPSByZXRyeVdoZW47XG52YXIgUmV0cnlXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXRyeVdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZXRyeVdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0cnlXaGVuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllciwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIHZhciByZXRyaWVzID0gdGhpcy5yZXRyaWVzO1xuICAgICAgICAgICAgdmFyIHJldHJpZXNTdWJzY3JpcHRpb24gPSB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAoIXJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgICAgICByZXRyaWVzID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLm5vdGlmaWVyKShlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmV0cmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgZXJyb3JzLm5leHQoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeVdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJldHJ5V2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmV0cnlXaGVuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmV0cnlXaGVuID0gcmV0cnlXaGVuXzEucmV0cnlXaGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlXaGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZW5ldmVyXG4gKiBhbm90aGVyIE9ic2VydmFibGUsIHRoZSBgbm90aWZpZXJgLCBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBzYW1wbGVUaW1lfSwgYnV0IHNhbXBsZXMgd2hlbmV2ZXJcbiAqIHRoZSBgbm90aWZpZXJgIE9ic2VydmFibGUgZW1pdHMgc29tZXRoaW5nLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NhbXBsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBXaGVuZXZlciB0aGUgYG5vdGlmaWVyYCBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUgb3IgY29tcGxldGVzLCBgc2FtcGxlYFxuICogbG9va3MgYXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBlbWl0cyB3aGljaGV2ZXIgdmFsdWUgaXQgaGFzIG1vc3QgcmVjZW50bHlcbiAqIGVtaXR0ZWQgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLCB1bmxlc3MgdGhlIHNvdXJjZSBoYXMgbm90IGVtaXR0ZWRcbiAqIGFueXRoaW5nIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZy4gVGhlIGBub3RpZmllcmAgaXMgc3Vic2NyaWJlZCB0byBhcyBzb29uXG4gKiBhcyB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgc2FtcGxlIHRoZSBtb3N0IHJlY2VudCBcInNlY29uZHNcIiB0aW1lcjwvY2FwdGlvbj5cbiAqIHZhciBzZWNvbmRzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gc2Vjb25kcy5zYW1wbGUoY2xpY2tzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8YW55Pn0gbm90aWZpZXIgVGhlIE9ic2VydmFibGUgdG8gdXNlIGZvciBzYW1wbGluZyB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIHNhbXBsaW5nIHRoZVxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZW5ldmVyIHRoZSBub3RpZmllciBPYnNlcnZhYmxlXG4gKiBlbWl0cyB2YWx1ZSBvciBjb21wbGV0ZXMuXG4gKiBAbWV0aG9kIHNhbXBsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2FtcGxlT3BlcmF0b3Iobm90aWZpZXIpKTtcbn1cbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlO1xudmFyIFNhbXBsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYW1wbGVPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFNhbXBsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgc2FtcGxlU3Vic2NyaWJlciA9IG5ldyBTYW1wbGVTdWJzY3JpYmVyKHN1YnNjcmliZXIpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShzYW1wbGVTdWJzY3JpYmVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHNhbXBsZVN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhbXBsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYW1wbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhbXBsZVN1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgfTtcbiAgICBTYW1wbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB9O1xuICAgIFNhbXBsZVN1YnNjcmliZXIucHJvdG90eXBlLmVtaXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzYW1wbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NhbXBsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNhbXBsZSA9IHNhbXBsZV8xLnNhbXBsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbXBsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIHRoZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aGluXG4gKiBwZXJpb2RpYyB0aW1lIGludGVydmFscy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2FtcGxlcyB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgcGVyaW9kaWMgdGltZVxuICogaW50ZXJ2YWxzLCBlbWl0dGluZyB3aGF0IGl0IHNhbXBsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2FtcGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc2FtcGxlVGltZWAgcGVyaW9kaWNhbGx5IGxvb2tzIGF0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgZW1pdHMgd2hpY2hldmVyXG4gKiB2YWx1ZSBpdCBoYXMgbW9zdCByZWNlbnRseSBlbWl0dGVkIHNpbmNlIHRoZSBwcmV2aW91cyBzYW1wbGluZywgdW5sZXNzIHRoZVxuICogc291cmNlIGhhcyBub3QgZW1pdHRlZCBhbnl0aGluZyBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcuIFRoZSBzYW1wbGluZ1xuICogaGFwcGVucyBwZXJpb2RpY2FsbHkgaW4gdGltZSBldmVyeSBgcGVyaW9kYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXRcbiAqIGRlZmluZWQgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgIGFyZ3VtZW50KS4gVGhlIHNhbXBsaW5nIHN0YXJ0cyBhcyBzb29uIGFzXG4gKiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSBzZWNvbmQsIGVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGF0IG1vc3Qgb25jZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnNhbXBsZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJpb2QgVGhlIHNhbXBsaW5nIHBlcmlvZCBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZVxuICogdGltZSB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHNhbXBsaW5nLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIHNhbXBsaW5nIHRoZVxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IHRoZSBzcGVjaWZpZWQgdGltZSBpbnRlcnZhbC5cbiAqIEBtZXRob2Qgc2FtcGxlVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlVGltZShwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2FtcGxlVGltZU9wZXJhdG9yKHBlcmlvZCwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnNhbXBsZVRpbWUgPSBzYW1wbGVUaW1lO1xudmFyIFNhbXBsZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FtcGxlVGltZU9wZXJhdG9yKHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMucGVyaW9kID0gcGVyaW9kO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgU2FtcGxlVGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2FtcGxlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wZXJpb2QsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FtcGxlVGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2FtcGxlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYW1wbGVUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYW1wbGVUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IHBlcmlvZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTm90aWZpY2F0aW9uLCBwZXJpb2QsIHsgc3Vic2NyaWJlcjogdGhpcywgcGVyaW9kOiBwZXJpb2QgfSkpO1xuICAgIH1cbiAgICBTYW1wbGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTYW1wbGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmxhc3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTm90aWZpY2F0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBwZXJpb2QgPSBzdGF0ZS5wZXJpb2Q7XG4gICAgc3Vic2NyaWJlci5ub3RpZnlOZXh0KCk7XG4gICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbXBsZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNhbXBsZVRpbWVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NhbXBsZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGVUaW1lID0gc2FtcGxlVGltZV8xLnNhbXBsZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGVUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciB0aGUgc291cmNlIE9ic2VydmFibGUsIGFuZCByZXR1cm5zIGVhY2hcbiAqIGludGVybWVkaWF0ZSByZXN1bHQsIHdpdGggYW4gb3B0aW9uYWwgc2VlZCB2YWx1ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayByZWR1Y2V9LCBidXQgZW1pdHMgdGhlIGN1cnJlbnRcbiAqIGFjY3VtdWxhdGlvbiB3aGVuZXZlciB0aGUgc291cmNlIGVtaXRzIGEgdmFsdWUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2Nhbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBDb21iaW5lcyB0b2dldGhlciBhbGwgdmFsdWVzIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSwgdXNpbmcgYW4gYWNjdW11bGF0b3JcbiAqIGZ1bmN0aW9uIHRoYXQga25vd3MgaG93IHRvIGpvaW4gYSBuZXcgc291cmNlIHZhbHVlIGludG8gdGhlIGFjY3VtdWxhdGlvbiBmcm9tXG4gKiB0aGUgcGFzdC4gSXMgc2ltaWxhciB0byB7QGxpbmsgcmVkdWNlfSwgYnV0IGVtaXRzIHRoZSBpbnRlcm1lZGlhdGVcbiAqIGFjY3VtdWxhdGlvbnMuXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgYXBwbGllcyBhIHNwZWNpZmllZCBgYWNjdW11bGF0b3JgIGZ1bmN0aW9uIHRvIGVhY2hcbiAqIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgYHNlZWRgIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlblxuICogdGhhdCB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBhY2N1bXVsYXRvci4gSWYgbm8gc2VlZFxuICogdmFsdWUgaXMgc3BlY2lmaWVkLCB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgc291cmNlIGlzIHVzZWQgYXMgdGhlIHNlZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnQgdGhlIG51bWJlciBvZiBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9uZXMgPSBjbGlja3MubWFwVG8oMSk7XG4gKiB2YXIgc2VlZCA9IDA7XG4gKiB2YXIgY291bnQgPSBvbmVzLnNjYW4oKGFjYywgb25lKSA9PiBhY2MgKyBvbmUsIHNlZWQpO1xuICogY291bnQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGV4cGFuZH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHJlZHVjZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFjYzogUiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBhY2N1bXVsYXRvclxuICogVGhlIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIGNhbGxlZCBvbiBlYWNoIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7VHxSfSBbc2VlZF0gVGhlIGluaXRpYWwgYWNjdW11bGF0aW9uIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gb2JzZXJ2YWJsZSBvZiB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzLlxuICogQG1ldGhvZCBzY2FuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzY2FuKGFjY3VtdWxhdG9yLCBzZWVkKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZTtcbiAgICAvLyBwcm92aWRpbmcgYSBzZWVkIG9mIGB1bmRlZmluZWRgICpzaG91bGQqIGJlIHZhbGlkIGFuZCB0cmlnZ2VyXG4gICAgLy8gaGFzU2VlZCEgc28gZG9uJ3QgdXNlIGBzZWVkICE9PSB1bmRlZmluZWRgIGNoZWNrcyFcbiAgICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGhhdmUgdG8gY2hlY2sgaXQgaGVyZSBhdCB0aGUgb3JpZ2luYWwgY2FsbCBzaXRlXG4gICAgLy8gb3RoZXJ3aXNlIGluc2lkZSBPcGVyYXRvci9TdWJzY3JpYmVyIHdlIHdvbid0IGtub3cgaWYgYHVuZGVmaW5lZGBcbiAgICAvLyBtZWFucyB0aGV5IGRpZG4ndCBwcm92aWRlIGFueXRoaW5nIG9yIGlmIHRoZXkgbGl0ZXJhbGx5IHByb3ZpZGVkIGB1bmRlZmluZWRgXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICBoYXNTZWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSk7XG59XG5leHBvcnRzLnNjYW4gPSBzY2FuO1xudmFyIFNjYW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSB7XG4gICAgICAgIGlmIChoYXNTZWVkID09PSB2b2lkIDApIHsgaGFzU2VlZCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICB9XG4gICAgU2Nhbk9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2NhblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hY2N1bXVsYXRvciwgdGhpcy5zZWVkLCB0aGlzLmhhc1NlZWQpKTtcbiAgICB9O1xuICAgIHJldHVybiBTY2FuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTY2FuU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhY2N1bXVsYXRvciwgX3NlZWQsIGhhc1NlZWQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuX3NlZWQgPSBfc2VlZDtcbiAgICAgICAgdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUsIFwic2VlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1NlZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2VlZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYWNjdW11bGF0b3IodGhpcy5zZWVkLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZWQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2Nhbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2NhbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNjYW4gPSBzY2FuXzEuc2Nhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xuLyoqXG4gKiBDb21wYXJlcyBhbGwgdmFsdWVzIG9mIHR3byBvYnNlcnZhYmxlcyBpbiBzZXF1ZW5jZSB1c2luZyBhbiBvcHRpb25hbCBjb21wYXJvciBmdW5jdGlvblxuICogYW5kIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiBhIHNpbmdsZSBib29sZWFuIHZhbHVlIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHNlcXVlbmNlc1xuICogYXJlIGVxdWFsLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DaGVja3MgdG8gc2VlIG9mIGFsbCB2YWx1ZXMgZW1pdHRlZCBieSBib3RoIG9ic2VydmFibGVzIGFyZSBlcXVhbCwgaW4gb3JkZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2VxdWVuY2VFcXVhbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc2VxdWVuY2VFcXVhbGAgc3Vic2NyaWJlcyB0byB0d28gb2JzZXJ2YWJsZXMgYW5kIGJ1ZmZlcnMgaW5jb21pbmcgdmFsdWVzIGZyb20gZWFjaCBvYnNlcnZhYmxlLiBXaGVuZXZlciBlaXRoZXJcbiAqIG9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgdGhlIHZhbHVlIGlzIGJ1ZmZlcmVkIGFuZCB0aGUgYnVmZmVycyBhcmUgc2hpZnRlZCBhbmQgY29tcGFyZWQgZnJvbSB0aGUgYm90dG9tXG4gKiB1cDsgSWYgYW55IHZhbHVlIHBhaXIgZG9lc24ndCBtYXRjaCwgdGhlIHJldHVybmVkIG9ic2VydmFibGUgd2lsbCBlbWl0IGBmYWxzZWAgYW5kIGNvbXBsZXRlLiBJZiBvbmUgb2YgdGhlXG4gKiBvYnNlcnZhYmxlcyBjb21wbGV0ZXMsIHRoZSBvcGVyYXRvciB3aWxsIHdhaXQgZm9yIHRoZSBvdGhlciBvYnNlcnZhYmxlIHRvIGNvbXBsZXRlOyBJZiB0aGUgb3RoZXJcbiAqIG9ic2VydmFibGUgZW1pdHMgYmVmb3JlIGNvbXBsZXRpbmcsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgZW1pdCBgZmFsc2VgIGFuZCBjb21wbGV0ZS4gSWYgb25lIG9ic2VydmFibGUgbmV2ZXJcbiAqIGNvbXBsZXRlcyBvciBlbWl0cyBhZnRlciB0aGUgb3RoZXIgY29tcGxldHMsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgbmV2ZXIgY29tcGxldGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+ZmlndXJlIG91dCBpZiB0aGUgS29uYW1pIGNvZGUgbWF0Y2hlczwvY2FwdGlvbj5cbiAqIHZhciBjb2RlID0gUnguT2JzZXJ2YWJsZS5mcm9tKFtcbiAqICBcIkFycm93VXBcIixcbiAqICBcIkFycm93VXBcIixcbiAqICBcIkFycm93RG93blwiLFxuICogIFwiQXJyb3dEb3duXCIsXG4gKiAgXCJBcnJvd0xlZnRcIixcbiAqICBcIkFycm93UmlnaHRcIixcbiAqICBcIkFycm93TGVmdFwiLFxuICogIFwiQXJyb3dSaWdodFwiLFxuICogIFwiS2V5QlwiLFxuICogIFwiS2V5QVwiLFxuICogIFwiRW50ZXJcIiAvLyBubyBzdGFydCBrZXksIGNsZWFybHkuXG4gKiBdKTtcbiAqXG4gKiB2YXIga2V5cyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5dXAnKVxuICogIC5tYXAoZSA9PiBlLmNvZGUpO1xuICogdmFyIG1hdGNoZXMgPSBrZXlzLmJ1ZmZlckNvdW50KDExLCAxKVxuICogIC5tZXJnZU1hcChcbiAqICAgIGxhc3QxMSA9PlxuICogICAgICBSeC5PYnNlcnZhYmxlLmZyb20obGFzdDExKVxuICogICAgICAgIC5zZXF1ZW5jZUVxdWFsKGNvZGUpXG4gKiAgICk7XG4gKiBtYXRjaGVzLnN1YnNjcmliZShtYXRjaGVkID0+IGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsIGNoZWF0IGF0IENvbnRyYT8gJywgbWF0Y2hlZCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKiBAc2VlIHtAbGluayB6aXB9XG4gKiBAc2VlIHtAbGluayB3aXRoTGF0ZXN0RnJvbX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IGNvbXBhcmVUbyB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZSB0byBjb21wYXJlIHRoZSBzb3VyY2Ugc2VxdWVuY2UgdG8uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyb3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGNvbXBhcmUgZWFjaCB2YWx1ZSBwYWlyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIGEgc2luZ2xlIGJvb2xlYW4gdmFsdWUgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90XG4gKiB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgYm90aCBvYnNlcnZhYmxlcyB3ZXJlIGVxdWFsIGluIHNlcXVlbmNlXG4gKiBAbWV0aG9kIHNlcXVlbmNlRXF1YWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNlcXVlbmNlRXF1YWwoY29tcGFyZVRvLCBjb21wYXJvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNlcXVlbmNlRXF1YWxPcGVyYXRvcihjb21wYXJlVG8sIGNvbXBhcm9yKSk7XG59XG5leHBvcnRzLnNlcXVlbmNlRXF1YWwgPSBzZXF1ZW5jZUVxdWFsO1xudmFyIFNlcXVlbmNlRXF1YWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2VFcXVhbE9wZXJhdG9yKGNvbXBhcmVUbywgY29tcGFyb3IpIHtcbiAgICAgICAgdGhpcy5jb21wYXJlVG8gPSBjb21wYXJlVG87XG4gICAgICAgIHRoaXMuY29tcGFyb3IgPSBjb21wYXJvcjtcbiAgICB9XG4gICAgU2VxdWVuY2VFcXVhbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb21wYXJlVG8sIHRoaXMuY29tcGFyb3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXF1ZW5jZUVxdWFsT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5TZXF1ZW5jZUVxdWFsT3BlcmF0b3IgPSBTZXF1ZW5jZUVxdWFsT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbXBhcmVUbywgY29tcGFyb3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbXBhcmVUbyA9IGNvbXBhcmVUbztcbiAgICAgICAgdGhpcy5jb21wYXJvciA9IGNvbXBhcm9yO1xuICAgICAgICB0aGlzLl9hID0gW107XG4gICAgICAgIHRoaXMuX2IgPSBbXTtcbiAgICAgICAgdGhpcy5fb25lQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQoY29tcGFyZVRvLnN1YnNjcmliZShuZXcgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIHRoaXMpKSk7XG4gICAgfVxuICAgIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fb25lQ29tcGxldGUgJiYgdGhpcy5fYi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb25lQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLl9hLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9iLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbmVDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5jaGVja1ZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9jID0gdGhpcywgX2EgPSBfYy5fYSwgX2IgPSBfYy5fYiwgY29tcGFyb3IgPSBfYy5jb21wYXJvcjtcbiAgICAgICAgd2hpbGUgKF9hLmxlbmd0aCA+IDAgJiYgX2IubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGEgPSBfYS5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGIgPSBfYi5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGFyZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29tcGFyb3IpIHtcbiAgICAgICAgICAgICAgICBhcmVFcXVhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goY29tcGFyb3IpKGEsIGIpO1xuICAgICAgICAgICAgICAgIGlmIChhcmVFcXVhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJlRXF1YWwgPSBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcmVFcXVhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIucHJvdG90eXBlLm5leHRCID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmVDb21wbGV0ZSAmJiB0aGlzLl9hLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2IucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU2VxdWVuY2VFcXVhbFN1YnNjcmliZXIgPSBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlcjtcbnZhciBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwYXJlbnQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5leHRCKHZhbHVlKTtcbiAgICB9O1xuICAgIFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmVudC5fY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXF1ZW5jZUVxdWFsQ29tcGFyZVRvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbmNlRXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNlcXVlbmNlRXF1YWxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NlcXVlbmNlRXF1YWwnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zZXF1ZW5jZUVxdWFsID0gc2VxdWVuY2VFcXVhbF8xLnNlcXVlbmNlRXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZW5jZUVxdWFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG5mdW5jdGlvbiBzaGFyZVN1YmplY3RGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5ldyBPYnNlcnZhYmxlIHRoYXQgbXVsdGljYXN0cyAoc2hhcmVzKSB0aGUgb3JpZ2luYWwgT2JzZXJ2YWJsZS4gQXMgbG9uZyBhcyB0aGVyZSBpcyBhdCBsZWFzdCBvbmVcbiAqIFN1YnNjcmliZXIgdGhpcyBPYnNlcnZhYmxlIHdpbGwgYmUgc3Vic2NyaWJlZCBhbmQgZW1pdHRpbmcgZGF0YS4gV2hlbiBhbGwgc3Vic2NyaWJlcnMgaGF2ZSB1bnN1YnNjcmliZWQgaXQgd2lsbFxuICogdW5zdWJzY3JpYmUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuIEJlY2F1c2UgdGhlIE9ic2VydmFibGUgaXMgbXVsdGljYXN0aW5nIGl0IG1ha2VzIHRoZSBzdHJlYW0gYGhvdGAuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIGZvciAucHVibGlzaCgpLnJlZkNvdW50KCkuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zaGFyZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBhbiBPYnNlcnZhYmxlIHRoYXQgdXBvbiBjb25uZWN0aW9uIGNhdXNlcyB0aGUgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBpdGVtcyB0byBpdHMgT2JzZXJ2ZXJzXG4gKiBAbWV0aG9kIHNoYXJlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzaGFyZSgpIHtcbiAgICByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0LmNhbGwodGhpcywgc2hhcmVTdWJqZWN0RmFjdG9yeSkucmVmQ291bnQoKTtcbn1cbmV4cG9ydHMuc2hhcmUgPSBzaGFyZTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzaGFyZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2hhcmUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zaGFyZSA9IHNoYXJlXzEuc2hhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBFbXB0eUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0VtcHR5RXJyb3InKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHNpbmdsZSBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgbWF0Y2hlcyBhIHNwZWNpZmllZFxuICogcHJlZGljYXRlLCBpZiB0aGF0IE9ic2VydmFibGUgZW1pdHMgb25lIHN1Y2ggaXRlbS4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIG1vcmUgdGhhbiBvbmUgc3VjaCBpdGVtIG9yIG5vXG4gKiBzdWNoIGl0ZW1zLCBub3RpZnkgb2YgYW4gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIG9yIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gcmVzcGVjdGl2ZWx5LlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2luZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzaW5nbGUgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBwcmVkaWNhdGUuXG4gLlxuICogQG1ldGhvZCBzaW5nbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTaW5nbGVPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXMpKTtcbn1cbmV4cG9ydHMuc2luZ2xlID0gc2luZ2xlO1xudmFyIFNpbmdsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW5nbGVPcGVyYXRvcihwcmVkaWNhdGUsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIFNpbmdsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2luZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNpbmdsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW5nbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbmdsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnNlZW5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2luZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuYXBwbHlTaW5nbGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZWVuVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoJ1NlcXVlbmNlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWVuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaW5nbGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5wcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbmdsZVN1YnNjcmliZXIucHJvdG90eXBlLnRyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW5nbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLnNlZW5WYWx1ZSA/IHRoaXMuc2luZ2xlVmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTaW5nbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2luZ2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzaW5nbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NpbmdsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNpbmdsZSA9IHNpbmdsZV8xLnNpbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbmdsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgYG5gIGl0ZW1zIGVtaXR0ZWQgYnkgYW4gT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NraXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZSBgbmAgb2YgdGltZXMsIGl0ZW1zIGVtaXR0ZWQgYnkgc291cmNlIE9ic2VydmFibGUgc2hvdWxkIGJlIHNraXBwZWQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIEBtZXRob2Qgc2tpcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2tpcCh0b3RhbCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNraXBPcGVyYXRvcih0b3RhbCkpO1xufVxuZXhwb3J0cy5za2lwID0gc2tpcDtcbnZhciBTa2lwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNraXBPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgfVxuICAgIFNraXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBTa2lwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTa2lwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNraXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFNraXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICgrK3RoaXMuY291bnQgPiB0aGlzLnRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoeCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNraXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NraXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwID0gc2tpcF8xLnNraXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBza2lwcyBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCBhIHNlY29uZCBPYnNlcnZhYmxlIGVtaXRzIGFuIGl0ZW0uXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSB0aGUgc2Vjb25kIE9ic2VydmFibGUgdGhhdCBoYXMgdG8gZW1pdCBhbiBpdGVtIGJlZm9yZSB0aGUgc291cmNlIE9ic2VydmFibGUncyBlbGVtZW50cyBiZWdpbiB0b1xuICogYmUgbWlycm9yZWQgYnkgdGhlIHJlc3VsdGluZyBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gYW4gT2JzZXJ2YWJsZSB0aGF0IHNraXBzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIHRoZSBzZWNvbmQgT2JzZXJ2YWJsZSBlbWl0c1xuICogYW4gaXRlbSwgdGhlbiBlbWl0cyB0aGUgcmVtYWluaW5nIGl0ZW1zLlxuICogQG1ldGhvZCBza2lwVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXBVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFNraXBVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnNraXBVbnRpbCA9IHNraXBVbnRpbDtcbnZhciBTa2lwVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBTa2lwVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBVbnRpbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBVbnRpbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFVudGlsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBVbnRpbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFVudGlsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbm5lclN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBTa2lwVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fbmV4dC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lubmVyU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNraXBVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzSW5uZXJTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2tpcFVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwVW50aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNraXBVbnRpbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2tpcFVudGlsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2tpcFVudGlsID0gc2tpcFVudGlsXzEuc2tpcFVudGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFVudGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBza2lwcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXMgbG9uZyBhcyBhIHNwZWNpZmllZCBjb25kaXRpb24gaG9sZHNcbiAqIHRydWUsIGJ1dCBlbWl0cyBhbGwgZnVydGhlciBzb3VyY2UgaXRlbXMgYXMgc29vbiBhcyB0aGUgY29uZGl0aW9uIGJlY29tZXMgZmFsc2UuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwV2hpbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIC0gYSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggaXRlbSBlbWl0dGVkIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gYW4gT2JzZXJ2YWJsZSB0aGF0IGJlZ2lucyBlbWl0dGluZyBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuIHRoZVxuICogc3BlY2lmaWVkIHByZWRpY2F0ZSBiZWNvbWVzIGZhbHNlLlxuICogQG1ldGhvZCBza2lwV2hpbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTa2lwV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpKTtcbn1cbmV4cG9ydHMuc2tpcFdoaWxlID0gc2tpcFdoaWxlO1xudmFyIFNraXBXaGlsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIFNraXBXaGlsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNraXBXaGlsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2tpcFdoaWxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU2tpcFdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2tpcHBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5Q2FsbFByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNraXBwaW5nKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2tpcFdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5Q2FsbFByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyspO1xuICAgICAgICAgICAgdGhpcy5za2lwcGluZyA9IEJvb2xlYW4ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTa2lwV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFdoaWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBza2lwV2hpbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NraXBXaGlsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNraXBXaGlsZSA9IHNraXBXaGlsZV8xLnNraXBXaGlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNraXBXaGlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgU2NhbGFyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZSgnLi9jb25jYXQnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiBhIHNwZWNpZmllZCBJdGVyYWJsZSBiZWZvcmUgaXQgYmVnaW5zIHRvIGVtaXQgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3RhcnRXaXRoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7VmFsdWVzfSBhbiBJdGVyYWJsZSB0aGF0IGNvbnRhaW5zIHRoZSBpdGVtcyB5b3Ugd2FudCB0aGUgbW9kaWZpZWQgT2JzZXJ2YWJsZSB0byBlbWl0IGZpcnN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICBhcnJheS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3RhcnRXaXRoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zdGFydFdpdGgnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdGFydFdpdGggPSBzdGFydFdpdGhfMS5zdGFydFdpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFydFdpdGguanMubWFwIiwiLyoqXG5Tb21lIGNyZWRpdCBmb3IgdGhpcyBoZWxwZXIgZ29lcyB0byBodHRwOi8vZ2l0aHViLmNvbS9ZdXp1SlMvc2V0SW1tZWRpYXRlXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG52YXIgSW1tZWRpYXRlRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW1tZWRpYXRlRGVmaW5pdGlvbihyb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIGlmIChyb290LnNldEltbWVkaWF0ZSAmJiB0eXBlb2Ygcm9vdC5zZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gcm9vdC5zZXRJbW1lZGlhdGUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbW1lZGlhdGUgPSByb290LmNsZWFySW1tZWRpYXRlLmJpbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRIYW5kbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy50YXNrc0J5SGFuZGxlID0ge307XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuVXNlUHJvY2Vzc05leHRUaWNrKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVByb2Nlc3NOZXh0VGlja1NldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVQb3N0TWVzc2FnZVNldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYW5Vc2VNZXNzYWdlQ2hhbm5lbCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlTWVzc2FnZUNoYW5uZWxTZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuVXNlUmVhZHlTdGF0ZUNoYW5nZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVJlYWR5U3RhdGVDaGFuZ2VTZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVTZXRUaW1lb3V0U2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2kgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2xlYXJJbW1lZGlhdGUuaW5zdGFuY2UudGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNpLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbW1lZGlhdGUgPSBjaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5pZGVudGlmeSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY2FuVXNlUHJvY2Vzc05leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGVudGlmeSh0aGlzLnJvb3QucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNhblVzZU1lc3NhZ2VDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnJvb3QuTWVzc2FnZUNoYW5uZWwpO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY2FuVXNlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5yb290LmRvY3VtZW50O1xuICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSk7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jYW5Vc2VQb3N0TWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYHJvb3QucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAocm9vdC5wb3N0TWVzc2FnZSAmJiAhcm9vdC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91c18xID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSByb290Lm9ubWVzc2FnZTtcbiAgICAgICAgICAgIHJvb3Qub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXNfMSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvb3QucG9zdE1lc3NhZ2UoJycsICcqJyk7XG4gICAgICAgICAgICByb290Lm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzXzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5wYXJ0aWFsbHlBcHBsaWVkID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgICAgICAgICAgdmFyIF9hID0gcmVzdWx0LCBoYW5kbGVyID0gX2EuaGFuZGxlciwgYXJncyA9IF9hLmFyZ3M7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKCcnICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZuLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICBmbi5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHRoaXMudGFza3NCeUhhbmRsZVt0aGlzLm5leHRIYW5kbGVdID0gdGhpcy5wYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRIYW5kbGUrKztcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNyZWF0ZVByb2Nlc3NOZXh0VGlja1NldEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gc2V0SW1tZWRpYXRlLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnJvb3QucHJvY2Vzcy5uZXh0VGljayhpbnN0YW5jZS5wYXJ0aWFsbHlBcHBsaWVkKGluc3RhbmNlLnJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgICAgICBmbi5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNyZWF0ZVBvc3RNZXNzYWdlU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gJ3NldEltbWVkaWF0ZSQnICsgcm9vdC5NYXRoLnJhbmRvbSgpICsgJyQnO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24gZ2xvYmFsTWVzc2FnZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGdsb2JhbE1lc3NhZ2VIYW5kbGVyLmluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvbkdsb2JhbE1lc3NhZ2UuaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gc2V0SW1tZWRpYXRlLCBtZXNzYWdlUHJlZml4ID0gX2EubWVzc2FnZVByZWZpeCwgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBpbnN0YW5jZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5yb290LnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsICcqJyk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgICAgICBmbi5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIGZuLm1lc3NhZ2VQcmVmaXggPSBtZXNzYWdlUHJlZml4O1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5ydW5JZlByZXNlbnQgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6ICdXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC4nXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vICd0b28gbXVjaCByZWN1cnNpb24nIGVycm9yLlxuICAgICAgICAgICAgdGhpcy5yb290LnNldFRpbWVvdXQodGhpcy5wYXJ0aWFsbHlBcHBsaWVkKHRoaXMucnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGhpcy50YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jcmVhdGVNZXNzYWdlQ2hhbm5lbFNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgdGhpcy5yb290Lk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIF90aGlzLnJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBzZXRJbW1lZGlhdGUsIGNoYW5uZWwgPSBfYS5jaGFubmVsLCBpbnN0YW5jZSA9IF9hLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBmbi5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNyZWF0ZVJlYWR5U3RhdGVDaGFuZ2VTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHNldEltbWVkaWF0ZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciByb290ID0gaW5zdGFuY2Uucm9vdDtcbiAgICAgICAgICAgIHZhciBkb2MgPSByb290LmRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlU2V0VGltZW91dFNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gc2V0SW1tZWRpYXRlLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnJvb3Quc2V0VGltZW91dChpbnN0YW5jZS5wYXJ0aWFsbHlBcHBsaWVkKGluc3RhbmNlLnJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgICAgICBmbi5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIHJldHVybiBJbW1lZGlhdGVEZWZpbml0aW9uO1xufSgpKTtcbmV4cG9ydHMuSW1tZWRpYXRlRGVmaW5pdGlvbiA9IEltbWVkaWF0ZURlZmluaXRpb247XG5leHBvcnRzLkltbWVkaWF0ZSA9IG5ldyBJbW1lZGlhdGVEZWZpbml0aW9uKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltbWVkaWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEltbWVkaWF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9JbW1lZGlhdGUnKTtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBc2FwQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNhcEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc2FwQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICB9XG4gICAgQXNhcEFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIGRlbGF5IGlzIGdyZWF0ZXIgdGhhbiAwLCByZXF1ZXN0IGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCB0aGUgYWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBxdWV1ZS5cbiAgICAgICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgLy8gSWYgYSBtaWNyb3Rhc2sgaGFzIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQsIGRvbid0IHNjaGVkdWxlIGFub3RoZXJcbiAgICAgICAgLy8gb25lLiBJZiBhIG1pY3JvdGFzayBoYXNuJ3QgYmVlbiBzY2hlZHVsZWQgeWV0LCBzY2hlZHVsZSBvbmUgbm93LiBSZXR1cm5cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2NoZWR1bGVkIG1pY3JvdGFzayBpZC5cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZWQgfHwgKHNjaGVkdWxlci5zY2hlZHVsZWQgPSBJbW1lZGlhdGVfMS5JbW1lZGlhdGUuc2V0SW1tZWRpYXRlKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgbnVsbCkpKTtcbiAgICB9O1xuICAgIEFzYXBBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgICAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNjaGVkdWxlciBxdWV1ZSBpcyBlbXB0eSwgY2FuY2VsIHRoZSByZXF1ZXN0ZWQgbWljcm90YXNrIGFuZFxuICAgICAgICAvLyBzZXQgdGhlIHNjaGVkdWxlZCBmbGFnIHRvIHVuZGVmaW5lZCBzbyB0aGUgbmV4dCBBc2FwQWN0aW9uIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgLy8gaXRzIG93bi5cbiAgICAgICAgaWYgKHNjaGVkdWxlci5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgSW1tZWRpYXRlXzEuSW1tZWRpYXRlLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBzbyB0aGUgYWN0aW9uIGtub3dzIHRvIHJlcXVlc3QgYSBuZXcgYXN5bmMgaWQgaWYgaXQncyByZXNjaGVkdWxlZC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBc2FwQWN0aW9uO1xufShBc3luY0FjdGlvbl8xLkFzeW5jQWN0aW9uKSk7XG5leHBvcnRzLkFzYXBBY3Rpb24gPSBBc2FwQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNhcEFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG52YXIgQXNhcFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzYXBTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNhcFNjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFzYXBTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGNvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbiB8fCBhY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXNhcFNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc2FwU2NoZWR1bGVyID0gQXNhcFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzYXBTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXNhcEFjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc2FwQWN0aW9uJyk7XG52YXIgQXNhcFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc2FwU2NoZWR1bGVyJyk7XG5leHBvcnRzLmFzYXAgPSBuZXcgQXNhcFNjaGVkdWxlcl8xLkFzYXBTY2hlZHVsZXIoQXNhcEFjdGlvbl8xLkFzYXBBY3Rpb24pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNhcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc2FwXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXNhcCcpO1xudmFyIGlzTnVtZXJpY18xID0gcmVxdWlyZSgnLi4vdXRpbC9pc051bWVyaWMnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgU3Vic2NyaWJlT25PYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaWJlT25PYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZU9uT2JzZXJ2YWJsZShzb3VyY2UsIGRlbGF5VGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChkZWxheVRpbWUgPT09IHZvaWQgMCkgeyBkZWxheVRpbWUgPSAwOyB9XG4gICAgICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc2FwXzEuYXNhcDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZGVsYXlUaW1lID0gZGVsYXlUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFpc051bWVyaWNfMS5pc051bWVyaWMoZGVsYXlUaW1lKSB8fCBkZWxheVRpbWUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgfHwgdHlwZW9mIHNjaGVkdWxlci5zY2hlZHVsZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBhc2FwXzEuYXNhcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVPbk9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzYXBfMS5hc2FwOyB9XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlT25PYnNlcnZhYmxlKHNvdXJjZSwgZGVsYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVPbk9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmcuc291cmNlLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZU9uT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBkZWxheSA9IHRoaXMuZGVsYXlUaW1lO1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShTdWJzY3JpYmVPbk9ic2VydmFibGUuZGlzcGF0Y2gsIGRlbGF5LCB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVPbk9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlN1YnNjcmliZU9uT2JzZXJ2YWJsZSA9IFN1YnNjcmliZU9uT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZU9uT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVPbk9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU3Vic2NyaWJlT25PYnNlcnZhYmxlJyk7XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHN1YnNjcmliZXMgT2JzZXJ2ZXJzIHRvIHRoaXMgT2JzZXJ2YWJsZSBvbiB0aGUgc3BlY2lmaWVkIFNjaGVkdWxlci5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N1YnNjcmliZU9uLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSB0aGUgU2NoZWR1bGVyIHRvIHBlcmZvcm0gc3Vic2NyaXB0aW9uIGFjdGlvbnMgb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSB0aGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgc28gdGhhdCBpdHMgc3Vic2NyaXB0aW9ucyBoYXBwZW4gb24gdGhlIHNwZWNpZmllZCBTY2hlZHVsZXJcbiAuXG4gKiBAbWV0aG9kIHN1YnNjcmliZU9uXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzdWJzY3JpYmVPbihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3Vic2NyaWJlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG59XG5leHBvcnRzLnN1YnNjcmliZU9uID0gc3Vic2NyaWJlT247XG52YXIgU3Vic2NyaWJlT25PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgfVxuICAgIFN1YnNjcmliZU9uT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlT25PYnNlcnZhYmxlXzEuU3Vic2NyaWJlT25PYnNlcnZhYmxlKHNvdXJjZSwgdGhpcy5kZWxheSwgdGhpcy5zY2hlZHVsZXIpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVPbk9wZXJhdG9yO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZU9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVPbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3Vic2NyaWJlT24nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmVPbiA9IHN1YnNjcmliZU9uXzEuc3Vic2NyaWJlT247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVPbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieVxuICogc3Vic2NyaWJpbmcgdG8gb25seSB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIG9mIHRob3NlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGRyb3BwaW5nIHRoZVxuICogcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBvbmNlIGEgbmV3IG9uZSBhcHBlYXJzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc3dpdGNoYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN1YnNjcmliZXMgdG8gdGhlIGlubmVyIE9ic2VydmFibGUgYW5kXG4gKiBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhhdC4gU28gZmFyLCBpdCBiZWhhdmVzXG4gKiBsaWtlIHtAbGluayBtZXJnZUFsbH0uIEhvd2V2ZXIsIHdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLFxuICogYHN3aXRjaGAgdW5zdWJzY3JpYmVzIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogc3Vic2NyaWJlcyB0byB0aGUgbmV3IGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2lucyBlbWl0dGluZyBpdGVtcyBmcm9tIGl0LiBJdFxuICogY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiAvLyBFYWNoIGNsaWNrIGV2ZW50IGlzIG1hcHBlZCB0byBhbiBPYnNlcnZhYmxlIHRoYXQgdGlja3MgZXZlcnkgc2Vjb25kXG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgc3dpdGNoZWQgPSBoaWdoZXJPcmRlci5zd2l0Y2goKTtcbiAqIC8vIFRoZSBvdXRjb21lIGlzIHRoYXQgYHN3aXRjaGVkYCBpcyBlc3NlbnRpYWxseSBhIHRpbWVyIHRoYXQgcmVzdGFydHNcbiAqIC8vIG9uIGV2ZXJ5IGNsaWNrLiBUaGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZXMgZnJvbSBvbGRlciBjbGlja3MgZG8gbm90IG1lcmdlXG4gKiAvLyB3aXRoIHRoZSBjdXJyZW50IGludGVydmFsIE9ic2VydmFibGUuXG4gKiBzd2l0Y2hlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIE9ic2VydmFibGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoXG4gKiBAbmFtZSBzd2l0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9zd2l0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLl9zd2l0Y2ggPSBfc3dpdGNoO1xudmFyIFN3aXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgU3dpdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlID4gMCA/IHRoaXMuYWN0aXZlIC0gMSA6IDA7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N3aXRjaCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaCA9IHN3aXRjaF8xLl9zd2l0Y2g7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N3aXRjaCA9IHN3aXRjaF8xLl9zd2l0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGV9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZyBvbmx5IHRoZSB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRseVxuICogcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3dpdGNoTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwID0gc3dpdGNoTWFwO1xudmFyIFN3aXRjaE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgfVxuICAgIFN3aXRjaE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlOb3RpZnlOZXh0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5Tm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoTWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2hNYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIHNhbWUgT2JzZXJ2YWJsZSB3aGljaCBpcyBmbGF0dGVuZWQgbXVsdGlwbGVcbiAqIHRpbWVzIHdpdGgge0BsaW5rIHN3aXRjaH0gaW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIHN3aXRjaE1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWVcbiAqIGFsd2F5cyB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaE1hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIE1hcHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIGdpdmVuIE9ic2VydmFibGUgYGlubmVyT2JzZXJ2YWJsZWAgcmVnYXJkbGVzc1xuICogb2YgdGhlIHNvdXJjZSB2YWx1ZSwgYW5kIHRoZW4gZmxhdHRlbnMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGVzXG4gKiBlbWl0cyB2YWx1ZXMgb25seSBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgaW5zdGFuY2Ugb2ZcbiAqIGBpbm5lck9ic2VydmFibGVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zd2l0Y2hNYXBUbyhSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gaW5uZXJPYnNlcnZhYmxlIEFuIE9ic2VydmFibGUgdG8gcmVwbGFjZSBlYWNoIHZhbHVlIGZyb21cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgZ2l2ZW5cbiAqIGBpbm5lck9ic2VydmFibGVgIGV2ZXJ5IHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgKGFuZCBvcHRpb25hbGx5IHRyYW5zZm9ybWVkIHRocm91Z2ggYHJlc3VsdFNlbGVjdG9yYCkgZXZlcnlcbiAqIHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIHRha2luZyBvbmx5IHRoZSB2YWx1ZXNcbiAqIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaE1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwVG9PcGVyYXRvcihpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSk7XG59XG5leHBvcnRzLnN3aXRjaE1hcFRvID0gc3dpdGNoTWFwVG87XG52YXIgU3dpdGNoTWFwVG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwVG9PcGVyYXRvcihvYnNlcnZhYmxlLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgfVxuICAgIFN3aXRjaE1hcFRvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBUb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLnJlc3VsdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwVG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFRvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaE1hcFRvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBUb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIGlubmVyLCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5pbm5lciwgdmFsdWUsIHRoaXMuaW5kZXgrKykpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBUb1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoTWFwVG9TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlc3VsdFNlbGVjdG9yID0gX2EucmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy50cnlSZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFRvU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwVG9TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcFRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hNYXBUb18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3dpdGNoTWFwVG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2hNYXBUbyA9IHN3aXRjaE1hcFRvXzEuc3dpdGNoTWFwVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXBUby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UsIHRoZW5cbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcyB0aGVuXG4gKiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gQWZ0ZXIgdGhhdCwgaXQgY29tcGxldGVzLCByZWdhcmRsZXNzIGlmIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UYWtlIHRoZSBmaXJzdCA1IHNlY29uZHMgb2YgYW4gaW5maW5pdGUgMS1zZWNvbmQgaW50ZXJ2YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgZml2ZSA9IGludGVydmFsLnRha2UoNSk7XG4gKiBmaXZlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2UoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYG5leHRgIHZhbHVlcyB0byBlbWl0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGBcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBpZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YCB2YWx1ZXMuXG4gKiBAbWV0aG9kIHRha2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2UoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZSA9IHRha2U7XG52YXIgVGFrZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFRha2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB2YXIgY291bnQgPSArK3RoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCA8PSB0b3RhbCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0YWtlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90YWtlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZSA9IHRha2VfMS50YWtlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgbGFzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UmVtZW1iZXJzIHRoZSBsYXRlc3QgYGNvdW50YCB2YWx1ZXMsIHRoZW4gZW1pdHMgdGhvc2VcbiAqIG9ubHkgd2hlbiB0aGUgc291cmNlIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlTGFzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZUxhc3RgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGF0IG1vc3QgdGhlIGxhc3QgYGNvdW50YCB2YWx1ZXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YFxuICogdmFsdWVzIHRoZW4gYWxsIG9mIGl0cyB2YWx1ZXMgYXJlIGVtaXR0ZWQuIFRoaXMgb3BlcmF0b3IgbXVzdCB3YWl0IHVudGlsIHRoZVxuICogYGNvbXBsZXRlYCBub3RpZmljYXRpb24gZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGVtaXQgdGhlIGBuZXh0YFxuICogdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSwgYmVjYXVzZSBvdGhlcndpc2UgaXQgaXMgaW1wb3NzaWJsZSB0byBrbm93XG4gKiB3aGV0aGVyIG9yIG5vdCBtb3JlIHZhbHVlcyB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIHNvdXJjZS4gRm9yIHRoaXMgcmVhc29uLFxuICogYWxsIHZhbHVlcyBhcmUgZW1pdHRlZCBzeW5jaHJvbm91c2x5LCBmb2xsb3dlZCBieSB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGxhc3QgMyB2YWx1ZXMgb2YgYW4gT2JzZXJ2YWJsZSB3aXRoIG1hbnkgdmFsdWVzPC9jYXB0aW9uPlxuICogdmFyIG1hbnkgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwMCk7XG4gKiB2YXIgbGFzdFRocmVlID0gbWFueS50YWtlTGFzdCgzKTtcbiAqIGxhc3RUaHJlZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2VMYXN0KGkpYCwgaXQgZGVsaXZlcnMgYW5cbiAqIEFyZ3VtZW50T3V0T3JSYW5nZUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmAgY2FsbGJhY2sgaWYgYGkgPCAwYC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhbHVlcyB0byBlbWl0IGZyb20gdGhlIGVuZCBvZlxuICogdGhlIHNlcXVlbmNlIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhdCBtb3N0IHRoZSBsYXN0IGNvdW50XG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHRha2VMYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0YWtlTGFzdChjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZUxhc3RPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZUxhc3QgPSB0YWtlTGFzdDtcbnZhciBUYWtlTGFzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlTGFzdE9wZXJhdG9yKHRvdGFsKSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgaWYgKHRoaXMudG90YWwgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUYWtlTGFzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZUxhc3RTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlTGFzdE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZUxhc3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZUxhc3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VMYXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMucmluZyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgVGFrZUxhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmluZyA9IHRoaXMucmluZztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCsrO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCB0b3RhbCkge1xuICAgICAgICAgICAgcmluZy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvdW50ICUgdG90YWw7XG4gICAgICAgICAgICByaW5nW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWtlTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5jb3VudCA+PSB0aGlzLnRvdGFsID8gdGhpcy50b3RhbCA6IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHRoaXMucmluZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSAoY291bnQrKykgJSB0b3RhbDtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJpbmdbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlTGFzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZUxhc3RfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rha2VMYXN0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZUxhc3QgPSB0YWtlTGFzdF8xLnRha2VMYXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZUxhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgYSBgbm90aWZpZXJgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgdmFsdWVzIHBhc3MgdW50aWwgYSBzZWNvbmQgT2JzZXJ2YWJsZSxcbiAqIGBub3RpZmllcmAsIGVtaXRzIHNvbWV0aGluZy4gVGhlbiwgaXQgY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2VVbnRpbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZVVudGlsYCBzdWJzY3JpYmVzIGFuZCBiZWdpbnMgbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSXQgYWxzb1xuICogbW9uaXRvcnMgYSBzZWNvbmQgT2JzZXJ2YWJsZSwgYG5vdGlmaWVyYCB0aGF0IHlvdSBwcm92aWRlLiBJZiB0aGUgYG5vdGlmaWVyYFxuICogZW1pdHMgYSB2YWx1ZSBvciBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN0b3BzXG4gKiBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGljayBldmVyeSBzZWNvbmQgdW50aWwgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbnM8L2NhcHRpb24+XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHdob3NlIGZpcnN0IGVtaXR0ZWQgdmFsdWUgd2lsbFxuICogY2F1c2UgdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9mIGB0YWtlVW50aWxgIHRvIHN0b3AgZW1pdHRpbmcgdmFsdWVzIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB1bnRpbCBzdWNoIHRpbWUgYXMgYG5vdGlmaWVyYCBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gKiBAbWV0aG9kIHRha2VVbnRpbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZVVudGlsKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpKTtcbn1cbmV4cG9ydHMudGFrZVVudGlsID0gdGFrZVVudGlsO1xudmFyIFRha2VVbnRpbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFRha2VVbnRpbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVVudGlsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlVW50aWxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVVudGlsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlVW50aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRha2VVbnRpbF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZVVudGlsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVVudGlsID0gdGFrZVVudGlsXzEudGFrZVVudGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBFbWl0cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgc28gbG9uZyBhcyBlYWNoIHZhbHVlIHNhdGlzZmllc1xuICogdGhlIGdpdmVuIGBwcmVkaWNhdGVgLCBhbmQgdGhlbiBjb21wbGV0ZXMgYXMgc29vbiBhcyB0aGlzIGBwcmVkaWNhdGVgIGlzIG5vdFxuICogc2F0aXNmaWVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UYWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIG9ubHkgd2hpbGUgdGhleSBwYXNzIHRoZVxuICogY29uZGl0aW9uIGdpdmVuLiBXaGVuIHRoZSBmaXJzdCB2YWx1ZSBkb2VzIG5vdCBzYXRpc2Z5LCBpdCBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZVdoaWxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlV2hpbGVgIHN1YnNjcmliZXMgYW5kIGJlZ2lucyBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBFYWNoIHZhbHVlXG4gKiBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgaXMgZ2l2ZW4gdG8gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYVxuICogYm9vbGVhbiwgcmVwcmVzZW50aW5nIGEgY29uZGl0aW9uIHRvIGJlIHNhdGlzZmllZCBieSB0aGUgc291cmNlIHZhbHVlcy4gVGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB0aGUgc291cmNlIHZhbHVlcyB1bnRpbCBzdWNoIHRpbWUgYXMgdGhlIGBwcmVkaWNhdGVgXG4gKiByZXR1cm5zIGZhbHNlLCBhdCB3aGljaCBwb2ludCBgdGFrZVdoaWxlYCBzdG9wcyBtaXJyb3JpbmcgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrIGV2ZW50cyBvbmx5IHdoaWxlIHRoZSBjbGllbnRYIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiAyMDA8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy50YWtlV2hpbGUoZXYgPT4gZXYuY2xpZW50WCA+IDIwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBhIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCByZXR1cm5zIGEgYm9vbGVhbi5cbiAqIEFsc28gdGFrZXMgdGhlICh6ZXJvLWJhc2VkKSBpbmRleCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHNvIGxvbmcgYXMgZWFjaCB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBkZWZpbmVkIGJ5IHRoZVxuICogYHByZWRpY2F0ZWAsIHRoZW4gY29tcGxldGVzLlxuICogQG1ldGhvZCB0YWtlV2hpbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VXaGlsZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpKTtcbn1cbmV4cG9ydHMudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xudmFyIFRha2VXaGlsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIFRha2VXaGlsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VXaGlsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZVdoaWxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBUYWtlV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRPckNvbXBsZXRlKHZhbHVlLCByZXN1bHQpO1xuICAgIH07XG4gICAgVGFrZVdoaWxlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dE9yQ29tcGxldGUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWRpY2F0ZVJlc3VsdCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoQm9vbGVhbihwcmVkaWNhdGVSZXN1bHQpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVdoaWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0YWtlV2hpbGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rha2VXaGlsZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRha2VXaGlsZSA9IHRha2VXaGlsZV8xLnRha2VXaGlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VXaGlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiBpZ25vcmVzIHN1YnNlcXVlbnQgc291cmNlXG4gKiB2YWx1ZXMgZm9yIGEgZHVyYXRpb24gZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzXG4gKiBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIHRocm90dGxlVGltZX0sIGJ1dCB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGhyb3R0bGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRocm90dGxlYCBlbWl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogd2hlbiBpdHMgaW50ZXJuYWwgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2VcbiAqIHZhbHVlIGFycml2ZXMsIGl0IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZCBieSBjYWxsaW5nIHRoZSBgZHVyYXRpb25TZWxlY3RvcmAgZnVuY3Rpb24gd2l0aCB0aGUgc291cmNlIHZhbHVlLFxuICogd2hpY2ggcmV0dXJucyB0aGUgXCJkdXJhdGlvblwiIE9ic2VydmFibGUuIFdoZW4gdGhlIGR1cmF0aW9uIE9ic2VydmFibGUgZW1pdHMgYVxuICogdmFsdWUgb3IgY29tcGxldGVzLCB0aGUgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlXG4gKiBuZXh0IHNvdXJjZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRocm90dGxlKGV2ID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICogQHNlZSB7QGxpbmsgc2FtcGxlfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBPYnNlcnZhYmxlfFByb21pc2V9IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvblxuICogdGhhdCByZWNlaXZlcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBmb3IgY29tcHV0aW5nIHRoZSBzaWxlbmNpbmdcbiAqIGR1cmF0aW9uIGZvciBlYWNoIHNvdXJjZSB2YWx1ZSwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIHRocm90dGxlIG9wZXJhdGlvbiB0b1xuICogbGltaXQgdGhlIHJhdGUgb2YgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBtZXRob2QgdGhyb3R0bGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaHJvdHRsZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbnZhciBUaHJvdHRsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgVGhyb3R0bGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRocm90dGxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGhyb3R0bGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICB9XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUR1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLnRyeUR1cmF0aW9uU2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0QW5kVGhyb3R0bGUodmFsdWUsIGR1cmF0aW9uKTtcbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUuZW1pdEFuZFRocm90dGxlID0gZnVuY3Rpb24gKHZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFRocm90dGxlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhyb3R0bGVkID0gdGhpcy50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRocm90dGxlZCk7XG4gICAgICAgICAgICB0aGlzLnRocm90dGxlZCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdHRsZWQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGhyb3R0bGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBUaHJvdHRsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3R0bGVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rocm90dGxlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGhyb3R0bGUgPSB0aHJvdHRsZV8xLnRocm90dGxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgYSB2YWx1ZSBwYXNzLCB0aGVuIGlnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgdGhlXG4gKiBuZXh0IGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm90dGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVUaW1lYCBlbWl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogd2hlbiBpdHMgaW50ZXJuYWwgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2VcbiAqIHZhbHVlIGFycml2ZXMsIGl0IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gQWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGhhcyBwYXNzZWQsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCxcbiAqIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLiBPcHRpb25hbGx5IHRha2VzIGFcbiAqIHtAbGluayBTY2hlZHVsZXJ9IGZvciBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy50aHJvdHRsZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBUaW1lIHRvIHdhaXQgYmVmb3JlIGVtaXR0aW5nIGFub3RoZXIgdmFsdWUgYWZ0ZXJcbiAqIGVtaXR0aW5nIHRoZSBsYXN0IHZhbHVlLCBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHMgb3IgdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkXG4gKiBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIFNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgc2FtcGxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIHRocm90dGxlIG9wZXJhdGlvbiB0b1xuICogbGltaXQgdGhlIHJhdGUgb2YgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBtZXRob2QgdGhyb3R0bGVUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZVRpbWUoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWU7XG52YXIgVGhyb3R0bGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZU9wZXJhdG9yKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb24sIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVyYXRpb24sIHsgc3Vic2NyaWJlcjogdGhpcyB9KSk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhyb3R0bGVkID0gdGhpcy50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3R0bGVUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aHJvdHRsZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWVfMS50aHJvdHRsZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRpbWVJbnRlcnZhbDxhbnk+PnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVJbnRlcnZhbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGltZUludGVydmFsKHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGltZUludGVydmFsT3BlcmF0b3Ioc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbDtcbnZhciBUaW1lSW50ZXJ2YWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgfVxuICAgIHJldHVybiBUaW1lSW50ZXJ2YWw7XG59KCkpO1xuZXhwb3J0cy5UaW1lSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWw7XG47XG52YXIgVGltZUludGVydmFsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbE9wZXJhdG9yKHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZUludGVydmFsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZUludGVydmFsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lSW50ZXJ2YWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVJbnRlcnZhbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lSW50ZXJ2YWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHNjaGVkdWxlci5ub3coKTtcbiAgICB9XG4gICAgVGltZUludGVydmFsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB2YXIgc3BhbiA9IG5vdyAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBub3c7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuZXcgVGltZUludGVydmFsKHZhbHVlLCBzcGFuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUludGVydmFsU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVJbnRlcnZhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGltZUludGVydmFsXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aW1lSW50ZXJ2YWwnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lSW50ZXJ2YWwgPSB0aW1lSW50ZXJ2YWxfMS50aW1lSW50ZXJ2YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lSW50ZXJ2YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gZHVldGltZSBlbGFwc2VzLlxuICpcbiAqIEBzZWUge0BsaW5rIHRpbWVvdXR9XG4gKlxuICogQGNsYXNzIFRpbWVvdXRFcnJvclxuICovXG52YXIgVGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVvdXRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdUaW1lb3V0IGhhcyBvY2N1cnJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVvdXRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZW91dEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgVGltZW91dEVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL1RpbWVvdXRFcnJvcicpO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl1cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lb3V0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGR1ZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICB2YXIgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlXzEuaXNEYXRlKGR1ZSk7XG4gICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyAoK2R1ZSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyhkdWUpO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRpbWVvdXRPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHNjaGVkdWxlciwgbmV3IFRpbWVvdXRFcnJvcl8xLlRpbWVvdXRFcnJvcigpKSk7XG59XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xudmFyIFRpbWVvdXRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZW91dE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5lcnJvckluc3RhbmNlID0gZXJyb3JJbnN0YW5jZTtcbiAgICB9XG4gICAgVGltZW91dE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZW91dFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy5zY2hlZHVsZXIsIHRoaXMuZXJyb3JJbnN0YW5jZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRpbWVvdXRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZW91dFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgc2NoZWR1bGVyLCBlcnJvckluc3RhbmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZVRpbWVvdXQgPSBhYnNvbHV0ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmVycm9ySW5zdGFuY2UgPSBlcnJvckluc3RhbmNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLCBcInByZXZpb3VzSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0luZGV4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLCBcImhhc0NvbXBsZXRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NvbXBsZXRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGltZW91dFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIGlmICghc291cmNlLmhhc0NvbXBsZXRlZCAmJiBzb3VyY2UucHJldmlvdXNJbmRleCA9PT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBzb3VyY2Uubm90aWZ5VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lb3V0U3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoVGltZW91dFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHsgc3Vic2NyaWJlcjogdGhpcywgaW5kZXg6IGN1cnJlbnRJbmRleCB9KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4O1xuICAgIH07XG4gICAgVGltZW91dFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5hYnNvbHV0ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5faGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVvdXRTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVycm9yKHRoaXMuZXJyb3JJbnN0YW5jZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZW91dFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aW1lb3V0XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aW1lb3V0Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGltZW91dCA9IHRpbWVvdXRfMS50aW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBkdWVcbiAqIEBwYXJhbSB3aXRoT2JzZXJ2YWJsZVxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVvdXRXaXRoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lb3V0V2l0aChkdWUsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHZhciBhYnNvbHV0ZVRpbWVvdXQgPSBpc0RhdGVfMS5pc0RhdGUoZHVlKTtcbiAgICB2YXIgd2FpdEZvciA9IGFic29sdXRlVGltZW91dCA/ICgrZHVlIC0gc2NoZWR1bGVyLm5vdygpKSA6IE1hdGguYWJzKGR1ZSk7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGltZW91dFdpdGhPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMudGltZW91dFdpdGggPSB0aW1lb3V0V2l0aDtcbnZhciBUaW1lb3V0V2l0aE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgICAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICAgICAgdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZW91dFdpdGhPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVvdXRXaXRoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLndpdGhPYnNlcnZhYmxlLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVvdXRXaXRoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaW1lb3V0V2l0aFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lb3V0V2l0aFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZW91dFdpdGhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhYnNvbHV0ZVRpbWVvdXQsIHdhaXRGb3IsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZVRpbWVvdXQgPSBhYnNvbHV0ZVRpbWVvdXQ7XG4gICAgICAgIHRoaXMud2FpdEZvciA9IHdhaXRGb3I7XG4gICAgICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSB3aXRoT2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMudGltZW91dFN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZSwgXCJwcmV2aW91c0luZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNJbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUsIFwiaGFzQ29tcGxldGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzQ29tcGxldGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIGlmICghc291cmNlLmhhc0NvbXBsZXRlZCAmJiBzb3VyY2UucHJldmlvdXNJbmRleCA9PT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBzb3VyY2UuaGFuZGxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciB0aW1lb3V0U3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIGluZGV4OiBjdXJyZW50SW5kZXggfTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoVGltZW91dFdpdGhTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aW1lb3V0U3RhdGUpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5hYnNvbHV0ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB2YXIgd2l0aE9ic2VydmFibGUgPSB0aGlzLndpdGhPYnNlcnZhYmxlO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcy50aW1lb3V0U3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB3aXRoT2JzZXJ2YWJsZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGltZW91dFdpdGhTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXRXaXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aW1lb3V0V2l0aF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGltZW91dFdpdGgnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lb3V0V2l0aCA9IHRpbWVvdXRXaXRoXzEudGltZW91dFdpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VGltZXN0YW1wPGFueT4+fFdlYlNvY2tldFN1YmplY3Q8VD58T2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgdGltZXN0YW1wXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aW1lc3RhbXAoc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaW1lc3RhbXBPcGVyYXRvcihzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMudGltZXN0YW1wID0gdGltZXN0YW1wO1xudmFyIFRpbWVzdGFtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXN0YW1wKHZhbHVlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9XG4gICAgcmV0dXJuIFRpbWVzdGFtcDtcbn0oKSk7XG5leHBvcnRzLlRpbWVzdGFtcCA9IFRpbWVzdGFtcDtcbjtcbnZhciBUaW1lc3RhbXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXN0YW1wT3BlcmF0b3Ioc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaW1lc3RhbXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lc3RhbXBTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVzdGFtcE9wZXJhdG9yO1xufSgpKTtcbnZhciBUaW1lc3RhbXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXN0YW1wU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGltZXN0YW1wU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMuc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQobmV3IFRpbWVzdGFtcCh2YWx1ZSwgbm93KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXN0YW1wU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVzdGFtcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGltZXN0YW1wXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aW1lc3RhbXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lc3RhbXAgPSB0aW1lc3RhbXBfMS50aW1lc3RhbXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3RhbXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEByZXR1cm4ge09ic2VydmFibGU8YW55W10+fFdlYlNvY2tldFN1YmplY3Q8VD58T2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgdG9BcnJheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUb0FycmF5T3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xudmFyIFRvQXJyYXlPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9BcnJheU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBUb0FycmF5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUb0FycmF5U3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9BcnJheU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVG9BcnJheVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb0FycmF5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb0FycmF5U3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG4gICAgVG9BcnJheVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy5hcnJheS5wdXNoKHgpO1xuICAgIH07XG4gICAgVG9BcnJheVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9BcnJheVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0b0FycmF5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90b0FycmF5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9BcnJheSA9IHRvQXJyYXlfMS50b0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9BcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBAcGFyYW0gUHJvbWlzZUN0b3JcbiAqIEByZXR1cm4ge1Byb21pc2U8VD59XG4gKiBAbWV0aG9kIHRvUHJvbWlzZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdG9Qcm9taXNlKFByb21pc2VDdG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5Qcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7IHJldHVybiB2YWx1ZSA9IHg7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnRvUHJvbWlzZSA9IHRvUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvUHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdG9Qcm9taXNlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90b1Byb21pc2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50b1Byb21pc2UgPSB0b1Byb21pc2VfMS50b1Byb21pc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1Byb21pc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB3aGVuZXZlclxuICogYHdpbmRvd0JvdW5kYXJpZXNgIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlcn0sIGJ1dCBlbWl0cyBhIG5lc3RlZCBPYnNlcnZhYmxlXG4gKiBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvdy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIGNvbm5lY3RlZCwgbm9uLW92ZXJsYXBwaW5nXG4gKiB3aW5kb3dzLiBJdCBlbWl0cyB0aGUgY3VycmVudCB3aW5kb3cgYW5kIG9wZW5zIGEgbmV3IG9uZSB3aGVuZXZlciB0aGVcbiAqIE9ic2VydmFibGUgYHdpbmRvd0JvdW5kYXJpZXNgIGVtaXRzIGFuIGl0ZW0uIEJlY2F1c2UgZWFjaCB3aW5kb3cgaXMgYW5cbiAqIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgaXMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JbiBldmVyeSB3aW5kb3cgb2YgMSBzZWNvbmQgZWFjaCwgZW1pdCBhdCBtb3N0IDIgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvdyhpbnRlcnZhbClcbiAqICAgLm1hcCh3aW4gPT4gd2luLnRha2UoMikpIC8vIGVhY2ggd2luZG93IGhhcyBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IHdpbmRvd0JvdW5kYXJpZXMgQW4gT2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyB0aGVcbiAqIHByZXZpb3VzIHdpbmRvdyBhbmQgc3RhcnRzIGEgbmV3IHdpbmRvdy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIE9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggYXJlXG4gKiBPYnNlcnZhYmxlcyBlbWl0dGluZyB2YWx1ZXMgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB3aW5kb3dcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvdyh3aW5kb3dCb3VuZGFyaWVzKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93T3BlcmF0b3Iod2luZG93Qm91bmRhcmllcykpO1xufVxuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3c7XG52YXIgV2luZG93T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd09wZXJhdG9yKHdpbmRvd0JvdW5kYXJpZXMpIHtcbiAgICAgICAgdGhpcy53aW5kb3dCb3VuZGFyaWVzID0gd2luZG93Qm91bmRhcmllcztcbiAgICB9XG4gICAgV2luZG93T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciB3aW5kb3dTdWJzY3JpYmVyID0gbmV3IFdpbmRvd1N1YnNjcmliZXIoc3Vic2NyaWJlcik7XG4gICAgICAgIHZhciBzb3VyY2VTdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHdpbmRvd1N1YnNjcmliZXIpO1xuICAgICAgICBpZiAoIXNvdXJjZVN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHdpbmRvd1N1YnNjcmliZXIuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQod2luZG93U3Vic2NyaWJlciwgdGhpcy53aW5kb3dCb3VuZGFyaWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZVN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpbmRvd1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1N1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMud2luZG93KTtcbiAgICB9XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy53aW5kb3cubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMud2luZG93LmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53aW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldldpbmRvdyA9IHRoaXMud2luZG93O1xuICAgICAgICBpZiAocHJldldpbmRvdykge1xuICAgICAgICAgICAgcHJldldpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHZhciBuZXdXaW5kb3cgPSB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KG5ld1dpbmRvdyk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHdpbmRvd18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2luZG93Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93ID0gd2luZG93XzEud2luZG93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgd2l0aCBlYWNoXG4gKiBuZXN0ZWQgT2JzZXJ2YWJsZSBlbWl0dGluZyBhdCBtb3N0IGB3aW5kb3dTaXplYCB2YWx1ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyQ291bnR9LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3dDb3VudC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHdpbmRvd3MgZXZlcnkgYHN0YXJ0V2luZG93RXZlcnlgXG4gKiBpdGVtcywgZWFjaCBjb250YWluaW5nIG5vIG1vcmUgdGhhbiBgd2luZG93U2l6ZWAgaXRlbXMuIFdoZW4gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBjb21wbGV0ZXMgb3IgZW5jb3VudGVycyBhbiBlcnJvciwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzXG4gKiB0aGUgY3VycmVudCB3aW5kb3cgYW5kIHByb3BhZ2F0ZXMgdGhlIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gbmV3IHdpbmRvd3MgYXJlXG4gKiBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlIGFuZCB3aGVuIGVhY2ggd2luZG93IGNvbXBsZXRlc1xuICogd2l0aCBzaXplIGB3aW5kb3dTaXplYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZ25vcmUgZXZlcnkgM3JkIGNsaWNrIGV2ZW50LCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvbmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dDb3VudCgzKVxuICogICAubWFwKHdpbiA9PiB3aW4uc2tpcCgxKSkgLy8gc2tpcCBmaXJzdCBvZiBldmVyeSAzIGNsaWNrc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZ25vcmUgZXZlcnkgM3JkIGNsaWNrIGV2ZW50LCBzdGFydGluZyBmcm9tIHRoZSB0aGlyZCBvbmU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dDb3VudCgyLCAzKVxuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dTaXplIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2YWx1ZXMgZW1pdHRlZCBieSBlYWNoXG4gKiB3aW5kb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0V2luZG93RXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IHdpbmRvdy5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydFdpbmRvd0V2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgd2luZG93IHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyB3aW5kb3cgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBPYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlIG9mIHZhbHVlcy5cbiAqIEBtZXRob2Qgd2luZG93Q291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpbmRvd0NvdW50KHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcbiAgICBpZiAoc3RhcnRXaW5kb3dFdmVyeSA9PT0gdm9pZCAwKSB7IHN0YXJ0V2luZG93RXZlcnkgPSAwOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93Q291bnRPcGVyYXRvcih3aW5kb3dTaXplLCBzdGFydFdpbmRvd0V2ZXJ5KSk7XG59XG5leHBvcnRzLndpbmRvd0NvdW50ID0gd2luZG93Q291bnQ7XG52YXIgV2luZG93Q291bnRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93Q291bnRPcGVyYXRvcih3aW5kb3dTaXplLCBzdGFydFdpbmRvd0V2ZXJ5KSB7XG4gICAgICAgIHRoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemU7XG4gICAgICAgIHRoaXMuc3RhcnRXaW5kb3dFdmVyeSA9IHN0YXJ0V2luZG93RXZlcnk7XG4gICAgfVxuICAgIFdpbmRvd0NvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy53aW5kb3dTaXplLCB0aGlzLnN0YXJ0V2luZG93RXZlcnkpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dDb3VudE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2luZG93Q291bnRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93Q291bnRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd0NvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgd2luZG93U2l6ZSwgc3RhcnRXaW5kb3dFdmVyeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy53aW5kb3dTaXplID0gd2luZG93U2l6ZTtcbiAgICAgICAgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID0gc3RhcnRXaW5kb3dFdmVyeTtcbiAgICAgICAgdGhpcy53aW5kb3dzID0gW25ldyBTdWJqZWN0XzEuU3ViamVjdCgpXTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy53aW5kb3dzWzBdKTtcbiAgICB9XG4gICAgV2luZG93Q291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhcnRXaW5kb3dFdmVyeSA9ICh0aGlzLnN0YXJ0V2luZG93RXZlcnkgPiAwKSA/IHRoaXMuc3RhcnRXaW5kb3dFdmVyeSA6IHRoaXMud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSB0aGlzLndpbmRvd1NpemU7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB2YXIgbGVuID0gd2luZG93cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuICYmICF0aGlzLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICB3aW5kb3dzW2ldLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gdGhpcy5jb3VudCAtIHdpbmRvd1NpemUgKyAxO1xuICAgICAgICBpZiAoYyA+PSAwICYmIGMgJSBzdGFydFdpbmRvd0V2ZXJ5ID09PSAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsrdGhpcy5jb3VudCAlIHN0YXJ0V2luZG93RXZlcnkgPT09IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB2YXIgd2luZG93XzEgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgIHdpbmRvd3MucHVzaCh3aW5kb3dfMSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHdpbmRvd18xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93Q291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICBpZiAod2luZG93cykge1xuICAgICAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCAmJiAhdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIGlmICh3aW5kb3dzKSB7XG4gICAgICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd0NvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy53aW5kb3dzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dDb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2luZG93Q291bnRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3dpbmRvd0NvdW50Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93Q291bnQgPSB3aW5kb3dDb3VudF8xLndpbmRvd0NvdW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93Q291bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgcGVyaW9kaWNhbGx5XG4gKiBpbiB0aW1lLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlclRpbWV9LCBidXQgZW1pdHMgYSBuZXN0ZWRcbiAqIE9ic2VydmFibGUgaW5zdGVhZCBvZiBhbiBhcnJheS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aW5kb3dUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgc3RhcnRzIGEgbmV3IHdpbmRvdyBwZXJpb2RpY2FsbHksIGFzXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBgd2luZG93Q3JlYXRpb25JbnRlcnZhbGAgYXJndW1lbnQuIEl0IGVtaXRzIGVhY2ggd2luZG93XG4gKiBhZnRlciBhIGZpeGVkIHRpbWVzcGFuLCBzcGVjaWZpZWQgYnkgdGhlIGB3aW5kb3dUaW1lU3BhbmAgYXJndW1lbnQuIFdoZW4gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgb3IgZW5jb3VudGVycyBhbiBlcnJvciwgdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiBlbWl0cyB0aGUgY3VycmVudCB3aW5kb3cgYW5kIHByb3BhZ2F0ZXMgdGhlIG5vdGlmaWNhdGlvbiBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGB3aW5kb3dDcmVhdGlvbkludGVydmFsYCBpcyBub3QgcHJvdmlkZWQsIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUgc3RhcnRzIGEgbmV3IHdpbmRvdyB3aGVuIHRoZSBwcmV2aW91cyB3aW5kb3cgb2YgZHVyYXRpb25cbiAqIGB3aW5kb3dUaW1lU3BhbmAgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkluIGV2ZXJ5IHdpbmRvdyBvZiAxIHNlY29uZCBlYWNoLCBlbWl0IGF0IG1vc3QgMiBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dUaW1lKDEwMDApXG4gKiAgIC5tYXAod2luID0+IHdpbi50YWtlKDIpKSAvLyBlYWNoIHdpbmRvdyBoYXMgYXQgbW9zdCAyIGVtaXNzaW9uc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSA1IHNlY29uZHMgc3RhcnQgYSB3aW5kb3cgMSBzZWNvbmQgbG9uZywgYW5kIGVtaXQgYXQgbW9zdCAyIGNsaWNrIGV2ZW50cyBwZXIgd2luZG93PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VGltZSgxMDAwLCA1MDAwKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dXaGVufVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2luZG93VGltZVNwYW4gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGZpbGwgZWFjaCB3aW5kb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpbmRvd0NyZWF0aW9uSW50ZXJ2YWxdIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBuZXdcbiAqIHdpbmRvd3MuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAqIGludGVydmFscyB0aGF0IGRldGVybWluZSB3aW5kb3cgYm91bmRhcmllcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIG9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVyblxuICogYXJlIE9ic2VydmFibGVzLlxuICogQG1ldGhvZCB3aW5kb3dUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3dUaW1lKHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAod2luZG93Q3JlYXRpb25JbnRlcnZhbCA9PT0gdm9pZCAwKSB7IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgPSBudWxsOyB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaW5kb3dUaW1lT3BlcmF0b3Iod2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy53aW5kb3dUaW1lID0gd2luZG93VGltZTtcbnZhciBXaW5kb3dUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RpbWVPcGVyYXRvcih3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMud2luZG93VGltZVNwYW4gPSB3aW5kb3dUaW1lU3BhbjtcbiAgICAgICAgdGhpcy53aW5kb3dDcmVhdGlvbkludGVydmFsID0gd2luZG93Q3JlYXRpb25JbnRlcnZhbDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIFdpbmRvd1RpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpbmRvd1RpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMud2luZG93VGltZVNwYW4sIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1RpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1RpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB3aW5kb3dUaW1lU3Bhbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLndpbmRvd1RpbWVTcGFuID0gd2luZG93VGltZVNwYW47XG4gICAgICAgIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndpbmRvd3MgPSBbXTtcbiAgICAgICAgaWYgKHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgd2luZG93XzEgPSB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICAgICAgICAgIHZhciBjbG9zZVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCB3aW5kb3c6IHdpbmRvd18xLCBjb250ZXh0OiBudWxsIH07XG4gICAgICAgICAgICB2YXIgY3JlYXRpb25TdGF0ZSA9IHsgd2luZG93VGltZVNwYW46IHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsOiB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBzdWJzY3JpYmVyOiB0aGlzLCBzY2hlZHVsZXI6IHNjaGVkdWxlciB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q2xvc2UsIHdpbmRvd1RpbWVTcGFuLCBjbG9zZVN0YXRlKSk7XG4gICAgICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hXaW5kb3dDcmVhdGlvbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgY3JlYXRpb25TdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18yID0gdGhpcy5vcGVuV2luZG93KCk7XG4gICAgICAgICAgICB2YXIgdGltZVNwYW5Pbmx5U3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIHdpbmRvdzogd2luZG93XzIsIHdpbmRvd1RpbWVTcGFuOiB3aW5kb3dUaW1lU3BhbiB9O1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93VGltZVNwYW5Pbmx5LCB3aW5kb3dUaW1lU3BhbiwgdGltZVNwYW5Pbmx5U3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgICAgIHZhciBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHdpbmRvd18zID0gd2luZG93c1tpXTtcbiAgICAgICAgICAgIGlmICghd2luZG93XzMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93XzMubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvd180ID0gd2luZG93cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3dfNC5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dfNC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luZG93ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG4gICAgICAgIHRoaXMud2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9O1xuICAgIFdpbmRvd1RpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgICAgICB3aW5kb3dzLnNwbGljZSh3aW5kb3dzLmluZGV4T2Yod2luZG93KSwgMSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93VGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd1RpbWVTcGFuT25seShzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgd2luZG93VGltZVNwYW4gPSBzdGF0ZS53aW5kb3dUaW1lU3Bhbiwgd2luZG93ID0gc3RhdGUud2luZG93O1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIHN0YXRlLndpbmRvdyA9IHN1YnNjcmliZXIub3BlbldpbmRvdygpO1xuICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIHdpbmRvd1RpbWVTcGFuKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoV2luZG93Q3JlYXRpb24oc3RhdGUpIHtcbiAgICB2YXIgd2luZG93VGltZVNwYW4gPSBzdGF0ZS53aW5kb3dUaW1lU3Bhbiwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlciwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IHN0YXRlLndpbmRvd0NyZWF0aW9uSW50ZXJ2YWw7XG4gICAgdmFyIHdpbmRvdyA9IHN1YnNjcmliZXIub3BlbldpbmRvdygpO1xuICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgIHZhciBjb250ZXh0ID0geyBhY3Rpb246IGFjdGlvbiwgc3Vic2NyaXB0aW9uOiBudWxsIH07XG4gICAgdmFyIHRpbWVTcGFuU3RhdGUgPSB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIsIHdpbmRvdzogd2luZG93LCBjb250ZXh0OiBjb250ZXh0IH07XG4gICAgY29udGV4dC5zdWJzY3JpcHRpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hXaW5kb3dDbG9zZSwgd2luZG93VGltZVNwYW4sIHRpbWVTcGFuU3RhdGUpO1xuICAgIGFjdGlvbi5hZGQoY29udGV4dC5zdWJzY3JpcHRpb24pO1xuICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd0Nsb3NlKGFyZykge1xuICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXIsIHdpbmRvdyA9IGFyZy53aW5kb3csIGNvbnRleHQgPSBhcmcuY29udGV4dDtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmFjdGlvbiAmJiBjb250ZXh0LnN1YnNjcmlwdGlvbikge1xuICAgICAgICBjb250ZXh0LmFjdGlvbi5yZW1vdmUoY29udGV4dC5zdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyLmNsb3NlV2luZG93KHdpbmRvdyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aW5kb3dUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3dUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93VGltZSA9IHdpbmRvd1RpbWVfMS53aW5kb3dUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93VGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHN0YXJ0aW5nIGZyb21cbiAqIGFuIGVtaXNzaW9uIGZyb20gYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYFxuICogZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93VG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyB0aGF0IGNvbnRhaW4gdGhvc2UgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJldHdlZW4gdGhlIHRpbWUgd2hlbiB0aGUgYG9wZW5pbmdzYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtIGFuZCB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IG90aGVyIHNlY29uZCwgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgNTAwbXM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9wZW5pbmdzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApLm1lcmdlQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPE8+fSBvcGVuaW5ncyBBbiBvYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgdG8gc3RhcnQgbmV3XG4gKiB3aW5kb3dzLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogTyk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqIHRoZSB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBgb3BlbmluZ3NgIG9ic2VydmFibGUgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSxcbiAqIHdoaWNoLCB3aGVuIGl0IGVtaXRzIChlaXRoZXIgYG5leHRgIG9yIGBjb21wbGV0ZWApLCBzaWduYWxzIHRoYXQgdGhlXG4gKiBhc3NvY2lhdGVkIHdpbmRvdyBzaG91bGQgY29tcGxldGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93VG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aW5kb3dUb2dnbGUob3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpbmRvd1RvZ2dsZU9wZXJhdG9yKG9wZW5pbmdzLCBjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMud2luZG93VG9nZ2xlID0gd2luZG93VG9nZ2xlO1xudmFyIFdpbmRvd1RvZ2dsZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5kb3dUb2dnbGVPcGVyYXRvcihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgfVxuICAgIFdpbmRvd1RvZ2dsZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2luZG93VG9nZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9wZW5pbmdzLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1RvZ2dsZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2luZG93VG9nZ2xlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93VG9nZ2xlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb3BlbmluZ3MsIGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMub3BlbmluZ3MgPSBvcGVuaW5ncztcbiAgICAgICAgdGhpcy5jbG9zaW5nU2VsZWN0b3IgPSBjbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5vcGVuU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvcGVuaW5ncywgb3BlbmluZ3MpKTtcbiAgICB9XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRzW2ldLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2luZG93VG9nZ2xlU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnRleHQud2luZG93LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29udGV4dC53aW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29udGV4dC53aW5kb3cudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmIChvdXRlclZhbHVlID09PSB0aGlzLm9wZW5pbmdzKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ1NlbGVjdG9yID0gdGhpcy5jbG9zaW5nU2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY2xvc2luZ05vdGlmaWVyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjbG9zaW5nU2VsZWN0b3IpKGlubmVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsb3NpbmdOb3RpZmllciA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93XzEgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0geyB3aW5kb3c6IHdpbmRvd18xLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiB9O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllciwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh3aW5kb3dfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMuaW5kZXhPZihvdXRlclZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd1RvZ2dsZVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lcikge1xuICAgICAgICBpZiAoaW5uZXIgIT09IHRoaXMub3BlblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh0aGlzLmNvbnRleHRzLmluZGV4T2YoaW5uZXIuY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgIHZhciB3aW5kb3cgPSBjb250ZXh0LndpbmRvdywgc3Vic2NyaXB0aW9uID0gY29udGV4dC5zdWJzY3JpcHRpb247XG4gICAgICAgIGNvbnRleHRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHdpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1RvZ2dsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgd2luZG93VG9nZ2xlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aW5kb3dUb2dnbGUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dUb2dnbGUgPSB3aW5kb3dUb2dnbGVfMS53aW5kb3dUb2dnbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUb2dnbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQnJhbmNoIG91dCB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIGFzIGEgbmVzdGVkIE9ic2VydmFibGUgdXNpbmcgYVxuICogZmFjdG9yeSBmdW5jdGlvbiBvZiBjbG9zaW5nIE9ic2VydmFibGVzIHRvIGRldGVybWluZSB3aGVuIHRvIHN0YXJ0IGEgbmV3XG4gKiB3aW5kb3cuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyV2hlbn0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd1doZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyBjb25uZWN0ZWQsIG5vbi1vdmVybGFwcGluZyB3aW5kb3dzLlxuICogSXQgZW1pdHMgdGhlIGN1cnJlbnQgd2luZG93IGFuZCBvcGVucyBhIG5ldyBvbmUgd2hlbmV2ZXIgdGhlIE9ic2VydmFibGVcbiAqIHByb2R1Y2VkIGJ5IHRoZSBzcGVjaWZpZWQgYGNsb3NpbmdTZWxlY3RvcmAgZnVuY3Rpb24gZW1pdHMgYW4gaXRlbS4gVGhlIGZpcnN0XG4gKiB3aW5kb3cgaXMgb3BlbmVkIGltbWVkaWF0ZWx5IHdoZW4gc3Vic2NyaWJpbmcgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSB0aGUgZmlyc3QgdHdvIGNsaWNrcyBldmVudHMgaW4gZXZlcnkgd2luZG93IG9mIFsxLTVdIHJhbmRvbSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3NcbiAqICAgLndpbmRvd1doZW4oKCkgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwICsgTWF0aC5yYW5kb20oKSAqIDQwMDApKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2lnbmFscyAob24gZWl0aGVyIGBuZXh0YCBvclxuICogYGNvbXBsZXRlYCkgd2hlbiB0byBjbG9zZSB0aGUgcHJldmlvdXMgd2luZG93IGFuZCBzdGFydCBhIG5ldyBvbmUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2luZG93V2hlbihjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaW5kb3dPcGVyYXRvcihjbG9zaW5nU2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMud2luZG93V2hlbiA9IHdpbmRvd1doZW47XG52YXIgV2luZG93T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd09wZXJhdG9yKGNsb3NpbmdTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmNsb3NpbmdTZWxlY3RvciA9IGNsb3NpbmdTZWxlY3RvcjtcbiAgICB9XG4gICAgV2luZG93T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaW5kb3dTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjbG9zaW5nU2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuY2xvc2luZ1NlbGVjdG9yID0gY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coKTtcbiAgICB9XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3coaW5uZXJTdWIpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMub3BlbldpbmRvdyhpbm5lclN1Yik7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFdpbmRvd1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xvc2luZ05vdGlmaWNhdGlvbigpO1xuICAgIH07XG4gICAgV2luZG93U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndpbmRvdy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUNsb3NpbmdOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NpbmdOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5kb3dTdWJzY3JpYmVyLnByb3RvdHlwZS5vcGVuV2luZG93ID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIGlmIChpbm5lclN1YiA9PT0gdm9pZCAwKSB7IGlubmVyU3ViID0gbnVsbDsgfVxuICAgICAgICBpZiAoaW5uZXJTdWIpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgICAgIGlubmVyU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZXaW5kb3cgPSB0aGlzLndpbmRvdztcbiAgICAgICAgaWYgKHByZXZXaW5kb3cpIHtcbiAgICAgICAgICAgIHByZXZXaW5kb3cuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luZG93ID0gdGhpcy53aW5kb3cgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHdpbmRvdyk7XG4gICAgICAgIHZhciBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMuY2xvc2luZ1NlbGVjdG9yKSgpO1xuICAgICAgICBpZiAoY2xvc2luZ05vdGlmaWVyID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1doZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHdpbmRvd1doZW5fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3dpbmRvd1doZW4nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dXaGVuID0gd2luZG93V2hlbl8xLndpbmRvd1doZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dXaGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIG90aGVyIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlXG4gKiB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlcyBvZiBlYWNoLCBvbmx5IHdoZW4gdGhlXG4gKiBzb3VyY2UgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW5ldmVyIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBpdFxuICogY29tcHV0ZXMgYSBmb3JtdWxhIHVzaW5nIHRoYXQgdmFsdWUgcGx1cyB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIG90aGVyIGlucHV0XG4gKiBPYnNlcnZhYmxlcywgdGhlbiBlbWl0cyB0aGUgb3V0cHV0IG9mIHRoYXQgZm9ybXVsYS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aXRoTGF0ZXN0RnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgd2l0aExhdGVzdEZyb21gIGNvbWJpbmVzIGVhY2ggdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgKHRoZVxuICogaW5zdGFuY2UpIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgaW5wdXQgT2JzZXJ2YWJsZXMgb25seSB3aGVuXG4gKiB0aGUgc291cmNlIGVtaXRzIGEgdmFsdWUsIG9wdGlvbmFsbHkgdXNpbmcgYSBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdmFsdWUgdG8gYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIEFsbCBpbnB1dCBPYnNlcnZhYmxlcyBtdXN0XG4gKiBlbWl0IGF0IGxlYXN0IG9uZSB2YWx1ZSBiZWZvcmUgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBhIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk9uIGV2ZXJ5IGNsaWNrIGV2ZW50LCBlbWl0IGFuIGFycmF5IHdpdGggdGhlIGxhdGVzdCB0aW1lciBldmVudCBwbHVzIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aXRoTGF0ZXN0RnJvbSh0aW1lcik7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9qZWN0XSBQcm9qZWN0aW9uIGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgdmFsdWVzXG4gKiB0b2dldGhlci4gUmVjZWl2ZXMgYWxsIHZhbHVlcyBpbiBvcmRlciBvZiB0aGUgT2JzZXJ2YWJsZXMgcGFzc2VkLCB3aGVyZSB0aGVcbiAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiAoZS5nLlxuICogYGEud2l0aExhdGVzdEZyb20oYiwgYywgKGExLCBiMSwgYzEpID0+IGExICsgYjEgKyBjMSlgKS4gSWYgdGhpcyBpcyBub3RcbiAqIHBhc3NlZCwgYXJyYXlzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpdGhMYXRlc3RGcm9tXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0O1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2plY3QgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBhcmdzO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpdGhMYXRlc3RGcm9tT3BlcmF0b3Iob2JzZXJ2YWJsZXMsIHByb2plY3QpKTtcbn1cbmV4cG9ydHMud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbTtcbnZhciBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlcztcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgV2l0aExhdGVzdEZyb21PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVzLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb2JzZXJ2YWJsZXMsIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudG9SZXNwb25kID0gW107XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudG9SZXNwb25kLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHZhciB0b1Jlc3BvbmQgPSB0aGlzLnRvUmVzcG9uZDtcbiAgICAgICAgaWYgKHRvUmVzcG9uZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0b1Jlc3BvbmQuaW5kZXhPZihvdXRlckluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b1Jlc3BvbmQuc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50b1Jlc3BvbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFt2YWx1ZV0uY29uY2F0KHRoaXMudmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aXRoTGF0ZXN0RnJvbV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aXRoTGF0ZXN0RnJvbSA9IHdpdGhMYXRlc3RGcm9tXzEud2l0aExhdGVzdEZyb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoTGF0ZXN0RnJvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci96aXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS56aXAgPSB6aXBfMS56aXBQcm90bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4vemlwJyk7XG4vKipcbiAqIEBwYXJhbSBwcm9qZWN0XG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fFdlYlNvY2tldFN1YmplY3Q8VD58T2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgemlwQWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBBbGwocHJvamVjdCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IHppcF8xLlppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwQWxsID0gemlwQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB6aXBBbGxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3ppcEFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnppcEFsbCA9IHppcEFsbF8xLnppcEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcEFsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpcHRpb25Mb2cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbkxvZyhzdWJzY3JpYmVkRnJhbWUsIHVuc3Vic2NyaWJlZEZyYW1lKSB7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZWRGcmFtZSA9PT0gdm9pZCAwKSB7IHVuc3Vic2NyaWJlZEZyYW1lID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZEZyYW1lID0gc3Vic2NyaWJlZEZyYW1lO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlZEZyYW1lID0gdW5zdWJzY3JpYmVkRnJhbWU7XG4gICAgfVxuICAgIHJldHVybiBTdWJzY3JpcHRpb25Mb2c7XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25Mb2cgPSBTdWJzY3JpcHRpb25Mb2c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb25Mb2cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaXB0aW9uTG9nXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbkxvZycpO1xudmFyIFN1YnNjcmlwdGlvbkxvZ2dhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25Mb2dnYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIFN1YnNjcmlwdGlvbkxvZ2dhYmxlLnByb3RvdHlwZS5sb2dTdWJzY3JpYmVkRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb25Mb2dfMS5TdWJzY3JpcHRpb25Mb2codGhpcy5zY2hlZHVsZXIubm93KCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggLSAxO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uTG9nZ2FibGUucHJvdG90eXBlLmxvZ1Vuc3Vic2NyaWJlZEZyYW1lID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25Mb2dzID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgICAgICB2YXIgb2xkU3Vic2NyaXB0aW9uTG9nID0gc3Vic2NyaXB0aW9uTG9nc1tpbmRleF07XG4gICAgICAgIHN1YnNjcmlwdGlvbkxvZ3NbaW5kZXhdID0gbmV3IFN1YnNjcmlwdGlvbkxvZ18xLlN1YnNjcmlwdGlvbkxvZyhvbGRTdWJzY3JpcHRpb25Mb2cuc3Vic2NyaWJlZEZyYW1lLCB0aGlzLnNjaGVkdWxlci5ub3coKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uTG9nZ2FibGU7XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25Mb2dnYWJsZSA9IFN1YnNjcmlwdGlvbkxvZ2dhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uTG9nZ2FibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcHBseU1peGlucyhkZXJpdmVkQ3RvciwgYmFzZUN0b3JzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJhc2VDdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYmFzZUN0b3IgPSBiYXNlQ3RvcnNbaV07XG4gICAgICAgIHZhciBwcm9wZXJ0eUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlQ3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IHByb3BlcnR5S2V5cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBwcm9wZXJ0eUtleXNbal07XG4gICAgICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGVbbmFtZV8xXSA9IGJhc2VDdG9yLnByb3RvdHlwZVtuYW1lXzFdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5hcHBseU1peGlucyA9IGFwcGx5TWl4aW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlNaXhpbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBTdWJzY3JpcHRpb25Mb2dnYWJsZV8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb25Mb2dnYWJsZScpO1xudmFyIGFwcGx5TWl4aW5zXzEgPSByZXF1aXJlKCcuLi91dGlsL2FwcGx5TWl4aW5zJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENvbGRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29sZE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29sZE9ic2VydmFibGUobWVzc2FnZXMsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2YWJsZS5sb2dTdWJzY3JpYmVkRnJhbWUoKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUubG9nVW5zdWJzY3JpYmVkRnJhbWUoaW5kZXgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZS5zY2hlZHVsZU1lc3NhZ2VzKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgQ29sZE9ic2VydmFibGUucHJvdG90eXBlLnNjaGVkdWxlTWVzc2FnZXMgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgbWVzc2FnZXNMZW5ndGggPSB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbaV07XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZCh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm90aWZpY2F0aW9uLm9ic2VydmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICB9LCBtZXNzYWdlLmZyYW1lLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29sZE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbGRPYnNlcnZhYmxlID0gQ29sZE9ic2VydmFibGU7XG5hcHBseU1peGluc18xLmFwcGx5TWl4aW5zKENvbGRPYnNlcnZhYmxlLCBbU3Vic2NyaXB0aW9uTG9nZ2FibGVfMS5TdWJzY3JpcHRpb25Mb2dnYWJsZV0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sZE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciBTdWJzY3JpcHRpb25Mb2dnYWJsZV8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb25Mb2dnYWJsZScpO1xudmFyIGFwcGx5TWl4aW5zXzEgPSByZXF1aXJlKCcuLi91dGlsL2FwcGx5TWl4aW5zJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEhvdE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIb3RPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvdE9ic2VydmFibGUobWVzc2FnZXMsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIEhvdE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXM7XG4gICAgICAgIHZhciBpbmRleCA9IHN1YmplY3QubG9nU3Vic2NyaWJlZEZyYW1lKCk7XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3ViamVjdC5sb2dVbnN1YnNjcmliZWRGcmFtZShpbmRleCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgSG90T2JzZXJ2YWJsZS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcztcbiAgICAgICAgdmFyIG1lc3NhZ2VzTGVuZ3RoID0gc3ViamVjdC5tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXZhci1rZXl3b3JkICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHN1YmplY3QubWVzc2FnZXNbaV07XG4gICAgICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICAgICAgICAgIHN1YmplY3Quc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgbWVzc2FnZS5ub3RpZmljYXRpb24ub2JzZXJ2ZShzdWJqZWN0KTsgfSwgbWVzc2FnZS5mcmFtZSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSG90T2JzZXJ2YWJsZTtcbn0oU3ViamVjdF8xLlN1YmplY3QpKTtcbmV4cG9ydHMuSG90T2JzZXJ2YWJsZSA9IEhvdE9ic2VydmFibGU7XG5hcHBseU1peGluc18xLmFwcGx5TWl4aW5zKEhvdE9ic2VydmFibGUsIFtTdWJzY3JpcHRpb25Mb2dnYWJsZV8xLlN1YnNjcmlwdGlvbkxvZ2dhYmxlXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ib3RPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc3luY1NjaGVkdWxlcicpO1xudmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlydHVhbFRpbWVTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlydHVhbFRpbWVTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBtYXhGcmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKFNjaGVkdWxlckFjdGlvbiA9PT0gdm9pZCAwKSB7IFNjaGVkdWxlckFjdGlvbiA9IFZpcnR1YWxBY3Rpb247IH1cbiAgICAgICAgaWYgKG1heEZyYW1lcyA9PT0gdm9pZCAwKSB7IG1heEZyYW1lcyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBTY2hlZHVsZXJBY3Rpb24sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZyYW1lOyB9KTtcbiAgICAgICAgdGhpcy5tYXhGcmFtZXMgPSBtYXhGcmFtZXM7XG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb21wdCB0aGUgU2NoZWR1bGVyIHRvIGV4ZWN1dGUgYWxsIG9mIGl0cyBxdWV1ZWQgYWN0aW9ucywgdGhlcmVmb3JlXG4gICAgICogY2xlYXJpbmcgaXRzIHF1ZXVlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBhY3Rpb25zID0gX2EuYWN0aW9ucywgbWF4RnJhbWVzID0gX2EubWF4RnJhbWVzO1xuICAgICAgICB2YXIgZXJyb3IsIGFjdGlvbjtcbiAgICAgICAgd2hpbGUgKChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpICYmICh0aGlzLmZyYW1lID0gYWN0aW9uLmRlbGF5KSA8PSBtYXhGcmFtZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyLmZyYW1lVGltZUZhY3RvciA9IDEwO1xuICAgIHJldHVybiBWaXJ0dWFsVGltZVNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5WaXJ0dWFsVGltZVNjaGVkdWxlciA9IFZpcnR1YWxUaW1lU2NoZWR1bGVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBWaXJ0dWFsQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlydHVhbEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXJ0dWFsQWN0aW9uKHNjaGVkdWxlciwgd29yaywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBzY2hlZHVsZXIuaW5kZXggKz0gMTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ID0gc2NoZWR1bGVyLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIFZpcnR1YWxBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuICF0aGlzLmlkID9cbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpIDogdGhpcy5hZGQobmV3IFZpcnR1YWxBY3Rpb24odGhpcy5zY2hlZHVsZXIsIHRoaXMud29yaykpLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBWaXJ0dWFsQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgdGhpcy5kZWxheSA9IHNjaGVkdWxlci5mcmFtZSArIGRlbGF5O1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICBhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgIGFjdGlvbnMuc29ydChWaXJ0dWFsQWN0aW9uLnNvcnRBY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBWaXJ0dWFsQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFZpcnR1YWxBY3Rpb24uc29ydEFjdGlvbnMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5kZWxheSA9PT0gYi5kZWxheSkge1xuICAgICAgICAgICAgaWYgKGEuaW5kZXggPT09IGIuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kZWxheSA+IGIuZGVsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlydHVhbEFjdGlvbjtcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xuZXhwb3J0cy5WaXJ0dWFsQWN0aW9uID0gVmlydHVhbEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpcnR1YWxUaW1lU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG52YXIgQ29sZE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQ29sZE9ic2VydmFibGUnKTtcbnZhciBIb3RPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0hvdE9ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpcHRpb25Mb2dfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uTG9nJyk7XG52YXIgVmlydHVhbFRpbWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlcicpO1xudmFyIGRlZmF1bHRNYXhGcmFtZSA9IDc1MDtcbnZhciBUZXN0U2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVzdFNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXN0U2NoZWR1bGVyKGFzc2VydERlZXBFcXVhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBWaXJ0dWFsVGltZVNjaGVkdWxlcl8xLlZpcnR1YWxBY3Rpb24sIGRlZmF1bHRNYXhGcmFtZSk7XG4gICAgICAgIHRoaXMuYXNzZXJ0RGVlcEVxdWFsID0gYXNzZXJ0RGVlcEVxdWFsO1xuICAgICAgICB0aGlzLmhvdE9ic2VydmFibGVzID0gW107XG4gICAgICAgIHRoaXMuY29sZE9ic2VydmFibGVzID0gW107XG4gICAgICAgIHRoaXMuZmx1c2hUZXN0cyA9IFtdO1xuICAgIH1cbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5jcmVhdGVUaW1lID0gZnVuY3Rpb24gKG1hcmJsZXMpIHtcbiAgICAgICAgdmFyIGluZGV4T2YgPSBtYXJibGVzLmluZGV4T2YoJ3wnKTtcbiAgICAgICAgaWYgKGluZGV4T2YgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmJsZSBkaWFncmFtIGZvciB0aW1lIHNob3VsZCBoYXZlIGEgY29tcGxldGlvbiBtYXJrZXIgXCJ8XCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhPZiAqIFRlc3RTY2hlZHVsZXIuZnJhbWVUaW1lRmFjdG9yO1xuICAgIH07XG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuY3JlYXRlQ29sZE9ic2VydmFibGUgPSBmdW5jdGlvbiAobWFyYmxlcywgdmFsdWVzLCBlcnJvcikge1xuICAgICAgICBpZiAobWFyYmxlcy5pbmRleE9mKCdeJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGQgb2JzZXJ2YWJsZSBjYW5ub3QgaGF2ZSBzdWJzY3JpcHRpb24gb2Zmc2V0IFwiXlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmJsZXMuaW5kZXhPZignIScpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2xkIG9ic2VydmFibGUgY2Fubm90IGhhdmUgdW5zdWJzY3JpcHRpb24gbWFya2VyIFwiIVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gVGVzdFNjaGVkdWxlci5wYXJzZU1hcmJsZXMobWFyYmxlcywgdmFsdWVzLCBlcnJvcik7XG4gICAgICAgIHZhciBjb2xkID0gbmV3IENvbGRPYnNlcnZhYmxlXzEuQ29sZE9ic2VydmFibGUobWVzc2FnZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLmNvbGRPYnNlcnZhYmxlcy5wdXNoKGNvbGQpO1xuICAgICAgICByZXR1cm4gY29sZDtcbiAgICB9O1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmNyZWF0ZUhvdE9ic2VydmFibGUgPSBmdW5jdGlvbiAobWFyYmxlcywgdmFsdWVzLCBlcnJvcikge1xuICAgICAgICBpZiAobWFyYmxlcy5pbmRleE9mKCchJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hvdCBvYnNlcnZhYmxlIGNhbm5vdCBoYXZlIHVuc3Vic2NyaXB0aW9uIG1hcmtlciBcIiFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzKG1hcmJsZXMsIHZhbHVlcywgZXJyb3IpO1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBIb3RPYnNlcnZhYmxlXzEuSG90T2JzZXJ2YWJsZShtZXNzYWdlcywgdGhpcyk7XG4gICAgICAgIHRoaXMuaG90T2JzZXJ2YWJsZXMucHVzaChzdWJqZWN0KTtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5tYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlLCBvdXRlckZyYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyBmcmFtZTogX3RoaXMuZnJhbWUgLSBvdXRlckZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaCh7IGZyYW1lOiBfdGhpcy5mcmFtZSAtIG91dGVyRnJhbWUsIG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyBmcmFtZTogX3RoaXMuZnJhbWUgLSBvdXRlckZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH07XG4gICAgVGVzdFNjaGVkdWxlci5wcm90b3R5cGUuZXhwZWN0T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlLCB1bnN1YnNjcmlwdGlvbk1hcmJsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHVuc3Vic2NyaXB0aW9uTWFyYmxlcyA9PT0gdm9pZCAwKSB7IHVuc3Vic2NyaXB0aW9uTWFyYmxlcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGFjdHVhbCA9IFtdO1xuICAgICAgICB2YXIgZmx1c2hUZXN0ID0geyBhY3R1YWw6IGFjdHVhbCwgcmVhZHk6IGZhbHNlIH07XG4gICAgICAgIHZhciB1bnN1YnNjcmlwdGlvbkZyYW1lID0gVGVzdFNjaGVkdWxlclxuICAgICAgICAgICAgLnBhcnNlTWFyYmxlc0FzU3Vic2NyaXB0aW9ucyh1bnN1YnNjcmlwdGlvbk1hcmJsZXMpLnVuc3Vic2NyaWJlZEZyYW1lO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0geDtcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAgICAgICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMubWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGUodmFsdWUsIF90aGlzLmZyYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0dWFsLnB1c2goeyBmcmFtZTogX3RoaXMuZnJhbWUsIG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGFjdHVhbC5wdXNoKHsgZnJhbWU6IF90aGlzLmZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFjdHVhbC5wdXNoKHsgZnJhbWU6IF90aGlzLmZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAodW5zdWJzY3JpcHRpb25GcmFtZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9LCB1bnN1YnNjcmlwdGlvbkZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoVGVzdHMucHVzaChmbHVzaFRlc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9CZTogZnVuY3Rpb24gKG1hcmJsZXMsIHZhbHVlcywgZXJyb3JWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZsdXNoVGVzdC5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmx1c2hUZXN0LmV4cGVjdGVkID0gVGVzdFNjaGVkdWxlci5wYXJzZU1hcmJsZXMobWFyYmxlcywgdmFsdWVzLCBlcnJvclZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRlc3RTY2hlZHVsZXIucHJvdG90eXBlLmV4cGVjdFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoYWN0dWFsU3Vic2NyaXB0aW9uTG9ncykge1xuICAgICAgICB2YXIgZmx1c2hUZXN0ID0geyBhY3R1YWw6IGFjdHVhbFN1YnNjcmlwdGlvbkxvZ3MsIHJlYWR5OiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmZsdXNoVGVzdHMucHVzaChmbHVzaFRlc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9CZTogZnVuY3Rpb24gKG1hcmJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFyYmxlc0FycmF5ID0gKHR5cGVvZiBtYXJibGVzID09PSAnc3RyaW5nJykgPyBbbWFyYmxlc10gOiBtYXJibGVzO1xuICAgICAgICAgICAgICAgIGZsdXNoVGVzdC5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmx1c2hUZXN0LmV4cGVjdGVkID0gbWFyYmxlc0FycmF5Lm1hcChmdW5jdGlvbiAobWFyYmxlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGVzdFNjaGVkdWxlci5wYXJzZU1hcmJsZXNBc1N1YnNjcmlwdGlvbnMobWFyYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUZXN0U2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhvdE9ic2VydmFibGVzID0gdGhpcy5ob3RPYnNlcnZhYmxlcztcbiAgICAgICAgd2hpbGUgKGhvdE9ic2VydmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGhvdE9ic2VydmFibGVzLnNoaWZ0KCkuc2V0dXAoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciByZWFkeUZsdXNoVGVzdHMgPSB0aGlzLmZsdXNoVGVzdHMuZmlsdGVyKGZ1bmN0aW9uICh0ZXN0KSB7IHJldHVybiB0ZXN0LnJlYWR5OyB9KTtcbiAgICAgICAgd2hpbGUgKHJlYWR5Rmx1c2hUZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdGVzdCA9IHJlYWR5Rmx1c2hUZXN0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnREZWVwRXF1YWwodGVzdC5hY3R1YWwsIHRlc3QuZXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXN0U2NoZWR1bGVyLnBhcnNlTWFyYmxlc0FzU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uIChtYXJibGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWFyYmxlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uTG9nXzEuU3Vic2NyaXB0aW9uTG9nKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IG1hcmJsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgZ3JvdXBTdGFydCA9IC0xO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uRnJhbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciB1bnN1YnNjcmlwdGlvbkZyYW1lID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBpICogdGhpcy5mcmFtZVRpbWVGYWN0b3I7XG4gICAgICAgICAgICB2YXIgYyA9IG1hcmJsZXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU3RhcnQgPSBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25GcmFtZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZvdW5kIGEgc2Vjb25kIHN1YnNjcmlwdGlvbiBwb2ludCBcXCdeXFwnIGluIGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbiBtYXJibGUgZGlhZ3JhbS4gVGhlcmUgY2FuIG9ubHkgYmUgb25lLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkZyYW1lID0gZ3JvdXBTdGFydCA+IC0xID8gZ3JvdXBTdGFydCA6IGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuc3Vic2NyaXB0aW9uRnJhbWUgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3VuZCBhIHNlY29uZCBzdWJzY3JpcHRpb24gcG9pbnQgXFwnXlxcJyBpbiBhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJzY3JpcHRpb24gbWFyYmxlIGRpYWdyYW0uIFRoZXJlIGNhbiBvbmx5IGJlIG9uZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmlwdGlvbkZyYW1lID0gZ3JvdXBTdGFydCA+IC0xID8gZ3JvdXBTdGFydCA6IGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZXJlIGNhbiBvbmx5IGJlIFxcJ15cXCcgYW5kIFxcJyFcXCcgbWFya2VycyBpbiBhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbiBtYXJibGUgZGlhZ3JhbS4gRm91bmQgaW5zdGVhZCBcXCcnICsgYyArICdcXCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3Vic2NyaXB0aW9uRnJhbWUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkxvZ18xLlN1YnNjcmlwdGlvbkxvZyhzdWJzY3JpcHRpb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkxvZ18xLlN1YnNjcmlwdGlvbkxvZyhzdWJzY3JpcHRpb25GcmFtZSwgdW5zdWJzY3JpcHRpb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzID0gZnVuY3Rpb24gKG1hcmJsZXMsIHZhbHVlcywgZXJyb3JWYWx1ZSwgbWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzKSB7XG4gICAgICAgIGlmIChtYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZXMgPT09IHZvaWQgMCkgeyBtYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobWFyYmxlcy5pbmRleE9mKCchJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlbnRpb25hbCBtYXJibGUgZGlhZ3JhbXMgY2Fubm90IGhhdmUgdGhlICcgK1xuICAgICAgICAgICAgICAgICd1bnN1YnNjcmlwdGlvbiBtYXJrZXIgXCIhXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gbWFyYmxlcy5sZW5ndGg7XG4gICAgICAgIHZhciB0ZXN0TWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdmFyIHN1YkluZGV4ID0gbWFyYmxlcy5pbmRleE9mKCdeJyk7XG4gICAgICAgIHZhciBmcmFtZU9mZnNldCA9IHN1YkluZGV4ID09PSAtMSA/IDAgOiAoc3ViSW5kZXggKiAtdGhpcy5mcmFtZVRpbWVGYWN0b3IpO1xuICAgICAgICB2YXIgZ2V0VmFsdWUgPSB0eXBlb2YgdmFsdWVzICE9PSAnb2JqZWN0JyA/XG4gICAgICAgICAgICBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6XG4gICAgICAgICAgICBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICAgICAgICAgICAgICAgIGlmIChtYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZXMgJiYgdmFsdWVzW3hdIGluc3RhbmNlb2YgQ29sZE9ic2VydmFibGVfMS5Db2xkT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW3hdLm1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW3hdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIGdyb3VwU3RhcnQgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gaSAqIHRoaXMuZnJhbWVUaW1lRmFjdG9yICsgZnJhbWVPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGMgPSBtYXJibGVzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgICAgICBncm91cFN0YXJ0ID0gZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgICAgICBncm91cFN0YXJ0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24gPSBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24gPSBOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlRXJyb3IoZXJyb3JWYWx1ZSB8fCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQoZ2V0VmFsdWUoYykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0ZXN0TWVzc2FnZXMucHVzaCh7IGZyYW1lOiBncm91cFN0YXJ0ID4gLTEgPyBncm91cFN0YXJ0IDogZnJhbWUsIG5vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXN0TWVzc2FnZXM7XG4gICAgfTtcbiAgICByZXR1cm4gVGVzdFNjaGVkdWxlcjtcbn0oVmlydHVhbFRpbWVTY2hlZHVsZXJfMS5WaXJ0dWFsVGltZVNjaGVkdWxlcikpO1xuZXhwb3J0cy5UZXN0U2NoZWR1bGVyID0gVGVzdFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRlc3RTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbihyb290KSB7XG4gICAgICAgIGlmIChyb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3QubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3Qud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcm9vdC5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290Lm9DYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290LmNsZWFyVGltZW91dC5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIHJvb3Quc2V0VGltZW91dChjYiwgMTAwMCAvIDYwKTsgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbjtcbn0oKSk7XG5leHBvcnRzLlJlcXVlc3RBbmltYXRpb25GcmFtZURlZmluaXRpb24gPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVEZWZpbml0aW9uO1xuZXhwb3J0cy5BbmltYXRpb25GcmFtZSA9IG5ldyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVEZWZpbml0aW9uKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkZyYW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbnZhciBBbmltYXRpb25GcmFtZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9BbmltYXRpb25GcmFtZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBbmltYXRpb25GcmFtZUFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGlvbkZyYW1lQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkZyYW1lQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICB9XG4gICAgQW5pbWF0aW9uRnJhbWVBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBpcyBncmVhdGVyIHRoYW4gMCwgcmVxdWVzdCBhcyBhbiBhc3luYyBhY3Rpb24uXG4gICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1c2ggdGhlIGFjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgcXVldWUuXG4gICAgICAgIHNjaGVkdWxlci5hY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgIC8vIElmIGFuIGFuaW1hdGlvbiBmcmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCwgZG9uJ3QgcmVxdWVzdCBhbm90aGVyXG4gICAgICAgIC8vIG9uZS4gSWYgYW4gYW5pbWF0aW9uIGZyYW1lIGhhc24ndCBiZWVuIHJlcXVlc3RlZCB5ZXQsIHJlcXVlc3Qgb25lLiBSZXR1cm5cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QgaWQuXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVkIHx8IChzY2hlZHVsZXIuc2NoZWR1bGVkID0gQW5pbWF0aW9uRnJhbWVfMS5BbmltYXRpb25GcmFtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCBudWxsKSkpO1xuICAgIH07XG4gICAgQW5pbWF0aW9uRnJhbWVBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgICAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNjaGVkdWxlciBxdWV1ZSBpcyBlbXB0eSwgY2FuY2VsIHRoZSByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIGFuZFxuICAgICAgICAvLyBzZXQgdGhlIHNjaGVkdWxlZCBmbGFnIHRvIHVuZGVmaW5lZCBzbyB0aGUgbmV4dCBBbmltYXRpb25GcmFtZUFjdGlvbiB3aWxsXG4gICAgICAgIC8vIHJlcXVlc3QgaXRzIG93bi5cbiAgICAgICAgaWYgKHNjaGVkdWxlci5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgQW5pbWF0aW9uRnJhbWVfMS5BbmltYXRpb25GcmFtZS5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgc28gdGhlIGFjdGlvbiBrbm93cyB0byByZXF1ZXN0IGEgbmV3IGFzeW5jIGlkIGlmIGl0J3MgcmVzY2hlZHVsZWQuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRnJhbWVBY3Rpb247XG59KEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pKTtcbmV4cG9ydHMuQW5pbWF0aW9uRnJhbWVBY3Rpb24gPSBBbmltYXRpb25GcmFtZUFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkZyYW1lQWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vQXN5bmNTY2hlZHVsZXInKTtcbnZhciBBbmltYXRpb25GcmFtZVNjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGNvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbiB8fCBhY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXI7XG59KEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIpKTtcbmV4cG9ydHMuQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgPSBBbmltYXRpb25GcmFtZVNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFuaW1hdGlvbkZyYW1lQWN0aW9uXzEgPSByZXF1aXJlKCcuL0FuaW1hdGlvbkZyYW1lQWN0aW9uJyk7XG52YXIgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXInKTtcbmV4cG9ydHMuYW5pbWF0aW9uRnJhbWUgPSBuZXcgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXJfMS5BbmltYXRpb25GcmFtZVNjaGVkdWxlcihBbmltYXRpb25GcmFtZUFjdGlvbl8xLkFuaW1hdGlvbkZyYW1lQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbkZyYW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG4vLyBTdWJqZWN0IGltcG9ydGVkIGJlZm9yZSBPYnNlcnZhYmxlIHRvIGJ5cGFzcyBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHNpbmNlXG4vLyBTdWJqZWN0IGV4dGVuZHMgT2JzZXJ2YWJsZSBhbmQgT2JzZXJ2YWJsZSByZWZlcmVuY2VzIFN1YmplY3QgaW4gaXQnc1xuLy8gZGVmaW5pdGlvblxudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4vU3ViamVjdCcpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdF8xLlN1YmplY3Q7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBTdWJqZWN0XzEuQW5vbnltb3VzU3ViamVjdDtcbi8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZTtcbi8vIHN0YXRpY3Ncbi8qIHRzbGludDpkaXNhYmxlOm5vLXVzZS1iZWZvcmUtZGVjbGFyZSAqL1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2snKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjaycpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2NvbmNhdCcpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9kZWZlcicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9lbXB0eScpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbicpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9mcm9tJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCcpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2dlbmVyYXRlJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2lmJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL2ludGVydmFsJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL21lcmdlJyk7XG5yZXF1aXJlKCcuL2FkZC9vYnNlcnZhYmxlL3JhY2UnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvbmV2ZXInKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvb2YnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvcGFpcnMnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvcmFuZ2UnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvdXNpbmcnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvdGhyb3cnKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvdGltZXInKTtcbnJlcXVpcmUoJy4vYWRkL29ic2VydmFibGUvemlwJyk7XG4vL2RvbVxucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheCcpO1xucmVxdWlyZSgnLi9hZGQvb2JzZXJ2YWJsZS9kb20vd2ViU29ja2V0Jyk7XG4vL29wZXJhdG9yc1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvYnVmZmVyJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXJDb3VudCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvYnVmZmVyVGltZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jYXRjaCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29tYmluZUFsbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29tYmluZUxhdGVzdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29uY2F0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9jb25jYXRBbGwnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NvbmNhdE1hcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvY29uY2F0TWFwVG8nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2NvdW50Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZW1hdGVyaWFsaXplJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZWJvdW5jZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGVsYXknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2RlbGF5V2hlbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZGlzdGluY3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxDaGFuZ2VkJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZG8nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2V4aGF1c3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2V4aGF1c3RNYXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2V4cGFuZCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZWxlbWVudEF0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9maWx0ZXInKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2ZpbmFsbHknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2ZpbmQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2ZpbmRJbmRleCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvZmlyc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2dyb3VwQnknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2lnbm9yZUVsZW1lbnRzJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9pc0VtcHR5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9hdWRpdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvYXVkaXRUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9sYXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9sZXQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL2V2ZXJ5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tYXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21hcFRvJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWF4Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tZXJnZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21lcmdlTWFwJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tZXJnZU1hcFRvJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9tZXJnZVNjYW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL21pbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvbXVsdGljYXN0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9vYnNlcnZlT24nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wYWlyd2lzZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcGFydGl0aW9uJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wbHVjaycpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcHVibGlzaCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wdWJsaXNoUmVwbGF5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9wdWJsaXNoTGFzdCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcmFjZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvcmVkdWNlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9yZXBlYXQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3JlcGVhdFdoZW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3JldHJ5Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9yZXRyeVdoZW4nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NhbXBsZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2FtcGxlVGltZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2NhbicpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2hhcmUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3NpbmdsZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2tpcCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc2tpcFVudGlsJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9za2lwV2hpbGUnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3N0YXJ0V2l0aCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc3Vic2NyaWJlT24nKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3N3aXRjaCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXBUbycpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGFrZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGFrZUxhc3QnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3Rha2VVbnRpbCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGFrZVdoaWxlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90aHJvdHRsZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvdGhyb3R0bGVUaW1lJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90aW1lSW50ZXJ2YWwnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RpbWVvdXQnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RpbWVvdXRXaXRoJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci90aW1lc3RhbXAnKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RvQXJyYXknKTtcbnJlcXVpcmUoJy4vYWRkL29wZXJhdG9yL3RvUHJvbWlzZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivd2luZG93Jyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudCcpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivd2luZG93VGltZScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3Ivd2luZG93VG9nZ2xlJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aW5kb3dXaGVuJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbScpO1xucmVxdWlyZSgnLi9hZGQvb3BlcmF0b3IvemlwJyk7XG5yZXF1aXJlKCcuL2FkZC9vcGVyYXRvci96aXBBbGwnKTtcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuZXhwb3J0cy5TdWJzY3JpYmVyID0gU3Vic2NyaWJlcl8xLlN1YnNjcmliZXI7XG52YXIgQXN5bmNTdWJqZWN0XzEgPSByZXF1aXJlKCcuL0FzeW5jU3ViamVjdCcpO1xuZXhwb3J0cy5Bc3luY1N1YmplY3QgPSBBc3luY1N1YmplY3RfMS5Bc3luY1N1YmplY3Q7XG52YXIgUmVwbGF5U3ViamVjdF8xID0gcmVxdWlyZSgnLi9SZXBsYXlTdWJqZWN0Jyk7XG5leHBvcnRzLlJlcGxheVN1YmplY3QgPSBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdDtcbnZhciBCZWhhdmlvclN1YmplY3RfMSA9IHJlcXVpcmUoJy4vQmVoYXZpb3JTdWJqZWN0Jyk7XG5leHBvcnRzLkJlaGF2aW9yU3ViamVjdCA9IEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdDtcbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUnKTtcbmV4cG9ydHMuQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gQ29ubmVjdGFibGVPYnNlcnZhYmxlXzEuQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi9Ob3RpZmljYXRpb24nKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uO1xudmFyIEVtcHR5RXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9FbXB0eUVycm9yJyk7XG5leHBvcnRzLkVtcHR5RXJyb3IgPSBFbXB0eUVycm9yXzEuRW1wdHlFcnJvcjtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG5leHBvcnRzLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG5leHBvcnRzLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbnZhciBUaW1lb3V0RXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9UaW1lb3V0RXJyb3InKTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yXzEuVGltZW91dEVycm9yO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yJyk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcjtcbnZhciB0aW1lSW50ZXJ2YWxfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3IvdGltZUludGVydmFsJyk7XG5leHBvcnRzLlRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbF8xLlRpbWVJbnRlcnZhbDtcbnZhciB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoJy4vb3BlcmF0b3IvdGltZXN0YW1wJyk7XG5leHBvcnRzLlRpbWVzdGFtcCA9IHRpbWVzdGFtcF8xLlRpbWVzdGFtcDtcbnZhciBUZXN0U2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL3Rlc3RpbmcvVGVzdFNjaGVkdWxlcicpO1xuZXhwb3J0cy5UZXN0U2NoZWR1bGVyID0gVGVzdFNjaGVkdWxlcl8xLlRlc3RTY2hlZHVsZXI7XG52YXIgVmlydHVhbFRpbWVTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vc2NoZWR1bGVyL1ZpcnR1YWxUaW1lU2NoZWR1bGVyJyk7XG5leHBvcnRzLlZpcnR1YWxUaW1lU2NoZWR1bGVyID0gVmlydHVhbFRpbWVTY2hlZHVsZXJfMS5WaXJ0dWFsVGltZVNjaGVkdWxlcjtcbnZhciBBamF4T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9vYnNlcnZhYmxlL2RvbS9BamF4T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5BamF4UmVzcG9uc2UgPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhSZXNwb25zZTtcbmV4cG9ydHMuQWpheEVycm9yID0gQWpheE9ic2VydmFibGVfMS5BamF4RXJyb3I7XG5leHBvcnRzLkFqYXhUaW1lb3V0RXJyb3IgPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhUaW1lb3V0RXJyb3I7XG52YXIgYXNhcF8xID0gcmVxdWlyZSgnLi9zY2hlZHVsZXIvYXNhcCcpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuL3NjaGVkdWxlci9hc3luYycpO1xudmFyIHF1ZXVlXzEgPSByZXF1aXJlKCcuL3NjaGVkdWxlci9xdWV1ZScpO1xudmFyIGFuaW1hdGlvbkZyYW1lXzEgPSByZXF1aXJlKCcuL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZScpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgb2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUnguU2NoZWR1bGVyXG4gKiBAcHJvcGVydHkge1NjaGVkdWxlcn0gcXVldWUgU2NoZWR1bGVzIG9uIGEgcXVldWUgaW4gdGhlIGN1cnJlbnQgZXZlbnQgZnJhbWVcbiAqICh0cmFtcG9saW5lIHNjaGVkdWxlcikuIFVzZSB0aGlzIGZvciBpdGVyYXRpb24gb3BlcmF0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBhc2FwIFNjaGVkdWxlcyBvbiB0aGUgbWljcm8gdGFzayBxdWV1ZSwgd2hpY2ggdXNlcyB0aGVcbiAqIGZhc3Rlc3QgdHJhbnNwb3J0IG1lY2hhbmlzbSBhdmFpbGFibGUsIGVpdGhlciBOb2RlLmpzJyBgcHJvY2Vzcy5uZXh0VGljaygpYFxuICogb3IgV2ViIFdvcmtlciBNZXNzYWdlQ2hhbm5lbCBvciBzZXRUaW1lb3V0IG9yIG90aGVycy4gVXNlIHRoaXMgZm9yXG4gKiBhc3luY2hyb25vdXMgY29udmVyc2lvbnMuXG4gKiBAcHJvcGVydHkge1NjaGVkdWxlcn0gYXN5bmMgU2NoZWR1bGVzIHdvcmsgd2l0aCBgc2V0SW50ZXJ2YWxgLiBVc2UgdGhpcyBmb3JcbiAqIHRpbWUtYmFzZWQgb3BlcmF0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBhbmltYXRpb25GcmFtZSBTY2hlZHVsZXMgd29yayB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICogVXNlIHRoaXMgZm9yIHN5bmNocm9uaXppbmcgd2l0aCB0aGUgcGxhdGZvcm0ncyBwYWludGluZ1xuICovXG52YXIgU2NoZWR1bGVyID0ge1xuICAgIGFzYXA6IGFzYXBfMS5hc2FwLFxuICAgIHF1ZXVlOiBxdWV1ZV8xLnF1ZXVlLFxuICAgIGFuaW1hdGlvbkZyYW1lOiBhbmltYXRpb25GcmFtZV8xLmFuaW1hdGlvbkZyYW1lLFxuICAgIGFzeW5jOiBhc3luY18xLmFzeW5jXG59O1xuZXhwb3J0cy5TY2hlZHVsZXIgPSBTY2hlZHVsZXI7XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJ4LlN5bWJvbFxuICogQHByb3BlcnR5IHtTeW1ib2x8c3RyaW5nfSByeFN1YnNjcmliZXIgQSBzeW1ib2wgdG8gdXNlIGFzIGEgcHJvcGVydHkgbmFtZSB0b1xuICogcmV0cmlldmUgYW4gXCJSeCBzYWZlXCIgT2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3QuIFwiUnggc2FmZXR5XCIgY2FuIGJlIGRlZmluZWQgYXNcbiAqIGFuIG9iamVjdCB0aGF0IGhhcyBhbGwgb2YgdGhlIHRyYWl0cyBvZiBhbiBSeCBTdWJzY3JpYmVyLCBpbmNsdWRpbmcgdGhlXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHN1YnNjcmlwdGlvbiBjaGFpbiBhbmRcbiAqIGd1YXJhbnRlZXMgaW52b2x2aW5nIGV2ZW50IHRyaWdnZXJpbmcgKGNhbid0IFwibmV4dFwiIGFmdGVyIHVuc3Vic2NyaXB0aW9uLFxuICogZXRjKS5cbiAqIEBwcm9wZXJ0eSB7U3ltYm9sfHN0cmluZ30gb2JzZXJ2YWJsZSBBIHN5bWJvbCB0byB1c2UgYXMgYSBwcm9wZXJ0eSBuYW1lIHRvXG4gKiByZXRyaWV2ZSBhbiBPYnNlcnZhYmxlIGFzIGRlZmluZWQgYnkgdGhlIFtFQ01BU2NyaXB0IFwiT2JzZXJ2YWJsZVwiIHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGUpLlxuICogQHByb3BlcnR5IHtTeW1ib2x8c3RyaW5nfSBpdGVyYXRvciBUaGUgRVM2IHN5bWJvbCB0byB1c2UgYXMgYSBwcm9wZXJ0eSBuYW1lXG4gKiB0byByZXRyaWV2ZSBhbiBpdGVyYXRvciBmcm9tIGFuIG9iamVjdC5cbiAqL1xudmFyIFN5bWJvbCA9IHtcbiAgICByeFN1YnNjcmliZXI6IHJ4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyLFxuICAgIG9ic2VydmFibGU6IG9ic2VydmFibGVfMS4kJG9ic2VydmFibGUsXG4gICAgaXRlcmF0b3I6IGl0ZXJhdG9yXzEuJCRpdGVyYXRvclxufTtcbmV4cG9ydHMuU3ltYm9sID0gU3ltYm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UnguanMubWFwIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAnLi4vLi4vc3JjL2luZGV4LmpzJ1xuaW1wb3J0IFdlYlNvY2tldCBmcm9tICdyZWNvbm5lY3Rpbmctd2Vic29ja2V0J1xuaW1wb3J0IFJ4IGZyb20gJ3J4anMvUngnXG5cbi8vIFN0cmVhbXNcbmxldCBhY3Rpb25zJCA9IG5ldyBSeC5TdWJqZWN0KClcbmxldCBzb2NrZXRPdXRnb2luZyQgPSBuZXcgUnguU3ViamVjdCgpXG5cbi8vIE1vZGVsXG5sZXQgaW5pdE1vZGVsID0ge3RleHQ6ICcnLCBtZXNzYWdlczogW10sIGNvbm5lY3RlZDogZmFsc2V9XG5cbi8vIFVwZGF0ZVxuZnVuY3Rpb24gdXBkYXRlKG1vZGVsLCBbYWN0aW9uLCB2YWx1ZV0pIHtcbiAgbGV0IHt0ZXh0LCBtZXNzYWdlcywgY29ubmVjdGVkfSA9IG1vZGVsXG5cbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgIHJldHVybiB7Li4ubW9kZWwsIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIHZhbHVlXX1cbiAgICBjYXNlICdjaGFuZ2VUZXh0JzpcbiAgICAgIHJldHVybiB7Li4ubW9kZWwsIHRleHQ6IHZhbHVlfVxuICAgIGNhc2UgJ2NsZWFyVGV4dCc6XG4gICAgICByZXR1cm4gey4uLm1vZGVsLCB0ZXh0OiAnJ31cbiAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgcmV0dXJuIHsuLi5tb2RlbCwgY29ubmVjdGVkOiB2YWx1ZX1cbiAgfVxufVxuXG4vLyBWaWV3XG5mdW5jdGlvbiB2aWV3KHt0ZXh0LCBtZXNzYWdlcywgY29ubmVjdGVkfSkge1xuICBsZXQgdiA9XG4gICAgWydkaXYnLCB7fSxcbiAgICAgIFsgWydpbnB1dCcsIHtwcm9wczoge3BsYWNlaG9sZGVyOiAnU2VuZCBtZXNzYWdlJywgYXV0b2ZvY3VzOiB0cnVlLCB2YWx1ZTogdGV4dH0sXG4gICAgICAgICAgICAgICAgICAgb246IHtpbnB1dDogaGFuZGxlSW5wdXR9LCBob29rOiB7cG9zdHBhdGNoOiBmb2N1c0VsZW1lbnR9fV0sXG4gICAgICAgIFsnYnV0dG9uJywge3Byb3BzOiB7ZGlzYWJsZWQ6ICFjb25uZWN0ZWR9LCBvbjoge2NsaWNrOiBbaGFuZGxlQ2xpY2ssIHRleHRdfX0sICdTZW5kJ10sXG4gICAgICAgIFsnc3BhbicsIHt9LCBjb25uZWN0ZWQgPyAnJyA6ICcgQ29ubmVjdGluZy4uLiddLFxuICAgICAgICBbJ2RpdicsIHtzdHlsZToge3BhZGRpbmdUb3A6ICc3cHgnfX0sIG1lc3NhZ2VzLm1hcChkaXNwbGF5TWVzc2FnZSldXV1cblxuICByZXR1cm4gdlxufVxuXG5mdW5jdGlvbiBmb2N1c0VsZW1lbnQob2xkVm5vZGUsIHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5lbG0uZm9jdXMoKVxufVxuXG5mdW5jdGlvbiBkaXNwbGF5TWVzc2FnZShtc2cpIHtcbiAgcmV0dXJuIFsnZGl2Jywge30sIG1zZ11cbn1cblxuZnVuY3Rpb24gaGFuZGxlSW5wdXQoZSkge1xuICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZS50cmltKClcbiAgYWN0aW9ucyQubmV4dChbJ2NoYW5nZVRleHQnLCB2YWx1ZV0pXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHRleHQpIHtcbiAgYWN0aW9ucyQubmV4dChbJ2NsZWFyVGV4dCddKVxuICBzb2NrZXRPdXRnb2luZyQubmV4dCh0ZXh0KVxufVxuXG4vLyBXZWJzb2NrZXRcbmxldCB3cyA9IG5ldyBXZWJTb2NrZXQoJ3dzczovL2VjaG8ud2Vic29ja2V0Lm9yZycpXG5cbmxldCBvbmxpbmUkID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApXG4gIC5tYXAoKCkgPT4gbmF2aWdhdG9yLm9uTGluZSlcbiAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKClcblxubGV0IHNvY2tldENvbm5lY3RlZCQgPSBSeC5PYnNlcnZhYmxlLmNyZWF0ZShzdWJzY3JpYmVyID0+IHtcbiAgd3Mub25vcGVuID0gKCkgPT4gc3Vic2NyaWJlci5uZXh0KHRydWUpXG4gIHdzLm9uY2xvc2UgPSAoKSA9PiBzdWJzY3JpYmVyLm5leHQoZmFsc2UpXG59KVxuXG5sZXQgY29ubmVjdGVkJCA9IHNvY2tldENvbm5lY3RlZCRcbiAgLmNvbWJpbmVMYXRlc3Qob25saW5lJCwgKGNvbm5lY3RlZCwgb25saW5lKSA9PiBjb25uZWN0ZWQgJiYgb25saW5lKVxuICAucHVibGlzaEJlaGF2aW9yKGZhbHNlKVxuICAucmVmQ291bnQoKVxuXG5zb2NrZXRPdXRnb2luZyRcbiAgLndpdGhMYXRlc3RGcm9tKGNvbm5lY3RlZCQsIChtc2csIGNvbm5lY3RlZCkgPT4gW21zZywgY29ubmVjdGVkXSlcbiAgLmZpbHRlcigoWywgY29ubmVjdGVkXSkgPT4gY29ubmVjdGVkKVxuICAuc3Vic2NyaWJlKChbbXNnXSkgPT4gd3Muc2VuZChtc2cpKVxuXG5sZXQgc29ja2V0SW5jb21pbmckID0gUnguT2JzZXJ2YWJsZS5jcmVhdGUoc3Vic2NyaWJlciA9PiB7XG4gIHdzLm9ubWVzc2FnZSA9IG1zZyA9PiBzdWJzY3JpYmVyLm5leHQobXNnKVxufSlcblxubGV0IGVmZmVjdHMkID0gc29ja2V0SW5jb21pbmckXG4gIC5tYXAobXNnRXZlbnQgPT4gWydtZXNzYWdlJywgbXNnRXZlbnQuZGF0YV0pXG4gIC5tZXJnZShjb25uZWN0ZWQkLm1hcChjb25uZWN0ZWQgPT4gWydjb25uZWN0ZWQnLCBjb25uZWN0ZWRdKSlcblxuLy8gUmVkdWNlXG5sZXQgbW9kZWwkID0gYWN0aW9ucyRcbiAgLm1lcmdlKGVmZmVjdHMkKVxuICAuZG8oeCA9PiBjb25zb2xlLmxvZygnQWN0aW9ucycsIHgpKVxuICAuc2Nhbih1cGRhdGUsIGluaXRNb2RlbClcbiAgLnN0YXJ0V2l0aChpbml0TW9kZWwpXG4gIC5kbyh4ID0+IGNvbnNvbGUubG9nKCdNb2RlbCcsIHgpKVxuXG4vLyBSZW5kZXJcbmxldCB2aWV3JCA9IG1vZGVsJC5tYXAodmlldylcbnJlbmRlcih2aWV3JCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpKVxuIl0sIm5hbWVzIjpbInNlbCIsImRhdGEiLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJrZXkiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJzIiwiY3JlYXRlRWxlbWVudCIsInRhZ05hbWUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZVVSSSIsInF1YWxpZmllZE5hbWUiLCJjcmVhdGVUZXh0Tm9kZSIsImluc2VydEJlZm9yZSIsInBhcmVudE5vZGUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwibm9kZSIsImNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnRFbGVtZW50IiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50IiwiVk5vZGUiLCJyZXF1aXJlJCQyIiwiaXMiLCJyZXF1aXJlJCQxIiwiZG9tQXBpIiwicmVxdWlyZSQkMCIsImlzVW5kZWYiLCJpc0RlZiIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInZub2RlMSIsInZub2RlMiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJpIiwibWFwIiwiaG9va3MiLCJpbml0IiwibW9kdWxlcyIsImFwaSIsImoiLCJjYnMiLCJsZW5ndGgiLCJwdXNoIiwiZW1wdHlOb2RlQXQiLCJpZCIsImMiLCJjbGFzc05hbWUiLCJzcGxpdCIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsImxpc3RlbmVycyIsInBhcmVudCIsImNyZWF0ZUVsbSIsInZub2RlIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwiaG9vayIsImhhc2hJZHgiLCJpbmRleE9mIiwiZG90SWR4IiwiaGFzaCIsImRvdCIsInRhZyIsInNsaWNlIiwiTWF0aCIsIm1pbiIsIm5zIiwicmVwbGFjZSIsImFycmF5IiwicHJpbWl0aXZlIiwiY3JlYXRlIiwiaW5zZXJ0IiwiYWRkVm5vZGVzIiwicGFyZW50RWxtIiwiYmVmb3JlIiwidm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsImRlc3Ryb3kiLCJyZW1vdmVWbm9kZXMiLCJybSIsImNoIiwicmVtb3ZlIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJwYXRjaFZub2RlIiwib2xkVm5vZGUiLCJwcmVwYXRjaCIsInVwZGF0ZSIsInBvc3RwYXRjaCIsInByZSIsInBvc3QiLCJhZGROUyIsImgiLCJiIiwidXBkYXRlQ2xhc3MiLCJjdXIiLCJuYW1lIiwib2xkQ2xhc3MiLCJjbGFzcyIsImtsYXNzIiwiY2xhc3NMaXN0IiwidXBkYXRlUHJvcHMiLCJvbGQiLCJvbGRQcm9wcyIsInByb3BzIiwicmFmIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsIm5leHRGcmFtZSIsImZuIiwic2V0TmV4dEZyYW1lIiwib2JqIiwicHJvcCIsInZhbCIsInVwZGF0ZVN0eWxlIiwib2xkU3R5bGUiLCJzdHlsZSIsIm9sZEhhc0RlbCIsImRlbGF5ZWQiLCJhcHBseURlc3Ryb3lTdHlsZSIsImFwcGx5UmVtb3ZlU3R5bGUiLCJpZHgiLCJtYXhEdXIiLCJjb21wU3R5bGUiLCJhbW91bnQiLCJhcHBsaWVkIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldiIsInRhcmdldCIsImludm9rZUhhbmRsZXIiLCJoYW5kbGVyIiwiZXZlbnQiLCJjYWxsIiwiYXJncyIsImFwcGx5IiwiaGFuZGxlRXZlbnQiLCJ0eXBlIiwib24iLCJjcmVhdGVMaXN0ZW5lciIsInVwZGF0ZUV2ZW50TGlzdGVuZXJzIiwib2xkT24iLCJvbGRMaXN0ZW5lciIsImxpc3RlbmVyIiwib2xkRWxtIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnZlcnRUb0h5cGVyU2NyaXB0IiwicmVuZGVyIiwidmlldyQiLCJjb250YWluZXIiLCJwYXRjaCIsInNuYWJiZG9tIiwic25hYkNsYXNzIiwic25hYlByb3BzIiwic25hYlN0eWxlIiwic25hYkV2ZW50Iiwic3Vic2NyaWJlIiwibmV3Vm5vZGUiLCJpc1dlYlNvY2tldCIsImNvbnN0cnVjdG9yIiwiQ0xPU0lORyIsImlzR2xvYmFsV2ViU29ja2V0IiwiV2ViU29ja2V0IiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJJbmZpbml0eSIsImJ5cGFzc1Byb3BlcnR5Iiwic3JjIiwiZHN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImluaXRSZWNvbm5lY3Rpb25EZWxheSIsImNvbmZpZyIsIm1pblJlY29ubmVjdGlvbkRlbGF5IiwicmFuZG9tIiwidXBkYXRlUmVjb25uZWN0aW9uRGVsYXkiLCJwcmV2aW91c0RlbGF5IiwibmV3RGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheUdyb3dGYWN0b3IiLCJtYXhSZWNvbm5lY3Rpb25EZWxheSIsIkxFVkVMXzBfRVZFTlRTIiwicmVhc3NpZ25FdmVudExpc3RlbmVycyIsIndzIiwib2xkV3MiLCJrZXlzIiwiZm9yRWFjaCIsIl9hIiwib3B0aW9ucyIsIlJlY29ubmVjdGluZ1dlYnNvY2tldCIsInVybCIsInByb3RvY29scyIsIl90aGlzIiwiY29ubmVjdGluZ1RpbWVvdXQiLCJyZWNvbm5lY3REZWxheSIsInJldHJpZXNDb3VudCIsInNob3VsZFJldHJ5Iiwic2F2ZWRPbkNsb3NlIiwiVHlwZUVycm9yIiwiZmlsdGVyIiwiaGFzT3duUHJvcGVydHkiLCJsb2ciLCJkZWJ1ZyIsInBhcmFtcyIsIl9pIiwiYXJndW1lbnRzIiwiY29uc29sZSIsImNvbmNhdCIsImVtaXRFcnJvciIsImNvZGUiLCJtc2ciLCJlcnIiLCJFcnJvciIsImVycm9yIiwib25lcnJvciIsImhhbmRsZUNsb3NlIiwibWF4UmV0cmllcyIsImNvbm5lY3QiLCJjbG9zZSIsImNvbm5lY3Rpb25UaW1lb3V0Iiwib25jbG9zZSIsInJlYXNvbiIsIl9iIiwiX2MiLCJrZWVwQ2xvc2VkIiwiX2QiLCJmYXN0Q2xvc2UiLCJfZSIsImRlbGF5IiwiZmFrZUNsb3NlRXZlbnRfMSIsInNlbmQiLCJzb21lIiwibCIsInNlbGYiLCJnbG9iYWwiLCJleHBvcnRzIiwicm9vdCIsImlzRnVuY3Rpb24iLCJ4IiwiaXNPYmplY3QiLCJlIiwiZXJyb3JPYmplY3RfMSIsInRyeUNhdGNoVGFyZ2V0IiwidHJ5Q2F0Y2hlciIsImVycm9yT2JqZWN0IiwidHJ5Q2F0Y2giLCJfX2V4dGVuZHMiLCJ0aGlzIiwiZCIsInAiLCJfXyIsInByb3RvdHlwZSIsIk9iamVjdCIsIlVuc3Vic2NyaXB0aW9uRXJyb3IiLCJfc3VwZXIiLCJlcnJvcnMiLCJ0b1N0cmluZyIsInN0YWNrIiwibWVzc2FnZSIsImlzQXJyYXlfMSIsInJlcXVpcmUkJDUiLCJpc09iamVjdF8xIiwicmVxdWlyZSQkNCIsImlzRnVuY3Rpb25fMSIsInJlcXVpcmUkJDMiLCJ0cnlDYXRjaF8xIiwiVW5zdWJzY3JpcHRpb25FcnJvcl8xIiwiU3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJjbG9zZWQiLCJfdW5zdWJzY3JpYmUiLCJoYXNFcnJvcnMiLCJfc3Vic2NyaXB0aW9ucyIsInRyaWFsIiwiaW5kZXgiLCJsZW4iLCJzdWIiLCJhZGQiLCJ0ZWFyZG93biIsIkVNUFRZIiwic3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbkluZGV4Iiwic3BsaWNlIiwiZW1wdHkiLCJyb290XzEiLCJTeW1ib2wiLCJmb3IiLCJTdWJzY3JpcHRpb25fMSIsIk9ic2VydmVyXzEiLCJyeFN1YnNjcmliZXJfMSIsIlN1YnNjcmliZXIiLCJkZXN0aW5hdGlvbk9yTmV4dCIsImNvbXBsZXRlIiwic3luY0Vycm9yVmFsdWUiLCJzeW5jRXJyb3JUaHJvd24iLCJzeW5jRXJyb3JUaHJvd2FibGUiLCJpc1N0b3BwZWQiLCJkZXN0aW5hdGlvbiIsIlNhZmVTdWJzY3JpYmVyIiwiJCRyeFN1YnNjcmliZXIiLCJuZXh0Iiwic3Vic2NyaWJlciIsIl9uZXh0IiwiX2Vycm9yIiwiX2NvbXBsZXRlIiwiX3BhcmVudCIsIm9ic2VydmVyT3JOZXh0IiwiY29udGV4dCIsImJpbmQiLCJfY29udGV4dCIsIl9fdHJ5T3JVbnN1YiIsIl9fdHJ5T3JTZXRFcnJvciIsIlN1YnNjcmliZXJfMSIsInRvU3Vic2NyaWJlciIsIm5leHRPck9ic2VydmVyIiwiZ2V0U3ltYm9sT2JzZXJ2YWJsZSIsIiQkb2JzZXJ2YWJsZSIsIm9ic2VydmFibGUiLCJ0b1N1YnNjcmliZXJfMSIsIm9ic2VydmFibGVfMSIsIk9ic2VydmFibGUiLCJfaXNTY2FsYXIiLCJfc3Vic2NyaWJlIiwibGlmdCIsIm9wZXJhdG9yIiwic291cmNlIiwic2luayIsIlByb21pc2VDdG9yIiwiUngiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIk9iamVjdFVuc3Vic2NyaWJlZEVycm9yIiwiU3ViamVjdFN1YnNjcmlwdGlvbiIsInN1YmplY3QiLCJvYnNlcnZlcnMiLCJzdWJzY3JpYmVySW5kZXgiLCJPYnNlcnZhYmxlXzEiLCJPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xIiwiU3ViamVjdFN1YnNjcmlwdGlvbl8xIiwiU3ViamVjdFN1YnNjcmliZXIiLCJTdWJqZWN0IiwiaGFzRXJyb3IiLCJ0aHJvd25FcnJvciIsIkFub255bW91c1N1YmplY3QiLCJjb3B5IiwiYXNPYnNlcnZhYmxlIiwiU3ViamVjdF8xIiwiQXN5bmNTdWJqZWN0IiwiaGFzTmV4dCIsImhhc0NvbXBsZXRlZCIsIkFzeW5jU3ViamVjdF8xIiwiQm91bmRDYWxsYmFja09ic2VydmFibGUiLCJjYWxsYmFja0Z1bmMiLCJzZWxlY3RvciIsInNjaGVkdWxlciIsImZ1bmMiLCJoYW5kbGVyRm4iLCJpbm5lckFyZ3MiLCJyZXN1bHRfMSIsInJlc3VsdCIsInNjaGVkdWxlIiwiZGlzcGF0Y2giLCJzdGF0ZSIsInJlc3VsdF8yIiwiZGlzcGF0Y2hFcnJvciIsImRpc3BhdGNoTmV4dCIsImFyZyIsIkJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlXzEiLCJiaW5kQ2FsbGJhY2tfMSIsImJpbmRDYWxsYmFjayIsIkJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZSIsInNoaWZ0IiwiQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlXzEiLCJiaW5kTm9kZUNhbGxiYWNrXzEiLCJiaW5kTm9kZUNhbGxiYWNrIiwiaXNTY2hlZHVsZXIiLCJTY2FsYXJPYnNlcnZhYmxlIiwiZG9uZSIsIkVtcHR5T2JzZXJ2YWJsZSIsIlNjYWxhck9ic2VydmFibGVfMSIsIkVtcHR5T2JzZXJ2YWJsZV8xIiwiaXNTY2hlZHVsZXJfMSIsIkFycmF5T2JzZXJ2YWJsZSIsIm9mIiwicG9wIiwiY291bnQiLCJPdXRlclN1YnNjcmliZXIiLCJub3RpZnlOZXh0Iiwib3V0ZXJWYWx1ZSIsImlubmVyVmFsdWUiLCJvdXRlckluZGV4IiwiaW5uZXJJbmRleCIsImlubmVyU3ViIiwibm90aWZ5RXJyb3IiLCJub3RpZnlDb21wbGV0ZSIsImlzUHJvbWlzZSIsInRoZW4iLCJzeW1ib2xJdGVyYXRvclBvbnlmaWxsIiwiaXRlcmF0b3IiLCJTZXRfMSIsIlNldCIsIk1hcF8xIiwiTWFwIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIklubmVyU3Vic2NyaWJlciIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ2IiwiaXNQcm9taXNlXzEiLCJpdGVyYXRvcl8xIiwiSW5uZXJTdWJzY3JpYmVyXzEiLCJzdWJzY3JpYmVUb1Jlc3VsdCIsIm91dGVyU3Vic2NyaWJlciIsIiQkaXRlcmF0b3IiLCJpdGVtIiwib2JzIiwiQXJyYXlPYnNlcnZhYmxlXzEiLCJPdXRlclN1YnNjcmliZXJfMSIsInN1YnNjcmliZVRvUmVzdWx0XzEiLCJub25lIiwiY29tYmluZUxhdGVzdCIsIm9ic2VydmFibGVzIiwicHJvamVjdCIsInVuc2hpZnQiLCJDb21iaW5lTGF0ZXN0T3BlcmF0b3IiLCJDb21iaW5lTGF0ZXN0U3Vic2NyaWJlciIsImFjdGl2ZSIsInZhbHVlcyIsInRvUmVzcG9uZCIsInVudXNlZCIsIm9sZFZhbCIsIl90cnlQcm9qZWN0IiwiY29tYmluZUxhdGVzdF8xIiwibWVyZ2VBbGwiLCJjb25jdXJyZW50IiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJNZXJnZUFsbE9wZXJhdG9yIiwib2JzZXJ2ZXIiLCJNZXJnZUFsbFN1YnNjcmliZXIiLCJidWZmZXIiLCJtZXJnZUFsbF8xIiwiY29uY2F0U3RhdGljIiwiY29uY2F0XzEiLCJEZWZlck9ic2VydmFibGUiLCJvYnNlcnZhYmxlRmFjdG9yeSIsIkRlZmVyU3Vic2NyaWJlciIsImZhY3RvcnkiLCJ0cnlEZWZlciIsIl9jYWxsRmFjdG9yeSIsIkRlZmVyT2JzZXJ2YWJsZV8xIiwiZGVmZXJfMSIsImRlZmVyIiwiZW1wdHlfMSIsIkZvcmtKb2luT2JzZXJ2YWJsZSIsInNvdXJjZXMiLCJyZXN1bHRTZWxlY3RvciIsIkZvcmtKb2luU3Vic2NyaWJlciIsImNvbXBsZXRlZCIsImhhdmVWYWx1ZXMiLCJ0b3RhbCIsImlubmVyU3Vic2NyaXB0aW9uIiwiX2hhc1ZhbHVlIiwiRm9ya0pvaW5PYnNlcnZhYmxlXzEiLCJmb3JrSm9pbl8xIiwiZm9ya0pvaW4iLCJQcm9taXNlT2JzZXJ2YWJsZSIsInByb21pc2UiLCJJdGVyYXRvck9ic2VydmFibGUiLCJnZXRJdGVyYXRvciIsInJldHVybiIsIlN0cmluZ0l0ZXJhdG9yIiwic3RyIiwiY2hhckF0IiwiQXJyYXlJdGVyYXRvciIsImFyciIsInRvTGVuZ3RoIiwibWF4U2FmZUludGVnZXIiLCJwb3ciLCJvIiwiaXNOYU4iLCJudW1iZXJJc0Zpbml0ZSIsInNpZ24iLCJmbG9vciIsImFicyIsImlzRmluaXRlIiwidmFsdWVBc051bWJlciIsIkFycmF5TGlrZU9ic2VydmFibGUiLCJhcnJheUxpa2UiLCJOb3RpZmljYXRpb24iLCJraW5kIiwiaGFzVmFsdWUiLCJvYnNlcnZlIiwiZG8iLCJhY2NlcHQiLCJ0b09ic2VydmFibGUiLCJ0aHJvdyIsImNyZWF0ZU5leHQiLCJ1bmRlZmluZWRWYWx1ZU5vdGlmaWNhdGlvbiIsImNyZWF0ZUVycm9yIiwiY3JlYXRlQ29tcGxldGUiLCJjb21wbGV0ZU5vdGlmaWNhdGlvbiIsIk5vdGlmaWNhdGlvbl8xIiwib2JzZXJ2ZU9uIiwiT2JzZXJ2ZU9uT3BlcmF0b3IiLCJPYnNlcnZlT25TdWJzY3JpYmVyIiwibm90aWZpY2F0aW9uIiwic2NoZWR1bGVNZXNzYWdlIiwiT2JzZXJ2ZU9uTWVzc2FnZSIsInJlcXVpcmUkJDkiLCJyZXF1aXJlJCQ4IiwiUHJvbWlzZU9ic2VydmFibGVfMSIsIkl0ZXJhdG9yT2JzZXJ2YWJsZV8xIiwiQXJyYXlMaWtlT2JzZXJ2YWJsZV8xIiwib2JzZXJ2ZU9uXzEiLCJpc0FycmF5TGlrZSIsIkZyb21PYnNlcnZhYmxlIiwiaXNoIiwiRnJvbU9ic2VydmFibGVfMSIsImZyb21fMSIsImZyb20iLCJpc05vZGVTdHlsZUV2ZW50RW1taXR0ZXIiLCJzb3VyY2VPYmoiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlciIsIm9mZiIsImlzTm9kZUxpc3QiLCJpc0hUTUxDb2xsZWN0aW9uIiwiaXNFdmVudFRhcmdldCIsIkZyb21FdmVudE9ic2VydmFibGUiLCJldmVudE5hbWUiLCJzZXR1cFN1YnNjcmlwdGlvbiIsInNvdXJjZV8xIiwic291cmNlXzIiLCJzb3VyY2VfMyIsIkZyb21FdmVudE9ic2VydmFibGVfMSIsImZyb21FdmVudF8xIiwiZnJvbUV2ZW50IiwiRnJvbUV2ZW50UGF0dGVybk9ic2VydmFibGUiLCJhZGRIYW5kbGVyIiwicmVtb3ZlSGFuZGxlciIsIl9jYWxsU2VsZWN0b3IiLCJfY2FsbEFkZEhhbmRsZXIiLCJlcnJvclN1YnNjcmliZXIiLCJGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZV8xIiwiZnJvbUV2ZW50UGF0dGVybl8xIiwiZnJvbUV2ZW50UGF0dGVybiIsImZyb21Qcm9taXNlXzEiLCJmcm9tUHJvbWlzZSIsInNlbGZTZWxlY3RvciIsIkdlbmVyYXRlT2JzZXJ2YWJsZSIsImluaXRpYWxTdGF0ZSIsImNvbmRpdGlvbiIsIml0ZXJhdGUiLCJpbml0aWFsU3RhdGVPck9wdGlvbnMiLCJyZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSIsImNvbmRpdGlvblJlc3VsdCIsIm5lZWRJdGVyYXRlIiwiR2VuZXJhdGVPYnNlcnZhYmxlXzEiLCJnZW5lcmF0ZSIsIklmT2JzZXJ2YWJsZSIsInRoZW5Tb3VyY2UiLCJlbHNlU291cmNlIiwiSWZTdWJzY3JpYmVyIiwidHJ5SWYiLCJJZk9ic2VydmFibGVfMSIsImlmXzEiLCJpZiIsIl9pZiIsImlzTnVtZXJpYyIsInBhcnNlRmxvYXQiLCJBY3Rpb24iLCJ3b3JrIiwiQWN0aW9uXzEiLCJBc3luY0FjdGlvbiIsInBlbmRpbmciLCJyZWN5Y2xlQXN5bmNJZCIsInJlcXVlc3RBc3luY0lkIiwic2V0SW50ZXJ2YWwiLCJmbHVzaCIsImNsZWFySW50ZXJ2YWwiLCJleGVjdXRlIiwiX2V4ZWN1dGUiLCJlcnJvcmVkIiwiZXJyb3JWYWx1ZSIsImFjdGlvbnMiLCJTY2hlZHVsZXIiLCJTY2hlZHVsZXJBY3Rpb24iLCJub3ciLCJEYXRlIiwiU2NoZWR1bGVyXzEiLCJBc3luY1NjaGVkdWxlciIsInNjaGVkdWxlZCIsImFjdGlvbiIsIkFzeW5jQWN0aW9uXzEiLCJBc3luY1NjaGVkdWxlcl8xIiwiaXNOdW1lcmljXzEiLCJhc3luY18xIiwiSW50ZXJ2YWxPYnNlcnZhYmxlIiwicGVyaW9kIiwiYXN5bmMiLCJJbnRlcnZhbE9ic2VydmFibGVfMSIsImludGVydmFsXzEiLCJpbnRlcnZhbCIsIm1lcmdlIiwibWVyZ2VTdGF0aWMiLCJsYXN0IiwibWVyZ2VfMSIsInJhY2UiLCJyYWNlU3RhdGljIiwiUmFjZU9wZXJhdG9yIiwiUmFjZVN1YnNjcmliZXIiLCJoYXNGaXJzdCIsInJhY2VfMSIsIm5vb3AiLCJub29wXzEiLCJOZXZlck9ic2VydmFibGUiLCJOZXZlck9ic2VydmFibGVfMSIsIm5ldmVyXzEiLCJuZXZlciIsIm9mXzEiLCJvbkVycm9yUmVzdW1lTmV4dCIsIm5leHRTb3VyY2VzIiwiT25FcnJvclJlc3VtZU5leHRPcGVyYXRvciIsIm9uRXJyb3JSZXN1bWVOZXh0U3RhdGljIiwiT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyIiwic3Vic2NyaWJlVG9OZXh0U291cmNlIiwib25FcnJvclJlc3VtZU5leHRfMSIsIlBhaXJzT2JzZXJ2YWJsZSIsIlBhaXJzT2JzZXJ2YWJsZV8xIiwicGFpcnNfMSIsInBhaXJzIiwiUmFuZ2VPYnNlcnZhYmxlIiwic3RhcnQiLCJfY291bnQiLCJSYW5nZU9ic2VydmFibGVfMSIsInJhbmdlXzEiLCJyYW5nZSIsIlVzaW5nT2JzZXJ2YWJsZSIsInJlc291cmNlRmFjdG9yeSIsInJlc291cmNlIiwiVXNpbmdTdWJzY3JpYmVyIiwidHJ5VXNlIiwiVXNpbmdPYnNlcnZhYmxlXzEiLCJ1c2luZ18xIiwidXNpbmciLCJFcnJvck9ic2VydmFibGUiLCJFcnJvck9ic2VydmFibGVfMSIsInRocm93XzEiLCJfdGhyb3ciLCJpc0RhdGUiLCJpc0RhdGVfMSIsIlRpbWVyT2JzZXJ2YWJsZSIsImR1ZVRpbWUiLCJpbml0aWFsRGVsYXkiLCJUaW1lck9ic2VydmFibGVfMSIsInRpbWVyXzEiLCJ0aW1lciIsInppcFByb3RvIiwiemlwU3RhdGljIiwiWmlwT3BlcmF0b3IiLCJaaXBTdWJzY3JpYmVyIiwiaXRlcmF0b3JzIiwiU3RhdGljQXJyYXlJdGVyYXRvciIsIlN0YXRpY0l0ZXJhdG9yIiwiWmlwQnVmZmVySXRlcmF0b3IiLCJzdGlsbFVuc3Vic2NyaWJlZCIsIm5vdGlmeUluYWN0aXZlIiwiY2hlY2tJdGVyYXRvcnMiLCJzaG91bGRDb21wbGV0ZSIsIm5leHRSZXN1bHQiLCJpc0NvbXBsZXRlIiwiemlwXzEiLCJ6aXAiLCJ0aGlzQXJnIiwiTWFwT3BlcmF0b3IiLCJNYXBTdWJzY3JpYmVyIiwibWFwXzEiLCJnZXRDT1JTUmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwieGhyIiwid2l0aENyZWRlbnRpYWxzIiwiWERvbWFpblJlcXVlc3QiLCJnZXRYTUxIdHRwUmVxdWVzdCIsInByb2dJZCIsInByb2dJZHMiLCJBY3RpdmVYT2JqZWN0IiwiYWpheEdldCIsImhlYWRlcnMiLCJBamF4T2JzZXJ2YWJsZSIsIm1ldGhvZCIsImFqYXhQb3N0IiwiYm9keSIsImFqYXhEZWxldGUiLCJhamF4UHV0IiwiYWpheEdldEpTT04iLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZSIsInVybE9yUmVxdWVzdCIsInJlcXVlc3QiLCJjcm9zc0RvbWFpbiIsIkFqYXhTdWJzY3JpYmVyIiwiZ2V0IiwiZGVsZXRlIiwicHV0IiwiZ2V0SlNPTiIsIkZvcm1EYXRhIiwic2VyaWFsaXplQm9keSIsIkFqYXhSZXNwb25zZSIsInVzZXIiLCJwYXNzd29yZCIsImNyZWF0ZVhIUiIsIm9wZW4iLCJ0aW1lb3V0Iiwic2V0SGVhZGVycyIsInNldHVwRXZlbnRzIiwiY29udGVudFR5cGUiLCJzcGxpdEluZGV4Iiwic3Vic3RyaW5nIiwiZW5jb2RlVVJJIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldFJlcXVlc3RIZWFkZXIiLCJwcm9ncmVzc1N1YnNjcmliZXIiLCJ4aHJUaW1lb3V0IiwiQWpheFRpbWVvdXRFcnJvciIsIm9udGltZW91dCIsInVwbG9hZCIsInhoclByb2dyZXNzXzEiLCJvbnByb2dyZXNzIiwieGhyRXJyb3JfMSIsIkFqYXhFcnJvciIsInhoclJlYWR5U3RhdGVDaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzXzEiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJhYm9ydCIsIm9yaWdpbmFsRXZlbnQiLCJwYXJzZSIsInJlc3BvbnNlWE1MIiwiQWpheE9ic2VydmFibGVfMSIsImFqYXhfMSIsImFqYXgiLCJRdWV1ZUFjdGlvbiIsIlF1ZXVlU2NoZWR1bGVyIiwiUXVldWVBY3Rpb25fMSIsIlF1ZXVlU2NoZWR1bGVyXzEiLCJxdWV1ZV8xIiwiUmVwbGF5U3ViamVjdCIsImJ1ZmZlclNpemUiLCJ3aW5kb3dUaW1lIiwiX2V2ZW50cyIsIl9idWZmZXJTaXplIiwiX3dpbmRvd1RpbWUiLCJfZ2V0Tm93IiwiUmVwbGF5RXZlbnQiLCJfdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMiLCJxdWV1ZSIsImV2ZW50c0NvdW50Iiwic3BsaWNlQ291bnQiLCJ0aW1lIiwibWF4IiwiYXNzaWduSW1wbCIsImsiLCJnZXRBc3NpZ24iLCJhc3NpZ24iLCJSZXBsYXlTdWJqZWN0XzEiLCJhc3NpZ25fMSIsIldlYlNvY2tldFN1YmplY3QiLCJ1cmxDb25maWdPclNvdXJjZSIsIldlYlNvY2tldEN0b3IiLCJfb3V0cHV0Iiwic29jayIsIl9yZXNldFN0YXRlIiwic29ja2V0IiwibXVsdGlwbGV4Iiwic3ViTXNnIiwidW5zdWJNc2ciLCJtZXNzYWdlRmlsdGVyIiwiX2Nvbm5lY3RTb2NrZXQiLCJwcm90b2NvbCIsIm9ub3BlbiIsIm9wZW5PYnNlcnZlciIsImNsb3NpbmdPYnNlcnZlciIsImNsb3NlT2JzZXJ2ZXIiLCJ3YXNDbGVhbiIsIm9ubWVzc2FnZSIsIldlYlNvY2tldFN1YmplY3RfMSIsIndlYlNvY2tldF8xIiwid2ViU29ja2V0IiwiY2xvc2luZ05vdGlmaWVyIiwiQnVmZmVyT3BlcmF0b3IiLCJCdWZmZXJTdWJzY3JpYmVyIiwiYnVmZmVyXzEiLCJidWZmZXJDb3VudCIsInN0YXJ0QnVmZmVyRXZlcnkiLCJCdWZmZXJDb3VudE9wZXJhdG9yIiwiQnVmZmVyQ291bnRTdWJzY3JpYmVyIiwiYnVmZmVycyIsInN0YXJ0T24iLCJidWZmZXJDb3VudF8xIiwiYnVmZmVyVGltZSIsImJ1ZmZlclRpbWVTcGFuIiwiYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCIsIm1heEJ1ZmZlclNpemUiLCJCdWZmZXJUaW1lT3BlcmF0b3IiLCJCdWZmZXJUaW1lU3Vic2NyaWJlciIsIkNvbnRleHQiLCJjb250ZXh0cyIsIm9wZW5Db250ZXh0IiwidGltZXNwYW5Pbmx5IiwidGltZVNwYW5Pbmx5U3RhdGUiLCJjbG9zZUFjdGlvbiIsImRpc3BhdGNoQnVmZmVyVGltZVNwYW5Pbmx5IiwiY2xvc2VTdGF0ZSIsImNyZWF0aW9uU3RhdGUiLCJkaXNwYXRjaEJ1ZmZlckNsb3NlIiwiZGlzcGF0Y2hCdWZmZXJDcmVhdGlvbiIsImZpbGxlZEJ1ZmZlckNvbnRleHQiLCJvbkJ1ZmZlckZ1bGwiLCJjbG9zZUNvbnRleHQiLCJzcGxpY2VJbmRleCIsInByZXZDb250ZXh0IiwiYnVmZmVyVGltZV8xIiwiYnVmZmVyVG9nZ2xlIiwib3BlbmluZ3MiLCJjbG9zaW5nU2VsZWN0b3IiLCJCdWZmZXJUb2dnbGVPcGVyYXRvciIsIkJ1ZmZlclRvZ2dsZVN1YnNjcmliZXIiLCJjbG9zZUJ1ZmZlciIsIm9wZW5CdWZmZXIiLCJ0cnlTdWJzY3JpYmUiLCJidWZmZXJUb2dnbGVfMSIsImJ1ZmZlcldoZW4iLCJCdWZmZXJXaGVuT3BlcmF0b3IiLCJCdWZmZXJXaGVuU3Vic2NyaWJlciIsInN1YnNjcmliaW5nIiwiY2xvc2luZ1N1YnNjcmlwdGlvbiIsImJ1ZmZlcldoZW5fMSIsIl9jYXRjaCIsIkNhdGNoT3BlcmF0b3IiLCJjYXVnaHQiLCJDYXRjaFN1YnNjcmliZXIiLCJjYXRjaF8xIiwiY2F0Y2giLCJjb21iaW5lQWxsIiwiY29tYmluZUFsbF8xIiwiY29uY2F0QWxsIiwiY29uY2F0QWxsXzEiLCJtZXJnZU1hcCIsIk1lcmdlTWFwT3BlcmF0b3IiLCJNZXJnZU1hcFN1YnNjcmliZXIiLCJfdHJ5TmV4dCIsIl9pbm5lclN1YiIsIl9ub3RpZnlSZXN1bHRTZWxlY3RvciIsIm1lcmdlTWFwXzEiLCJjb25jYXRNYXAiLCJjb25jYXRNYXBfMSIsIm1lcmdlTWFwVG8iLCJpbm5lck9ic2VydmFibGUiLCJNZXJnZU1hcFRvT3BlcmF0b3IiLCJNZXJnZU1hcFRvU3Vic2NyaWJlciIsInRyeVNlbGVjdFJlc3VsdCIsIm1lcmdlTWFwVG9fMSIsImNvbmNhdE1hcFRvIiwiY29uY2F0TWFwVG9fMSIsInByZWRpY2F0ZSIsIkNvdW50T3BlcmF0b3IiLCJDb3VudFN1YnNjcmliZXIiLCJfdHJ5UHJlZGljYXRlIiwiY291bnRfMSIsImRlbWF0ZXJpYWxpemUiLCJEZU1hdGVyaWFsaXplT3BlcmF0b3IiLCJEZU1hdGVyaWFsaXplU3Vic2NyaWJlciIsImRlbWF0ZXJpYWxpemVfMSIsImRlYm91bmNlIiwiZHVyYXRpb25TZWxlY3RvciIsIkRlYm91bmNlT3BlcmF0b3IiLCJEZWJvdW5jZVN1YnNjcmliZXIiLCJkdXJhdGlvblN1YnNjcmlwdGlvbiIsImVtaXRWYWx1ZSIsImR1cmF0aW9uIiwiZGVib3VuY2VfMSIsImRlYm91bmNlVGltZSIsIkRlYm91bmNlVGltZU9wZXJhdG9yIiwiRGVib3VuY2VUaW1lU3Vic2NyaWJlciIsImRlYm91bmNlZFN1YnNjcmlwdGlvbiIsImxhc3RWYWx1ZSIsImNsZWFyRGVib3VuY2UiLCJkZWJvdW5jZWROZXh0IiwiZGVib3VuY2VUaW1lXzEiLCJkZWZhdWx0SWZFbXB0eSIsImRlZmF1bHRWYWx1ZSIsIkRlZmF1bHRJZkVtcHR5T3BlcmF0b3IiLCJEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIiLCJpc0VtcHR5IiwiZGVmYXVsdElmRW1wdHlfMSIsImFic29sdXRlRGVsYXkiLCJkZWxheUZvciIsIkRlbGF5T3BlcmF0b3IiLCJEZWxheVN1YnNjcmliZXIiLCJkZWxheV8xIiwiX3NjaGVkdWxlIiwic2NoZWR1bGVOb3RpZmljYXRpb24iLCJEZWxheU1lc3NhZ2UiLCJkZWxheVdoZW4iLCJkZWxheUR1cmF0aW9uU2VsZWN0b3IiLCJzdWJzY3JpcHRpb25EZWxheSIsIlN1YnNjcmlwdGlvbkRlbGF5T2JzZXJ2YWJsZSIsIkRlbGF5V2hlbk9wZXJhdG9yIiwiRGVsYXlXaGVuU3Vic2NyaWJlciIsImRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zIiwicmVtb3ZlU3Vic2NyaXB0aW9uIiwidHJ5Q29tcGxldGUiLCJkZWxheU5vdGlmaWVyIiwidHJ5RGVsYXkiLCJzdWJzY3JpcHRpb25JZHgiLCJub3RpZmllclN1YnNjcmlwdGlvbiIsIlN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlciIsInNvdXJjZVN1YnNjcmliZWQiLCJzdWJzY3JpYmVUb1NvdXJjZSIsImRlbGF5V2hlbl8xIiwibWluaW1hbFNldEltcGwiLCJNaW5pbWFsU2V0IiwiX3ZhbHVlcyIsImhhcyIsImNsZWFyIiwiZGlzdGluY3QiLCJrZXlTZWxlY3RvciIsImZsdXNoZXMiLCJEaXN0aW5jdE9wZXJhdG9yIiwiRGlzdGluY3RTdWJzY3JpYmVyIiwiX3VzZUtleVNlbGVjdG9yIiwiX2ZpbmFsaXplTmV4dCIsImRpc3RpbmN0XzEiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsImNvbXBhcmUiLCJEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yIiwiRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyIiwiaGFzS2V5IiwieSIsIkJvb2xlYW4iLCJkaXN0aW5jdFVudGlsQ2hhbmdlZF8xIiwiZGlzdGluY3RVbnRpbEtleUNoYW5nZWQiLCJkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZF8xIiwiX2RvIiwiRG9PcGVyYXRvciIsIkRvU3Vic2NyaWJlciIsInNhZmVTdWJzY3JpYmVyIiwiZG9fMSIsImV4aGF1c3QiLCJTd2l0Y2hGaXJzdE9wZXJhdG9yIiwiU3dpdGNoRmlyc3RTdWJzY3JpYmVyIiwiaGFzU3Vic2NyaXB0aW9uIiwiZXhoYXVzdF8xIiwiZXhoYXVzdE1hcCIsIlN3aXRjaEZpcnN0TWFwT3BlcmF0b3IiLCJTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIiLCJ0cnlOZXh0IiwiZXhoYXVzdE1hcF8xIiwiZXhwYW5kIiwiRXhwYW5kT3BlcmF0b3IiLCJFeHBhbmRTdWJzY3JpYmVyIiwic3Vic2NyaWJlVG9Qcm9qZWN0aW9uIiwiZXhwYW5kXzEiLCJBcmd1bWVudE91dE9mUmFuZ2VFcnJvciIsIkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEiLCJlbGVtZW50QXQiLCJFbGVtZW50QXRPcGVyYXRvciIsIkVsZW1lbnRBdFN1YnNjcmliZXIiLCJlbGVtZW50QXRfMSIsIkZpbHRlck9wZXJhdG9yIiwiRmlsdGVyU3Vic2NyaWJlciIsImZpbHRlcl8xIiwiX2ZpbmFsbHkiLCJjYWxsYmFjayIsIkZpbmFsbHlPcGVyYXRvciIsIkZpbmFsbHlTdWJzY3JpYmVyIiwiZmluYWxseV8xIiwiZmluYWxseSIsImZpbmQiLCJGaW5kVmFsdWVPcGVyYXRvciIsInlpZWxkSW5kZXgiLCJGaW5kVmFsdWVTdWJzY3JpYmVyIiwiZmluZF8xIiwiZmluZEluZGV4IiwiZmluZEluZGV4XzEiLCJFbXB0eUVycm9yIiwiRW1wdHlFcnJvcl8xIiwiZmlyc3QiLCJGaXJzdE9wZXJhdG9yIiwiRmlyc3RTdWJzY3JpYmVyIiwiX2VtaXR0ZWQiLCJfZW1pdCIsIl90cnlSZXN1bHRTZWxlY3RvciIsIl9lbWl0RmluYWwiLCJmaXJzdF8xIiwiTWFwUG9seWZpbGwiLCJzaXplIiwiX2tleXMiLCJzZXQiLCJjYiIsIk1hcFBvbHlmaWxsXzEiLCJGYXN0TWFwIiwiRmFzdE1hcF8xIiwiZ3JvdXBCeSIsImVsZW1lbnRTZWxlY3RvciIsInN1YmplY3RTZWxlY3RvciIsIkdyb3VwQnlPcGVyYXRvciIsIkdyb3VwQnlTdWJzY3JpYmVyIiwiZ3JvdXBzIiwiYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSIsIl9ncm91cCIsImdyb3VwIiwiZWxlbWVudCIsImdyb3VwZWRPYnNlcnZhYmxlIiwiR3JvdXBlZE9ic2VydmFibGUiLCJHcm91cER1cmF0aW9uU3Vic2NyaWJlciIsInJlbW92ZUdyb3VwIiwiZ3JvdXBTdWJqZWN0IiwicmVmQ291bnRTdWJzY3JpcHRpb24iLCJJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uIiwiZ3JvdXBCeV8xIiwiaWdub3JlRWxlbWVudHMiLCJJZ25vcmVFbGVtZW50c09wZXJhdG9yIiwiSWdub3JlRWxlbWVudHNTdWJzY3JpYmVyIiwiaWdub3JlRWxlbWVudHNfMSIsIklzRW1wdHlPcGVyYXRvciIsIklzRW1wdHlTdWJzY3JpYmVyIiwiaXNFbXB0eV8xIiwiYXVkaXQiLCJBdWRpdE9wZXJhdG9yIiwiQXVkaXRTdWJzY3JpYmVyIiwidGhyb3R0bGVkIiwiY2xlYXJUaHJvdHRsZSIsImF1ZGl0XzEiLCJhdWRpdFRpbWUiLCJBdWRpdFRpbWVPcGVyYXRvciIsIkF1ZGl0VGltZVN1YnNjcmliZXIiLCJhdWRpdFRpbWVfMSIsIkxhc3RPcGVyYXRvciIsIkxhc3RTdWJzY3JpYmVyIiwibGFzdF8xIiwibGV0UHJvdG8iLCJsZXRfMSIsImxldCIsImxldEJpbmQiLCJldmVyeSIsIkV2ZXJ5T3BlcmF0b3IiLCJFdmVyeVN1YnNjcmliZXIiLCJldmVyeVZhbHVlTWF0Y2giLCJldmVyeV8xIiwibWFwVG8iLCJNYXBUb09wZXJhdG9yIiwiTWFwVG9TdWJzY3JpYmVyIiwibWFwVG9fMSIsIm1hdGVyaWFsaXplIiwiTWF0ZXJpYWxpemVPcGVyYXRvciIsIk1hdGVyaWFsaXplU3Vic2NyaWJlciIsIm1hdGVyaWFsaXplXzEiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsInNlZWQiLCJoYXNTZWVkIiwiUmVkdWNlT3BlcmF0b3IiLCJSZWR1Y2VTdWJzY3JpYmVyIiwiYWNjIiwiX3RyeVJlZHVjZSIsInJlZHVjZV8xIiwiY29tcGFyZXIiLCJtYXhfMSIsImZsYXRNYXAiLCJmbGF0TWFwVG8iLCJtZXJnZVNjYW4iLCJNZXJnZVNjYW5PcGVyYXRvciIsIk1lcmdlU2NhblN1YnNjcmliZXIiLCJtZXJnZVNjYW5fMSIsIm1pbl8xIiwiQ29ubmVjdGFibGVPYnNlcnZhYmxlIiwic3ViamVjdEZhY3RvcnkiLCJfcmVmQ291bnQiLCJnZXRTdWJqZWN0IiwiX3N1YmplY3QiLCJjb25uZWN0aW9uIiwiX2Nvbm5lY3Rpb24iLCJDb25uZWN0YWJsZVN1YnNjcmliZXIiLCJyZWZDb3VudCIsIlJlZkNvdW50T3BlcmF0b3IiLCJ3cml0YWJsZSIsImNvbm5lY3RhYmxlIiwicmVmQ291bnRlciIsIlJlZkNvdW50U3Vic2NyaWJlciIsInNoYXJlZENvbm5lY3Rpb24iLCJDb25uZWN0YWJsZU9ic2VydmFibGVfMSIsIm11bHRpY2FzdCIsInN1YmplY3RPclN1YmplY3RGYWN0b3J5IiwiTXVsdGljYXN0T3BlcmF0b3IiLCJjb25uZWN0YWJsZU9ic2VydmFibGVEZXNjcmlwdG9yIiwibXVsdGljYXN0XzEiLCJwYWlyd2lzZSIsIlBhaXJ3aXNlT3BlcmF0b3IiLCJQYWlyd2lzZVN1YnNjcmliZXIiLCJoYXNQcmV2IiwicHJldiIsInBhaXJ3aXNlXzEiLCJub3QiLCJwcmVkIiwibm90UHJlZCIsIm5vdF8xIiwicGFydGl0aW9uIiwicGFydGl0aW9uXzEiLCJwbHVjayIsInByb3BlcnRpZXMiLCJwbHVja2VyIiwibWFwcGVyIiwiY3VycmVudFByb3AiLCJwbHVja18xIiwicHVibGlzaCIsInB1Ymxpc2hfMSIsIkJlaGF2aW9yU3ViamVjdCIsIl92YWx1ZSIsImdldFZhbHVlIiwiQmVoYXZpb3JTdWJqZWN0XzEiLCJwdWJsaXNoQmVoYXZpb3IiLCJwdWJsaXNoQmVoYXZpb3JfMSIsInB1Ymxpc2hSZXBsYXkiLCJwdWJsaXNoUmVwbGF5XzEiLCJwdWJsaXNoTGFzdCIsInB1Ymxpc2hMYXN0XzEiLCJyZXBlYXQiLCJSZXBlYXRPcGVyYXRvciIsIlJlcGVhdFN1YnNjcmliZXIiLCJyZXBlYXRfMSIsInJlcGVhdFdoZW4iLCJub3RpZmllciIsIlJlcGVhdFdoZW5PcGVyYXRvciIsIlJlcGVhdFdoZW5TdWJzY3JpYmVyIiwibm90aWZpY2F0aW9ucyIsInJldHJpZXMiLCJyZXRyaWVzU3Vic2NyaXB0aW9uIiwicmVwZWF0V2hlbl8xIiwicmV0cnkiLCJSZXRyeU9wZXJhdG9yIiwiUmV0cnlTdWJzY3JpYmVyIiwicmV0cnlfMSIsInJldHJ5V2hlbiIsIlJldHJ5V2hlbk9wZXJhdG9yIiwiUmV0cnlXaGVuU3Vic2NyaWJlciIsInJldHJ5V2hlbl8xIiwic2FtcGxlIiwiU2FtcGxlT3BlcmF0b3IiLCJzYW1wbGVTdWJzY3JpYmVyIiwiU2FtcGxlU3Vic2NyaWJlciIsInNhbXBsZV8xIiwic2FtcGxlVGltZSIsIlNhbXBsZVRpbWVPcGVyYXRvciIsIlNhbXBsZVRpbWVTdWJzY3JpYmVyIiwiZGlzcGF0Y2hOb3RpZmljYXRpb24iLCJzYW1wbGVUaW1lXzEiLCJzY2FuIiwiU2Nhbk9wZXJhdG9yIiwiU2NhblN1YnNjcmliZXIiLCJfc2VlZCIsInNjYW5fMSIsInNlcXVlbmNlRXF1YWwiLCJjb21wYXJlVG8iLCJjb21wYXJvciIsIlNlcXVlbmNlRXF1YWxPcGVyYXRvciIsIlNlcXVlbmNlRXF1YWxTdWJzY3JpYmVyIiwiX29uZUNvbXBsZXRlIiwiU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXIiLCJlbWl0IiwiY2hlY2tWYWx1ZXMiLCJhIiwiYXJlRXF1YWwiLCJuZXh0QiIsInNlcXVlbmNlRXF1YWxfMSIsInNoYXJlU3ViamVjdEZhY3RvcnkiLCJzaGFyZSIsInNoYXJlXzEiLCJzaW5nbGUiLCJTaW5nbGVPcGVyYXRvciIsIlNpbmdsZVN1YnNjcmliZXIiLCJzZWVuVmFsdWUiLCJhcHBseVNpbmdsZVZhbHVlIiwic2luZ2xlVmFsdWUiLCJzaW5nbGVfMSIsInNraXAiLCJTa2lwT3BlcmF0b3IiLCJTa2lwU3Vic2NyaWJlciIsInNraXBfMSIsInNraXBVbnRpbCIsIlNraXBVbnRpbE9wZXJhdG9yIiwiU2tpcFVudGlsU3Vic2NyaWJlciIsImlzSW5uZXJTdG9wcGVkIiwic2tpcFVudGlsXzEiLCJza2lwV2hpbGUiLCJTa2lwV2hpbGVPcGVyYXRvciIsIlNraXBXaGlsZVN1YnNjcmliZXIiLCJza2lwcGluZyIsInRyeUNhbGxQcmVkaWNhdGUiLCJza2lwV2hpbGVfMSIsInN0YXJ0V2l0aCIsInN0YXJ0V2l0aF8xIiwiSW1tZWRpYXRlRGVmaW5pdGlvbiIsInNldEltbWVkaWF0ZSIsImNsZWFySW1tZWRpYXRlIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJjYW5Vc2VQcm9jZXNzTmV4dFRpY2siLCJjcmVhdGVQcm9jZXNzTmV4dFRpY2tTZXRJbW1lZGlhdGUiLCJjYW5Vc2VQb3N0TWVzc2FnZSIsImNyZWF0ZVBvc3RNZXNzYWdlU2V0SW1tZWRpYXRlIiwiY2FuVXNlTWVzc2FnZUNoYW5uZWwiLCJjcmVhdGVNZXNzYWdlQ2hhbm5lbFNldEltbWVkaWF0ZSIsImNhblVzZVJlYWR5U3RhdGVDaGFuZ2UiLCJjcmVhdGVSZWFkeVN0YXRlQ2hhbmdlU2V0SW1tZWRpYXRlIiwiY3JlYXRlU2V0VGltZW91dFNldEltbWVkaWF0ZSIsImNpIiwiaGFuZGxlIiwiaW5zdGFuY2UiLCJpZGVudGlmeSIsInByb2Nlc3MiLCJNZXNzYWdlQ2hhbm5lbCIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXNfMSIsIm9sZE9uTWVzc2FnZSIsInBhcnRpYWxseUFwcGxpZWQiLCJGdW5jdGlvbiIsImFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMiLCJuZXh0VGljayIsInJ1bklmUHJlc2VudCIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJnbG9iYWxNZXNzYWdlSGFuZGxlciIsInRhc2siLCJjaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImRvYyIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJJbW1lZGlhdGVfMSIsIkFzYXBBY3Rpb24iLCJJbW1lZGlhdGUiLCJBc2FwU2NoZWR1bGVyIiwiQXNhcEFjdGlvbl8xIiwiQXNhcFNjaGVkdWxlcl8xIiwiYXNhcF8xIiwiU3Vic2NyaWJlT25PYnNlcnZhYmxlIiwiZGVsYXlUaW1lIiwiYXNhcCIsIlN1YnNjcmliZU9uT2JzZXJ2YWJsZV8xIiwic3Vic2NyaWJlT24iLCJTdWJzY3JpYmVPbk9wZXJhdG9yIiwic3Vic2NyaWJlT25fMSIsIl9zd2l0Y2giLCJTd2l0Y2hPcGVyYXRvciIsIlN3aXRjaFN1YnNjcmliZXIiLCJ1bnN1YnNjcmliZUlubmVyIiwic3dpdGNoXzEiLCJzd2l0Y2giLCJzd2l0Y2hNYXAiLCJTd2l0Y2hNYXBPcGVyYXRvciIsIlN3aXRjaE1hcFN1YnNjcmliZXIiLCJfdHJ5Tm90aWZ5TmV4dCIsInN3aXRjaE1hcF8xIiwic3dpdGNoTWFwVG8iLCJTd2l0Y2hNYXBUb09wZXJhdG9yIiwiU3dpdGNoTWFwVG9TdWJzY3JpYmVyIiwiaW5uZXIiLCJ0cnlSZXN1bHRTZWxlY3RvciIsInN3aXRjaE1hcFRvXzEiLCJ0YWtlIiwiVGFrZU9wZXJhdG9yIiwiVGFrZVN1YnNjcmliZXIiLCJ0YWtlXzEiLCJ0YWtlTGFzdCIsIlRha2VMYXN0T3BlcmF0b3IiLCJUYWtlTGFzdFN1YnNjcmliZXIiLCJyaW5nIiwidGFrZUxhc3RfMSIsInRha2VVbnRpbCIsIlRha2VVbnRpbE9wZXJhdG9yIiwiVGFrZVVudGlsU3Vic2NyaWJlciIsInRha2VVbnRpbF8xIiwidGFrZVdoaWxlIiwiVGFrZVdoaWxlT3BlcmF0b3IiLCJUYWtlV2hpbGVTdWJzY3JpYmVyIiwibmV4dE9yQ29tcGxldGUiLCJwcmVkaWNhdGVSZXN1bHQiLCJ0YWtlV2hpbGVfMSIsInRocm90dGxlIiwiVGhyb3R0bGVPcGVyYXRvciIsIlRocm90dGxlU3Vic2NyaWJlciIsInRyeUR1cmF0aW9uU2VsZWN0b3IiLCJlbWl0QW5kVGhyb3R0bGUiLCJ0aHJvdHRsZV8xIiwidGhyb3R0bGVUaW1lIiwiVGhyb3R0bGVUaW1lT3BlcmF0b3IiLCJUaHJvdHRsZVRpbWVTdWJzY3JpYmVyIiwidGhyb3R0bGVUaW1lXzEiLCJ0aW1lSW50ZXJ2YWwiLCJUaW1lSW50ZXJ2YWxPcGVyYXRvciIsIlRpbWVJbnRlcnZhbCIsIlRpbWVJbnRlcnZhbFN1YnNjcmliZXIiLCJsYXN0VGltZSIsInNwYW4iLCJ0aW1lSW50ZXJ2YWxfMSIsIlRpbWVvdXRFcnJvciIsIlRpbWVvdXRFcnJvcl8xIiwiZHVlIiwiYWJzb2x1dGVUaW1lb3V0Iiwid2FpdEZvciIsIlRpbWVvdXRPcGVyYXRvciIsImVycm9ySW5zdGFuY2UiLCJUaW1lb3V0U3Vic2NyaWJlciIsIl9wcmV2aW91c0luZGV4IiwiX2hhc0NvbXBsZXRlZCIsInNjaGVkdWxlVGltZW91dCIsImRpc3BhdGNoVGltZW91dCIsImN1cnJlbnRJbmRleCIsInByZXZpb3VzSW5kZXgiLCJub3RpZnlUaW1lb3V0IiwidGltZW91dF8xIiwidGltZW91dFdpdGgiLCJ3aXRoT2JzZXJ2YWJsZSIsIlRpbWVvdXRXaXRoT3BlcmF0b3IiLCJUaW1lb3V0V2l0aFN1YnNjcmliZXIiLCJ0aW1lb3V0U3Vic2NyaXB0aW9uIiwiaGFuZGxlVGltZW91dCIsInRpbWVvdXRTdGF0ZSIsInRpbWVvdXRXaXRoXzEiLCJ0aW1lc3RhbXAiLCJUaW1lc3RhbXBPcGVyYXRvciIsIlRpbWVzdGFtcCIsIlRpbWVzdGFtcFN1YnNjcmliZXIiLCJ0aW1lc3RhbXBfMSIsInRvQXJyYXkiLCJUb0FycmF5T3BlcmF0b3IiLCJUb0FycmF5U3Vic2NyaWJlciIsInRvQXJyYXlfMSIsInRvUHJvbWlzZSIsInRvUHJvbWlzZV8xIiwid2luZG93Qm91bmRhcmllcyIsIldpbmRvd09wZXJhdG9yIiwid2luZG93U3Vic2NyaWJlciIsIldpbmRvd1N1YnNjcmliZXIiLCJzb3VyY2VTdWJzY3JpcHRpb24iLCJvcGVuV2luZG93IiwicHJldldpbmRvdyIsIm5ld1dpbmRvdyIsIndpbmRvd18xIiwid2luZG93Q291bnQiLCJ3aW5kb3dTaXplIiwic3RhcnRXaW5kb3dFdmVyeSIsIldpbmRvd0NvdW50T3BlcmF0b3IiLCJXaW5kb3dDb3VudFN1YnNjcmliZXIiLCJ3aW5kb3dzIiwid2luZG93Q291bnRfMSIsIndpbmRvd1RpbWVTcGFuIiwid2luZG93Q3JlYXRpb25JbnRlcnZhbCIsIldpbmRvd1RpbWVPcGVyYXRvciIsIldpbmRvd1RpbWVTdWJzY3JpYmVyIiwiZGlzcGF0Y2hXaW5kb3dDbG9zZSIsImRpc3BhdGNoV2luZG93Q3JlYXRpb24iLCJ3aW5kb3dfMiIsImRpc3BhdGNoV2luZG93VGltZVNwYW5Pbmx5Iiwid2luZG93XzMiLCJ3aW5kb3dfNCIsImNsb3NlV2luZG93IiwidGltZVNwYW5TdGF0ZSIsIndpbmRvd1RpbWVfMSIsIndpbmRvd1RvZ2dsZSIsIldpbmRvd1RvZ2dsZU9wZXJhdG9yIiwiV2luZG93VG9nZ2xlU3Vic2NyaWJlciIsIm9wZW5TdWJzY3JpcHRpb24iLCJ3aW5kb3dUb2dnbGVfMSIsIndpbmRvd1doZW4iLCJ1bnN1YnNjcmliZUNsb3NpbmdOb3RpZmljYXRpb24iLCJjbG9zaW5nTm90aWZpY2F0aW9uIiwid2luZG93V2hlbl8xIiwid2l0aExhdGVzdEZyb20iLCJXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yIiwiV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyIiwiZm91bmQiLCJ3aXRoTGF0ZXN0RnJvbV8xIiwiemlwQWxsIiwiemlwQWxsXzEiLCJTdWJzY3JpcHRpb25Mb2ciLCJzdWJzY3JpYmVkRnJhbWUiLCJ1bnN1YnNjcmliZWRGcmFtZSIsIlN1YnNjcmlwdGlvbkxvZ18xIiwiU3Vic2NyaXB0aW9uTG9nZ2FibGUiLCJsb2dTdWJzY3JpYmVkRnJhbWUiLCJsb2dVbnN1YnNjcmliZWRGcmFtZSIsInN1YnNjcmlwdGlvbkxvZ3MiLCJvbGRTdWJzY3JpcHRpb25Mb2ciLCJhcHBseU1peGlucyIsImRlcml2ZWRDdG9yIiwiYmFzZUN0b3JzIiwiYmFzZUN0b3IiLCJwcm9wZXJ0eUtleXMiLCJsZW4yIiwibmFtZV8xIiwiU3Vic2NyaXB0aW9uTG9nZ2FibGVfMSIsImFwcGx5TWl4aW5zXzEiLCJDb2xkT2JzZXJ2YWJsZSIsIm1lc3NhZ2VzIiwic2NoZWR1bGVNZXNzYWdlcyIsIm1lc3NhZ2VzTGVuZ3RoIiwiZnJhbWUiLCJIb3RPYnNlcnZhYmxlIiwic2V0dXAiLCJWaXJ0dWFsVGltZVNjaGVkdWxlciIsIm1heEZyYW1lcyIsIlZpcnR1YWxBY3Rpb24iLCJmcmFtZVRpbWVGYWN0b3IiLCJzb3J0Iiwic29ydEFjdGlvbnMiLCJDb2xkT2JzZXJ2YWJsZV8xIiwiSG90T2JzZXJ2YWJsZV8xIiwiVmlydHVhbFRpbWVTY2hlZHVsZXJfMSIsImRlZmF1bHRNYXhGcmFtZSIsIlRlc3RTY2hlZHVsZXIiLCJhc3NlcnREZWVwRXF1YWwiLCJob3RPYnNlcnZhYmxlcyIsImNvbGRPYnNlcnZhYmxlcyIsImZsdXNoVGVzdHMiLCJjcmVhdGVUaW1lIiwibWFyYmxlcyIsImNyZWF0ZUNvbGRPYnNlcnZhYmxlIiwicGFyc2VNYXJibGVzIiwiY29sZCIsImNyZWF0ZUhvdE9ic2VydmFibGUiLCJtYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZSIsIm91dGVyRnJhbWUiLCJleHBlY3RPYnNlcnZhYmxlIiwidW5zdWJzY3JpcHRpb25NYXJibGVzIiwiYWN0dWFsIiwiZmx1c2hUZXN0IiwicmVhZHkiLCJ1bnN1YnNjcmlwdGlvbkZyYW1lIiwicGFyc2VNYXJibGVzQXNTdWJzY3JpcHRpb25zIiwiZXhwZWN0ZWQiLCJleHBlY3RTdWJzY3JpcHRpb25zIiwiYWN0dWFsU3Vic2NyaXB0aW9uTG9ncyIsIm1hcmJsZXNBcnJheSIsInJlYWR5Rmx1c2hUZXN0cyIsInRlc3QiLCJncm91cFN0YXJ0Iiwic3Vic2NyaXB0aW9uRnJhbWUiLCJtYXRlcmlhbGl6ZUlubmVyT2JzZXJ2YWJsZXMiLCJ0ZXN0TWVzc2FnZXMiLCJzdWJJbmRleCIsImZyYW1lT2Zmc2V0IiwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNDYW5jZWxBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvQ2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJBbmltYXRpb25GcmFtZV8xIiwiQW5pbWF0aW9uRnJhbWVBY3Rpb24iLCJBbmltYXRpb25GcmFtZSIsIkFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIiwiQW5pbWF0aW9uRnJhbWVBY3Rpb25fMSIsIkFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyXzEiLCJyZXF1aXJlJCQxNTIiLCJyZXF1aXJlJCQxNTEiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDIyIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDE5IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE2IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDEzIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEwIiwiVGVzdFNjaGVkdWxlcl8xIiwiYW5pbWF0aW9uRnJhbWVfMSIsImFuaW1hdGlvbkZyYW1lIiwiYWN0aW9ucyQiLCJzb2NrZXRPdXRnb2luZyQiLCJpbml0TW9kZWwiLCJjb25uZWN0ZWQiLCJtb2RlbCIsInZpZXciLCJ2IiwicGxhY2Vob2xkZXIiLCJhdXRvZm9jdXMiLCJpbnB1dCIsImhhbmRsZUlucHV0IiwiZm9jdXNFbGVtZW50IiwiZGlzYWJsZWQiLCJjbGljayIsImhhbmRsZUNsaWNrIiwicGFkZGluZ1RvcCIsImRpc3BsYXlNZXNzYWdlIiwiZm9jdXMiLCJ0cmltIiwib25saW5lJCIsIm5hdmlnYXRvciIsIm9uTGluZSIsInNvY2tldENvbm5lY3RlZCQiLCJjb25uZWN0ZWQkIiwib25saW5lIiwic29ja2V0SW5jb21pbmckIiwiZWZmZWN0cyQiLCJtc2dFdmVudCIsIm1vZGVsJCIsImdldEVsZW1lbnRCeUlkIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFpQixVQUFTQSxHQUFULEVBQWNDLElBQWQsRUFBb0JDLFFBQXBCLEVBQThCQyxJQUE5QixFQUFvQ0MsR0FBcEMsRUFBeUM7TUFDcERDLE1BQU1KLFNBQVNLLFNBQVQsR0FBcUJBLFNBQXJCLEdBQWlDTCxLQUFLSSxHQUFoRDtTQUNPLEVBQUNMLEtBQUtBLEdBQU4sRUFBV0MsTUFBTUEsSUFBakIsRUFBdUJDLFVBQVVBLFFBQWpDO1VBQ09DLElBRFAsRUFDYUMsS0FBS0EsR0FEbEIsRUFDdUJDLEtBQUtBLEdBRDVCLEVBQVA7Q0FGRjs7QUNBQSxXQUFpQjtTQUNSRSxNQUFNQyxPQURFO2FBRUosVUFBU0MsQ0FBVCxFQUFZO1dBQVMsT0FBT0EsQ0FBUCxLQUFh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
